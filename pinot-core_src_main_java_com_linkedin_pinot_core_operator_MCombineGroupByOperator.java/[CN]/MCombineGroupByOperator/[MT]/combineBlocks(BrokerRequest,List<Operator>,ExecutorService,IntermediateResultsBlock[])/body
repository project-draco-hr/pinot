{
  List<AggregationInfo> aggregationsInfo=brokerRequest.getAggregationsInfo();
  final List<AggregationFunction> aggregationFunctions=AggregationFunctionFactory.getAggregationFunction(brokerRequest);
  final int numAggrFunctions=aggregationsInfo.size();
  final int numOperators=operators.size();
  final Map<String,Serializable[]> resultsMap=new ConcurrentHashMap<>();
  final CountDownLatch operatorLatch=new CountDownLatch(numOperators);
  for (int i=0; i < numOperators; i++) {
    final int index=i;
    executorService.execute(new TraceRunnable(){
      @Override public void runJob(){
        AggregationGroupByResult groupByResult;
        blocks[index]=(IntermediateResultsBlock)operators.get(index).nextBlock();
        if (blocks[index] == null) {
          return;
        }
        groupByResult=blocks[index].getAggregationGroupByResult();
        if (groupByResult == null) {
          return;
        }
        final Iterator<GroupKeyGenerator.GroupKey> groupKeyIterator=groupByResult.getGroupKeyIterator();
        while (groupKeyIterator.hasNext()) {
          GroupKeyGenerator.GroupKey groupKey=groupKeyIterator.next();
          String groupKeyString=groupKey.getStringKey();
          int lockIndex=(groupKeyString.hashCode() & Integer.MAX_VALUE) % NUM_LOCKS;
synchronized (_locks[(lockIndex)]) {
            Serializable[] results=resultsMap.get(groupKeyString);
            if (results == null) {
              results=new Serializable[numAggrFunctions];
              for (int j=0; j < numAggrFunctions; j++) {
                results[j]=groupByResult.getResultForKey(groupKey,j);
              }
              resultsMap.put(groupKeyString,results);
            }
 else {
              for (int j=0; j < numAggrFunctions; j++) {
                results[j]=aggregationFunctions.get(j).combineTwoValues(results[j],groupByResult.getResultForKey(groupKey,j));
              }
            }
          }
        }
        operatorLatch.countDown();
      }
    }
);
  }
  operatorLatch.await(_timeOutMs,TimeUnit.SECONDS);
  List<Map<String,Serializable>> untrimmedResults=buildMergedResults(resultsMap,numAggrFunctions);
  return buildResultBlock(aggregationFunctions,untrimmedResults,blocks);
}
