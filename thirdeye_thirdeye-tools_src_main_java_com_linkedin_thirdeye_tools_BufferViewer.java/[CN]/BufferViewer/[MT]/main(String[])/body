{
  Options options=new Options();
  options.addOption("excludeZeroValues",false,"Should exclude rows for which all metric values are zero");
  CommandLine commandLine=new GnuParser().parse(options,args);
  args=commandLine.getArgs();
  boolean excludeZeroValues=commandLine.hasOption("excludeZeroValues");
  if (args.length != 2) {
    throw new IllegalArgumentException("usage: collectionDir nodeId");
  }
  UUID nodeId=UUID.fromString(args[1]);
  File dataDir=new File(args[0],StarTreeConstants.DATA_DIR_NAME);
  File dimensionStoreDir=new File(dataDir,StarTreeConstants.DIMENSION_STORE);
  File[] dimensionIndexFiles=dimensionStoreDir.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return name.endsWith(StarTreeConstants.INDEX_FILE_SUFFIX);
    }
  }
);
  if (dimensionIndexFiles == null) {
    throw new IllegalStateException("No index files in " + dimensionStoreDir);
  }
  List<DimensionIndexEntry> nodeDimensionIndexEntries=new ArrayList<DimensionIndexEntry>();
  for (  File dimensionIndexFile : dimensionIndexFiles) {
    List<DimensionIndexEntry> dimensionIndexEntries=StorageUtils.readDimensionIndex(dimensionIndexFile);
    for (    DimensionIndexEntry indexEntry : dimensionIndexEntries) {
      if (indexEntry.getNodeId().equals(nodeId)) {
        nodeDimensionIndexEntries.add(indexEntry);
      }
    }
  }
  if (nodeDimensionIndexEntries.size() != 1) {
    throw new IllegalStateException("There must be exactly one dimension index entry per node. " + "There are " + nodeDimensionIndexEntries.size());
  }
  DimensionIndexEntry nodeDimensionIndexEntry=nodeDimensionIndexEntries.get(0);
  StarTreeConfig starTreeConfig=StarTreeConfig.decode(new FileInputStream(new File(args[0],StarTreeConstants.CONFIG_FILE_NAME)));
  DimensionDictionary dimensionDictionary=getDictionary(nodeDimensionIndexEntry,new File(dimensionStoreDir,nodeDimensionIndexEntry.getFileId().toString() + StarTreeConstants.DICT_FILE_SUFFIX));
  ByteBuffer dimensionBuffer=getDimensionBuffer(nodeDimensionIndexEntry,new File(dimensionStoreDir,nodeDimensionIndexEntry.getFileId().toString() + StarTreeConstants.BUFFER_FILE_SUFFIX));
  DimensionStore dimensionStore=new DimensionStoreImmutableImpl(starTreeConfig,dimensionBuffer,dimensionDictionary);
  File metricStoreDir=new File(dataDir,StarTreeConstants.METRIC_STORE);
  File[] metricIndexFiles=metricStoreDir.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return name.endsWith(StarTreeConstants.INDEX_FILE_SUFFIX);
    }
  }
);
  if (metricIndexFiles == null) {
    throw new IllegalStateException("No index files in " + metricStoreDir);
  }
  List<MetricIndexEntry> nodeMetricIndexEntries=new ArrayList<MetricIndexEntry>();
  Set<UUID> fileIds=new HashSet<UUID>();
  for (  File metricIndexFile : metricIndexFiles) {
    List<MetricIndexEntry> metricIndexEntries=StorageUtils.readMetricIndex(metricIndexFile);
    for (    MetricIndexEntry metricIndexEntry : metricIndexEntries) {
      if (metricIndexEntry.getNodeId().equals(nodeId)) {
        nodeMetricIndexEntries.add(metricIndexEntry);
        fileIds.add(metricIndexEntry.getFileId());
      }
    }
  }
  if (nodeMetricIndexEntries.isEmpty()) {
    throw new IllegalStateException("No metric index entries for " + nodeId);
  }
  Map<UUID,ByteBuffer> metricBuffers=new HashMap<UUID,ByteBuffer>();
  for (  UUID fileId : fileIds) {
    File bufferFile=new File(metricStoreDir,fileId + StarTreeConstants.BUFFER_FILE_SUFFIX);
    metricBuffers.put(fileId,mapBuffer(bufferFile));
  }
  ConcurrentMap<TimeRange,List<ByteBuffer>> projectedBuffers=new ConcurrentHashMap<TimeRange,List<ByteBuffer>>();
  for (  MetricIndexEntry indexEntry : nodeMetricIndexEntries) {
    ByteBuffer metricBuffer=getMetricBuffer(indexEntry,metricBuffers);
    List<ByteBuffer> buffers=projectedBuffers.get(indexEntry.getTimeRange());
    if (buffers == null) {
      buffers=new ArrayList<ByteBuffer>();
      projectedBuffers.put(indexEntry.getTimeRange(),buffers);
    }
    buffers.add(metricBuffer);
  }
  MetricStore metricStore=new MetricStoreImmutableImpl(starTreeConfig,projectedBuffers);
  for (  DimensionKey dimensionKey : dimensionStore.getDimensionKeys()) {
    MetricTimeSeries timeSeries=metricStore.getTimeSeries(dimensionStore.findMatchingKeys(dimensionKey).values(),null);
    List<Long> times=new ArrayList<Long>(timeSeries.getTimeWindowSet());
    Collections.sort(times);
    Number[] current=new Number[starTreeConfig.getMetrics().size()];
    for (    Long time : times) {
      boolean nonZero=false;
      for (int i=0; i < starTreeConfig.getMetrics().size(); i++) {
        current[i]=timeSeries.get(time,starTreeConfig.getMetrics().get(i).getName());
        if (!NumberUtils.isZero(current[i],starTreeConfig.getMetrics().get(i).getType())) {
          nonZero=true;
        }
      }
      if (!excludeZeroValues || nonZero) {
        System.out.print(dimensionKey + "\t@" + time);
        for (        Number value : current) {
          System.out.print("\t" + value);
        }
        System.out.println();
      }
    }
  }
}
