{
  long detectionIntervalInMillis=TimeGranularityUtils.toMillis(detectionInterval);
  long latestTimeDataAvailable=ThirdEyeServerUtils.getLatestTime(config.getThirdEyeServerHost(),config.getThirdEyeServerPort(),config.getCollectionName());
  long prevTime=TimeGranularityUtils.truncateBy(latestTimeDataAvailable,detectionInterval);
  while (true) {
    try {
      latestTimeDataAvailable=ThirdEyeServerUtils.getLatestTime(config.getThirdEyeServerHost(),config.getThirdEyeServerPort(),config.getCollectionName());
      long nextTime=prevTime;
      while (nextTime + detectionIntervalInMillis <= latestTimeDataAvailable) {
        nextTime+=detectionIntervalInMillis;
      }
      if (nextTime != prevTime) {
        ;
        LOGGER.info("begin processing for {} to {}",prevTime,nextTime);
        final TimeRange taskTimeRange=new TimeRange(prevTime,nextTime);
        new Thread(new Runnable(){
          @Override public void run(){
            try {
              new ThirdEyeAnomalyDetection(config,taskTimeRange).call();
            }
 catch (            Exception e) {
              LOGGER.error("uncaught exception",e);
            }
          }
        }
).start();
        prevTime=nextTime;
      }
 else {
        LOGGER.info("no new data available, polling again at {} for {}",DateTime.now().plusMillis((int)pollingMillis),new DateTime(prevTime + detectionIntervalInMillis));
      }
    }
 catch (    IOException e) {
      LOGGER.error("error in polling",e);
    }
 finally {
      Thread.sleep(pollingMillis);
    }
  }
}
