{
  if (e == null) {
    return new Integer[]{-1};
  }
  final Object[] multiValues=(Object[])e;
  final Integer[] ret=new Integer[multiValues.length];
switch (spec.getDataType()) {
case INT:
    for (int i=0; i < multiValues.length; i++) {
      ret[i]=searchableByteBuffer.binarySearch(0,((Integer)multiValues[i]).intValue());
    }
  break;
case FLOAT:
for (int i=0; i < multiValues.length; i++) {
  ret[i]=searchableByteBuffer.binarySearch(0,((Float)multiValues[i]).floatValue());
}
break;
case LONG:
for (int i=0; i < multiValues.length; i++) {
ret[i]=searchableByteBuffer.binarySearch(0,((Long)multiValues[i]).longValue());
}
break;
case DOUBLE:
for (int i=0; i < multiValues.length; i++) {
ret[i]=searchableByteBuffer.binarySearch(0,((Double)multiValues[i]).doubleValue());
}
break;
case STRING:
case BOOLEAN:
for (int i=0; i < multiValues.length; i++) {
if (multiValues[i] == null) {
ret[i]=-1;
}
 else {
final StringBuilder bld=new StringBuilder();
for (int j=0; j < (stringColumnMaxLength - ((String)multiValues[i]).length()); j++) {
bld.append(V1Constants.Str.STRING_PAD_CHAR);
}
bld.append(multiValues[i].toString());
ret[i]=searchableByteBuffer.binarySearch(0,bld.toString());
}
}
break;
default :
break;
}
return ret;
}
