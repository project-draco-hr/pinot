{
switch (spec.getDataType()) {
case INT:
    final FixedByteSingleValueMultiColWriter intDictionaryWrite=new FixedByteSingleValueMultiColWriter(dictionaryFile,rowCount,1,V1Constants.Dict.INT_DICTIONARY_COL_SIZE);
  intValueToIndexMap=new Int2IntOpenHashMap(rowCount);
int[] sortedInts=(int[])sortedList;
for (int i=0; i < rowCount; i++) {
final int entry=sortedInts[i];
intDictionaryWrite.setInt(i,0,entry);
intValueToIndexMap.put(entry,i);
}
intDictionaryWrite.close();
break;
case FLOAT:
final FixedByteSingleValueMultiColWriter floatDictionaryWrite=new FixedByteSingleValueMultiColWriter(dictionaryFile,rowCount,1,V1Constants.Dict.FLOAT_DICTIONARY_COL_SIZE);
floatValueToIndexMap=new Float2IntOpenHashMap(rowCount);
float[] sortedFloats=(float[])sortedList;
for (int i=0; i < rowCount; i++) {
final float entry=sortedFloats[i];
floatDictionaryWrite.setFloat(i,0,entry);
floatValueToIndexMap.put(entry,i);
}
floatDictionaryWrite.close();
break;
case LONG:
final FixedByteSingleValueMultiColWriter longDictionaryWrite=new FixedByteSingleValueMultiColWriter(dictionaryFile,rowCount,1,V1Constants.Dict.LONG_DICTIONARY_COL_SIZE);
longValueToIndexMap=new Long2IntOpenHashMap(rowCount);
long[] sortedLongs=(long[])sortedList;
for (int i=0; i < rowCount; i++) {
final long entry=sortedLongs[i];
longDictionaryWrite.setLong(i,0,entry);
longValueToIndexMap.put(entry,i);
}
longDictionaryWrite.close();
break;
case DOUBLE:
final FixedByteSingleValueMultiColWriter doubleDictionaryWrite=new FixedByteSingleValueMultiColWriter(dictionaryFile,rowCount,1,V1Constants.Dict.DOUBLE_DICTIONARY_COL_SIZE);
doubleValueToIndexMap=new Double2IntOpenHashMap(rowCount);
double[] sortedDoubles=(double[])sortedList;
for (int i=0; i < rowCount; i++) {
final double entry=sortedDoubles[i];
doubleDictionaryWrite.setDouble(i,0,entry);
doubleValueToIndexMap.put(entry,i);
}
doubleDictionaryWrite.close();
break;
case STRING:
case BOOLEAN:
Object[] sortedObjects=(Object[])sortedList;
for (final Object e : sortedObjects) {
String val=e.toString();
int length=val.getBytes(Charset.forName("UTF-8")).length;
if (stringColumnMaxLength < length) {
stringColumnMaxLength=length;
}
}
final FixedByteSingleValueMultiColWriter stringDictionaryWrite=new FixedByteSingleValueMultiColWriter(dictionaryFile,rowCount,1,new int[]{stringColumnMaxLength});
final String[] revised=new String[rowCount];
for (int i=0; i < rowCount; i++) {
final String toWrite=sortedObjects[i].toString();
final int padding=stringColumnMaxLength - toWrite.getBytes(Charset.forName("UTF-8")).length;
final StringBuilder bld=new StringBuilder();
bld.append(toWrite);
for (int j=0; j < padding; j++) {
bld.append(V1Constants.Str.STRING_PAD_CHAR);
}
String entry=bld.toString();
revised[i]=entry;
assert(revised[i].getBytes(Charset.forName("UTF-8")).length == stringColumnMaxLength);
}
Arrays.sort(revised);
stringValueToIndexMap=new Object2IntOpenHashMap<>(rowCount);
for (int i=0; i < revised.length; i++) {
stringDictionaryWrite.setString(i,0,revised[i]);
stringValueToIndexMap.put(revised[i],i);
}
stringDictionaryWrite.close();
break;
default :
throw new RuntimeException("Unhandled type " + spec.getDataType());
}
}
