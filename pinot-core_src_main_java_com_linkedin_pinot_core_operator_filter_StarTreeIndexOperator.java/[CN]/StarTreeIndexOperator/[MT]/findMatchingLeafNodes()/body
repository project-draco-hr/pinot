{
  Queue<SearchEntry> matchedEntries=new LinkedList<>();
  Queue<SearchEntry> searchQueue=new LinkedList<>();
  HashBiMap<String,Integer> dimensionIndexToNameMapping=segment.getStarTree().getDimensionNameToIndexMap();
  SearchEntry startEntry=new SearchEntry();
  startEntry.starTreeIndexnode=segment.getStarTree().getRoot();
  startEntry.remainingPredicates=new HashSet<>(eligibleEqualityPredicatesMap.keySet());
  searchQueue.add(startEntry);
  while (!searchQueue.isEmpty()) {
    SearchEntry searchEntry=searchQueue.remove();
    StarTreeIndexNode current=searchEntry.starTreeIndexnode;
    HashSet<String> remainingColumnsToFilter=searchEntry.remainingPredicates;
    if (current.isLeaf()) {
      matchedEntries.add(searchEntry);
      continue;
    }
    String nextDimension=dimensionIndexToNameMapping.inverse().get(current.getChildDimensionName());
    HashSet<String> newRemainingPredicates=new HashSet<>();
    newRemainingPredicates.addAll(remainingColumnsToFilter);
    newRemainingPredicates.remove(nextDimension);
    if (!(inEligiblePredicatesMap.containsKey(nextDimension) || nonEqualityPredicatesMap.containsKey(nextDimension))) {
      int nextValueId;
      if (eligibleEqualityPredicatesMap.containsKey(nextDimension)) {
        nextValueId=eligibleEqualityPredicatesMap.get(nextDimension).dictionaryId;
      }
 else {
        nextValueId=StarTreeIndexNode.all();
      }
      SearchEntry newEntry=new SearchEntry();
      newEntry.starTreeIndexnode=current.getChildren().get(nextValueId);
      if (newEntry.starTreeIndexnode != null) {
        newEntry.remainingPredicates=newRemainingPredicates;
        searchQueue.add(newEntry);
      }
    }
 else {
      for (      Map.Entry<Integer,StarTreeIndexNode> entry : current.getChildren().entrySet()) {
        if (entry.getKey() != StarTreeIndexNode.all()) {
          SearchEntry newEntry=new SearchEntry();
          newEntry.starTreeIndexnode=entry.getValue();
          newEntry.remainingPredicates=newRemainingPredicates;
          searchQueue.add(newEntry);
        }
      }
    }
  }
  return matchedEntries;
}
