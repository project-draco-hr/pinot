{
  if (node.isLeaf()) {
    StarTreeTableRange range=builder.getDocumentIdRange(node.getNodeId());
    StarTreeTable subTable=builder.getTable().view(range.getStartDocumentId(),range.getDocumentCount());
    List<List<Integer>> sortedValues=new ArrayList<List<Integer>>();
    Iterator<StarTreeTableRow> itr=subTable.getAllCombinations();
    while (itr.hasNext()) {
      List<Integer> copy=new ArrayList<>(itr.next().getDimensions());
      sortedValues.add(copy);
    }
    final List<Integer> pathDimensions=node.getPathDimensions();
    Collections.sort(sortedValues,new Comparator<List<Integer>>(){
      @Override public int compare(      List<Integer> o1,      List<Integer> o2){
        for (        Integer dimension : pathDimensions) {
          Integer v1=o1.get(dimension);
          Integer v2=o2.get(dimension);
          if (!v1.equals(v2)) {
            return v1.compareTo(v2);
          }
        }
        return 0;
      }
    }
);
    itr=subTable.getAllCombinations();
    int idx=0;
    while (itr.hasNext()) {
      Assert.assertEquals(itr.next().getDimensions(),sortedValues.get(idx++));
    }
    Map<Integer,Integer> pathValues=node.getPathValues();
    itr=subTable.getAllCombinations();
    while (itr.hasNext()) {
      List<Integer> next=itr.next().getDimensions();
      for (      Map.Entry<Integer,Integer> entry : pathValues.entrySet()) {
        Assert.assertEquals(next.get(entry.getKey()),entry.getValue());
      }
    }
    if (pathDimensions.size() < builder.getSplitOrder().size()) {
      Assert.assertTrue(sortedValues.size() <= builder.getMaxLeafRecords(),sortedValues.size() + " is > " + builder.getMaxLeafRecords());
    }
  }
 else {
    for (    StarTreeIndexNode child : node.getChildren().values()) {
      checkSubTable(builder,child);
    }
  }
}
