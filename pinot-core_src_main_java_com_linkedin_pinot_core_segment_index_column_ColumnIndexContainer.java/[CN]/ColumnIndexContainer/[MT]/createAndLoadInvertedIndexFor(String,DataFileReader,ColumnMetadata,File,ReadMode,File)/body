{
  File inProgress=new File(column + "_inv.inprogress");
  if (!inProgress.exists() && invertedIndexFile.exists()) {
    LOGGER.warn("found inverted index for colummn {}, loading it",column);
    return new BitmapInvertedIndexReader(invertedIndexFile,metadata.getCardinality(),mode == ReadMode.mmap);
  }
  FileUtils.touch(inProgress);
  if (invertedIndexFile.exists()) {
    FileUtils.deleteQuietly(invertedIndexFile);
  }
  LOGGER.warn("did not find inverted index for colummn {}, creating it",column);
  InvertedIndexCreator creator=new OffHeapBitmapInvertedIndexCreator(indexDir,metadata.getCardinality(),metadata.getTotalRawDocs(),metadata.getTotalNumberOfEntries(),metadata.toFieldSpec());
  if (!metadata.isSingleValue()) {
    SingleColumnMultiValueReader mvFwdIndex=(SingleColumnMultiValueReader)fwdIndex;
    int[] dictIds=new int[metadata.getMaxNumberOfMultiValues()];
    for (int i=0; i < metadata.getTotalRawDocs(); i++) {
      int len=mvFwdIndex.getIntArray(i,dictIds);
      creator.add(i,dictIds,len);
    }
  }
 else {
    FixedBitSingleValueReader svFwdIndex=(FixedBitSingleValueReader)fwdIndex;
    for (int i=0; i < metadata.getTotalRawDocs(); i++) {
      creator.add(i,svFwdIndex.getInt(i));
    }
  }
  creator.seal();
  FileUtils.deleteQuietly(inProgress);
  LOGGER.warn("created inverted index for colummn {}, loading it",column);
  return new BitmapInvertedIndexReader(invertedIndexFile,metadata.getCardinality(),mode == ReadMode.mmap);
}
