{
  int minCount=rawDimensionKey.getDimensionValues().length + 1;
  DimensionKey selectedRollup=null;
  LOGGER.info("Start find roll up for {}",rawDimensionKey);
  for (  Entry<DimensionKey,MetricTimeSeries> entry : possibleRollups.entrySet()) {
    DimensionKey key=entry.getKey();
    LOGGER.info("Trying {}",key);
    String[] dimensionsValues=key.getDimensionValues();
    if (func.isAboveThreshold(entry.getValue())) {
      LOGGER.debug("passed threshold");
      int count=0;
      for (      String val : dimensionsValues) {
        if ("?".equalsIgnoreCase(val)) {
          count+=1;
        }
      }
      LOGGER.info("count:{} mincount:{}",count,minCount);
      if (count < minCount) {
        minCount=count;
        selectedRollup=key;
        LOGGER.info("setting selectedrollup:{}",selectedRollup);
      }
    }
  }
  if (selectedRollup == null) {
    if (possibleRollups.size() < rawDimensionKey.getDimensionValues().length) {
      throw new IllegalStateException("Some rollup combinations are missing - " + "Rollup order in config could be missing some dimensions");
    }
    StringBuilder sb=new StringBuilder();
    for (    Entry<DimensionKey,MetricTimeSeries> entry : possibleRollups.entrySet()) {
      sb.append(entry.getKey());
      sb.append("=");
      sb.append(entry.getValue());
      sb.append("\n");
    }
    LOGGER.error("cannot find roll up for {} possiblerollups:{}",rawDimensionKey,sb.toString());
  }
  return selectedRollup;
}
