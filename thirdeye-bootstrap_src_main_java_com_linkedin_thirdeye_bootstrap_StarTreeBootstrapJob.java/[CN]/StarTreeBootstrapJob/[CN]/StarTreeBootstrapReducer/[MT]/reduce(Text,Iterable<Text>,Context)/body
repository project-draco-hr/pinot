{
  Map<Map<String,String>,Map<Long,List<StarTreeRecord>>> groupedRecords=new HashMap<Map<String,String>,Map<Long,List<StarTreeRecord>>>();
  for (  Text tsvRecord : tsvRecords) {
    int idx=0;
    String[] tokens=tsvRecord.toString().split("\t");
    StarTreeRecordImpl.Builder builder=new StarTreeRecordImpl.Builder();
    for (    String dimensionName : config.getDimensionNames()) {
      builder.setDimensionValue(dimensionName,tokens[idx++]);
    }
    for (    String metricName : config.getMetricNames()) {
      builder.setMetricValue(metricName,Long.valueOf(tokens[idx++]));
    }
    builder.setTime(Long.valueOf(tokens[idx]));
    StarTreeRecord record=builder.build();
    Map<Long,List<StarTreeRecord>> timeBucket=groupedRecords.get(record.getDimensionValues());
    if (timeBucket == null) {
      timeBucket=new HashMap<Long,List<StarTreeRecord>>(numTimeBuckets);
      groupedRecords.put(record.getDimensionValues(),timeBucket);
    }
    List<StarTreeRecord> records=timeBucket.get(record.getTime());
    if (records == null) {
      records=new ArrayList<StarTreeRecord>();
      timeBucket.put(record.getTime(),records);
    }
    records.add(record);
  }
  List<StarTreeRecord> mergedRecords=new ArrayList<StarTreeRecord>();
  for (  Map.Entry<Map<String,String>,Map<Long,List<StarTreeRecord>>> e1 : groupedRecords.entrySet()) {
    Map<String,String> combination=e1.getKey();
    Map<Long,List<StarTreeRecord>> timeGroups=e1.getValue();
    Long latestTime=null;
    List<StarTreeRecord> latestRecords=null;
    for (    Map.Entry<Long,List<StarTreeRecord>> e2 : timeGroups.entrySet()) {
      if (latestTime == null || e2.getKey() > latestTime) {
        latestTime=e2.getKey();
        latestRecords=e2.getValue();
      }
    }
    if (latestRecords == null) {
      throw new IllegalStateException("Could not find latest records for combination " + combination);
    }
    mergedRecords.add(StarTreeUtils.merge(latestRecords));
  }
  int nextValueId=StarTreeConstants.FIRST_VALUE;
  Map<String,Map<String,Integer>> forwardIndex=new HashMap<String,Map<String,Integer>>();
  for (  StarTreeRecord record : mergedRecords) {
    for (    String dimensionName : config.getDimensionNames()) {
      Map<String,Integer> forward=forwardIndex.get(dimensionName);
      if (forward == null) {
        forward=new HashMap<String,Integer>();
        forwardIndex.put(dimensionName,forward);
      }
      String dimensionValue=record.getDimensionValues().get(dimensionName);
      Integer valueId=forward.get(dimensionValue);
      if (valueId == null) {
        forward.put(dimensionValue,nextValueId++);
      }
    }
  }
  int bufferSize=mergedRecords.size() * (config.getDimensionNames().size() * Integer.SIZE / 8 + (config.getMetricNames().size() + 1) * numTimeBuckets * Long.SIZE / 8);
  if (buffer == null || bufferSize > buffer.capacity()) {
    buffer=ByteBuffer.allocate(bufferSize);
  }
  buffer.clear();
  StarTreeRecordStoreCircularBufferImpl.fillBuffer(buffer,config.getDimensionNames(),config.getMetricNames(),forwardIndex,mergedRecords,numTimeBuckets,true);
  buffer.flip();
  Path bufferPath=new Path(outputPath,nodeId.toString() + StarTreeRecordStoreFactoryCircularBufferHdfsImpl.BUFFER_SUFFIX);
  OutputStream outputStream=FileSystem.get(context.getConfiguration()).create(bufferPath,true);
  WritableByteChannel channel=Channels.newChannel(outputStream);
  channel.write(buffer);
  outputStream.flush();
  outputStream.close();
  Path indexPath=new Path(outputPath,nodeId.toString() + StarTreeRecordStoreFactoryCircularBufferHdfsImpl.INDEX_SUFFIX);
  outputStream=FileSystem.get(context.getConfiguration()).create(indexPath,true);
  OBJECT_MAPPER.writeValue(outputStream,forwardIndex);
  outputStream.flush();
  outputStream.close();
}
