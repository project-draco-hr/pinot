{
  Operator ret=null;
  if (null == filterQueryTree) {
    return null;
  }
  final List<FilterQueryTree> childFilters=filterQueryTree.getChildren();
  final boolean isLeaf=(childFilters == null) || childFilters.isEmpty();
  if (!isLeaf) {
    List<Operator> scanBasedOperators=new ArrayList<Operator>();
    List<Operator> invertedIndexRelatedOperators=new ArrayList<Operator>();
    for (    final FilterQueryTree query : childFilters) {
      Operator childOperator=constructPhysicalOperator(query);
      if (isOpearatorInvertedIndexInvolved(childOperator)) {
        invertedIndexRelatedOperators.add(childOperator);
      }
 else {
        scanBasedOperators.add(childOperator);
      }
    }
    final FilterOperator filterType=filterQueryTree.getOperator();
switch (filterType) {
case AND:
      if (0 == scanBasedOperators.size()) {
        ret=new BBitmapOnlyAndOperator(invertedIndexRelatedOperators);
      }
 else {
        Operator bitMapAndOperator=new BBitmapOnlyAndOperator(invertedIndexRelatedOperators);
        scanBasedOperators.set(scanBasedOperators.size(),scanBasedOperators.get(0));
        scanBasedOperators.set(0,bitMapAndOperator);
        ret=new MAndOperator(scanBasedOperators);
      }
    break;
case OR:
  if (0 == scanBasedOperators.size()) {
    ret=new BBitmapOnlyOrOperator(invertedIndexRelatedOperators);
  }
 else {
    Operator bitMapOrOperator=new BBitmapOnlyOrOperator(invertedIndexRelatedOperators);
    scanBasedOperators.set(scanBasedOperators.size(),scanBasedOperators.get(0));
    scanBasedOperators.set(0,bitMapOrOperator);
    ret=new MOrOperator(scanBasedOperators);
  }
break;
default :
throw new UnsupportedOperationException("Not support filter type - " + filterType + " with children operators");
}
}
 else {
final FilterOperator filterType=filterQueryTree.getOperator();
final String column=filterQueryTree.getColumn();
Predicate predicate=null;
final List<String> value=filterQueryTree.getValue();
switch (filterType) {
case EQUALITY:
predicate=new EqPredicate(column,value);
break;
case RANGE:
predicate=new RangePredicate(column,value);
break;
case REGEX:
predicate=new RegexPredicate(column,value);
break;
case NOT:
predicate=new NEqPredicate(column,value);
break;
case NOT_IN:
predicate=new NotInPredicate(column,value);
break;
case IN:
predicate=new InPredicate(column,value);
break;
}
DataSource ds;
if (predicate != null) {
ds=_segment.getDataSource(column,predicate);
}
 else {
ds=_segment.getDataSource(column);
}
ret=ds;
}
return ret;
}
