{
  String rootDir=args[0];
  File[] segmentDirs=new File(rootDir).listFiles();
  String query=args[1];
  AtomicLong[] globalSums;
  AtomicInteger totalDocsMatched=new AtomicInteger(0);
  PQLCompiler compiler=new PQLCompiler(new HashMap<String,String[]>());
  JSONObject jsonObject=compiler.compile(query);
  BrokerRequest brokerRequest=RequestConverter.fromJSON(jsonObject);
  List<AggregationInfo> aggregationsInfo=brokerRequest.getAggregationsInfo();
  String[] columns=new String[aggregationsInfo.size()];
  globalSums=new AtomicLong[columns.length];
  for (int i=0; i < aggregationsInfo.size(); i++) {
    AggregationInfo aggregationInfo=aggregationsInfo.get(i);
    String columnName=aggregationInfo.getAggregationParams().get("column");
    System.out.println(aggregationInfo.getAggregationType());
    columns[i]=columnName;
    globalSums[i]=new AtomicLong(0);
  }
  List<Callable<Void>> segmentProcessors=new ArrayList<>();
  long[] timesSpent=new long[segmentDirs.length];
  for (int i=0; i < segmentDirs.length; i++) {
    File indexSegmentDir=segmentDirs[i];
    if (indexSegmentDir.getName().indexOf("_pricing") < 0) {
      continue;
    }
    System.out.println("Loading " + indexSegmentDir.getName());
    Configuration tableDataManagerConfig=new PropertiesConfiguration();
    List<String> invertedColumns=new ArrayList<>();
    FilenameFilter filter=new FilenameFilter(){
      @Override public boolean accept(      File dir,      String name){
        return name.endsWith(".bitmap.inv");
      }
    }
;
    String[] indexFiles=indexSegmentDir.list(filter);
    for (    String indexFileName : indexFiles) {
      invertedColumns.add(indexFileName.replace(".bitmap.inv",""));
    }
    tableDataManagerConfig.setProperty(IndexLoadingConfigMetadata.KEY_OF_LOADING_INVERTED_INDEX,invertedColumns);
    IndexLoadingConfigMetadata indexLoadingConfigMetadata=new IndexLoadingConfigMetadata(tableDataManagerConfig);
    IndexSegmentImpl indexSegmentImpl=(IndexSegmentImpl)Loaders.IndexSegment.load(indexSegmentDir,ReadMode.heap,indexLoadingConfigMetadata);
    segmentProcessors.add(new SegmentProcessor(i,indexSegmentImpl,brokerRequest,columns,globalSums,totalDocsMatched,timesSpent));
  }
  ExecutorService executorService=Executors.newWorkStealingPool();
  for (int run=0; run < 5; run++) {
    for (    AtomicLong globalSum : globalSums) {
      globalSum.set(0);
    }
    totalDocsMatched.set(0);
    long start=System.currentTimeMillis();
    List<Future<Void>> futures=executorService.invokeAll(segmentProcessors);
    for (int i=0; i < futures.size(); i++) {
      futures.get(i).get();
    }
    long end=System.currentTimeMillis();
    System.out.println("Total docs matched:" + totalDocsMatched + " sum:"+ Arrays.toString(globalSums)+ " took:"+ (end - start));
    System.out.println("Times spent:" + Arrays.toString(timesSpent));
  }
  System.exit(0);
}
