{
  long trainStartInput=Collections.min(series.getTimeWindowSet());
  long trainEndInput=Collections.max(series.getTimeWindowSet());
  long bucketMillis=bucketUnit.toMillis(bucketSize);
  Set<Long> omitTimestamps=new HashSet<Long>();
  Pair<long[],double[]> arraysFromSeries=MetricTimeSeriesUtils.toArray(series,metric,bucketMillis,omitTimestamps,0.0);
  long[] timestamps=arraysFromSeries.getFirst();
  double[] observations=arraysFromSeries.getSecond();
  for (  AnomalyResult ar : anomalyHistory) {
    omitTimestamps.add(ar.getTimeWindow());
  }
  StateSpaceAnomalyDetector stateSpaceDetector=new StateSpaceAnomalyDetector(trainStartInput,trainEndInput,-1,bucketUnit.toMillis(bucketSize),omitTimestamps,seasonal,order,order + seasonal - 1,1,r);
  final String FUNCTION_INVOCATION_STATE_KEY=getKVMapKeyString(functionConfig,dimensionKey);
  Double initialEstimatedStateNoise=NON_DURABLE_STATE_KV_PAIRS.get(FUNCTION_INVOCATION_STATE_KEY);
  if (initialEstimatedStateNoise != null) {
    stateSpaceDetector.setInitialEstimatedStateNoise(initialEstimatedStateNoise);
  }
  Map<Long,StateSpaceDataPoint> resultsByTimeWindow;
  try {
    LOGGER.info("detecting anomalies using kalman filter");
    long offset=TimeUnit.MILLISECONDS.convert(bucketSize,bucketUnit);
    long startTime=System.nanoTime();
    resultsByTimeWindow=stateSpaceDetector.detectAnomalies(observations,timestamps,offset);
    LOGGER.info("algorithm took {} seconds",TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime));
    NON_DURABLE_STATE_KV_PAIRS.put(FUNCTION_INVOCATION_STATE_KEY,stateSpaceDetector.getEstimatedStateNoise());
  }
 catch (  Exception e) {
    throw new FunctionDidNotEvaluateException("something went wrong",e);
  }
  List<AnomalyResult> anomalyResults=new LinkedList<AnomalyResult>();
  for (  long timeWindow : new TreeSet<>(resultsByTimeWindow.keySet())) {
    StateSpaceDataPoint stateSpaceDataPoint=resultsByTimeWindow.get(timeWindow);
    if (stateSpaceDataPoint.pValue < pValueThreshold) {
      ResultProperties resultProperties=new ResultProperties();
      resultProperties.put("actualValue","" + stateSpaceDataPoint.actualValue);
      resultProperties.put("predictedValue","" + stateSpaceDataPoint.predictedValue);
      resultProperties.put("stdError","" + stateSpaceDataPoint.stdError);
      resultProperties.put("pValue","" + stateSpaceDataPoint.pValue);
      resultProperties.put("predictedDate","" + stateSpaceDataPoint.predictedDate);
      resultProperties.setProperty("timestamp",new DateTime(timeWindow).toString());
      anomalyResults.add(new AnomalyResult(true,timeWindow,stateSpaceDataPoint.pValue,stateSpaceDataPoint.actualValue,resultProperties));
    }
  }
  return anomalyResults;
}
