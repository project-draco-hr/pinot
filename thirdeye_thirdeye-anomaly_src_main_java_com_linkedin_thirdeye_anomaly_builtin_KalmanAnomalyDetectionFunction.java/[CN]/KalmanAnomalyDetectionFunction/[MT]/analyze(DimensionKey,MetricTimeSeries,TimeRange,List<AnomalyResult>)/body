{
  long trainStartInput=Collections.min(series.getTimeWindowSet());
  long trainEndInput=Collections.max(series.getTimeWindowSet());
  long bucketMillis=bucketUnit.toMillis(bucketSize);
  int numObservations=(int)(1 + ((trainEndInput - trainStartInput) / bucketMillis));
  double[] observations=new double[numObservations];
  long[] timestamps=new long[numObservations];
  for (int i=0; i < numObservations; i++) {
    long timeWindow=trainStartInput + (i * bucketMillis);
    timestamps[i]=timeWindow;
    if (series.getTimeWindowSet().contains(timeWindow)) {
      observations[i]=series.get(timeWindow,metric).doubleValue();
    }
 else {
      observations[i]=0.0;
    }
  }
  if (numObservations != series.getTimeWindowSet().size()) {
    LOGGER.warn("looks like there are holes in the data: expected {} timestamps, actual {}",numObservations,series.getTimeWindowSet().size());
  }
  Set<Long> omitTimestamps=new HashSet<Long>();
  for (  AnomalyResult ar : anomalyHistory) {
    omitTimestamps.add(ar.getTimeWindow());
  }
  StateSpaceAnomalyDetector stateSpaceDetector=new StateSpaceAnomalyDetector(trainStartInput,trainEndInput,-1,bucketUnit.toMillis(bucketSize),omitTimestamps,seasonal,order,order + seasonal - 1,1,r);
  final String FUNCTION_INVOCATION_STATE_KEY=getKVMapKeyString(functionConfig,dimensionKey);
  Double initialEstimatedStateNoise=NON_DURABLE_STATE_KV_PAIRS.get(FUNCTION_INVOCATION_STATE_KEY);
  if (initialEstimatedStateNoise != null) {
    stateSpaceDetector.setInitialEstimatedStateNoise(initialEstimatedStateNoise);
  }
  Map<Long,FanomalyDataPoint> fAnomalyDataPoints;
  try {
    LOGGER.info("detecting anomalies using fanomaly");
    long offset=TimeUnit.MILLISECONDS.convert(bucketSize,bucketUnit);
    long startTime=System.nanoTime();
    fAnomalyDataPoints=stateSpaceDetector.DetectAnomaly(observations,timestamps,offset);
    LOGGER.info("algorithm took {} seconds",TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime));
    NON_DURABLE_STATE_KV_PAIRS.put(FUNCTION_INVOCATION_STATE_KEY,stateSpaceDetector.getEstimatedStateNoise());
  }
 catch (  Exception e) {
    throw new FunctionDidNotEvaluateException("something went wrong",e);
  }
  List<AnomalyResult> anomalyResults=new LinkedList<AnomalyResult>();
  for (  long timeWindow : new TreeSet<>(fAnomalyDataPoints.keySet())) {
    FanomalyDataPoint fAnomalyDataPoint=fAnomalyDataPoints.get(timeWindow);
    if (fAnomalyDataPoint.pValue < pValueThreshold) {
      ResultProperties resultProperties=new ResultProperties();
      resultProperties.put("actualValue","" + fAnomalyDataPoint.actualValue);
      resultProperties.put("predictedValue","" + fAnomalyDataPoint.predictedValue);
      resultProperties.put("stdError","" + fAnomalyDataPoint.stdError);
      resultProperties.put("pValue","" + fAnomalyDataPoint.pValue);
      resultProperties.put("predictedDate","" + fAnomalyDataPoint.predictedDate);
      anomalyResults.add(new AnomalyResult(true,timeWindow,fAnomalyDataPoint.pValue,fAnomalyDataPoint.actualValue,resultProperties));
    }
  }
  return anomalyResults;
}
