{
  LOGGER.info("Input config:{}",inputConfig);
  PhaseSpec phaseSpec;
  try {
    phaseSpec=PhaseSpec.valueOf(phaseName.toUpperCase());
  }
 catch (  Exception e) {
    usage();
    throw e;
  }
  if (PhaseSpec.JOIN.equals(phaseSpec)) {
    JoinPhaseJob job=new JoinPhaseJob("Join Job",inputConfig);
    job.run();
    return;
  }
  if (PhaseSpec.TRANSFORM.equals(phaseSpec)) {
    TransformPhaseJob job=new TransformPhaseJob("Transform Job",inputConfig);
    job.run();
    return;
  }
  String root=getAndCheck(ThirdEyeJobConstants.THIRDEYE_ROOT.getName(),inputConfig);
  String collection=getAndCheck(ThirdEyeJobConstants.THIRDEYE_COLLECTION.getName(),inputConfig);
  String inputPaths=getAndCheck(ThirdEyeJobConstants.INPUT_PATHS.getName(),inputConfig);
  FlowSpec flowSpec=null;
switch (phaseSpec) {
case WAIT:
case ANALYSIS:
case AGGREGATION:
case TOPK_ROLLUP_PHASE1:
case TOPK_ROLLUP_PHASE2:
case TOPK_ROLLUP_PHASE3:
case ROLLUP_PHASE1:
case ROLLUP_PHASE2:
case ROLLUP_PHASE3:
case ROLLUP_PHASE4:
case PARTITION:
case STARTREE_GENERATION:
    flowSpec=FlowSpec.DIMENSION_INDEX;
  break;
case STARTREE_BOOTSTRAP_PHASE1:
case STARTREE_BOOTSTRAP_PHASE2:
case SERVER_PACKAGE:
case SERVER_UPLOAD:
case CLEANUP:
flowSpec=FlowSpec.METRIC_INDEX;
break;
default :
break;
}
DateTime minTime;
DateTime maxTime;
String minTimeProp=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_MIN.getName());
String maxTimeProp=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_MAX.getName());
String timePathProp=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_PATH.getName());
FileSystem fileSystem=FileSystem.get(new Configuration());
if (minTimeProp != null && maxTimeProp != null) {
minTime=ISODateTimeFormat.dateTimeParser().parseDateTime(minTimeProp);
maxTime=ISODateTimeFormat.dateTimeParser().parseDateTime(maxTimeProp);
}
 else if (timePathProp != null) {
InputStream inputStream=fileSystem.open(new Path(timePathProp));
Properties timePathProps=new Properties();
timePathProps.load(inputStream);
inputStream.close();
minTimeProp=timePathProps.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_MIN.getName());
maxTimeProp=timePathProps.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_MAX.getName());
minTime=ISODateTimeFormat.dateTimeParser().parseDateTime(minTimeProp);
maxTime=ISODateTimeFormat.dateTimeParser().parseDateTime(maxTimeProp);
}
 else {
throw new IllegalStateException("Must specify either " + ThirdEyeJobConstants.THIRDEYE_TIME_PATH.getName() + " or "+ ThirdEyeJobConstants.THIRDEYE_TIME_MIN.getName()+ " and "+ ThirdEyeJobConstants.THIRDEYE_TIME_MAX.getName());
}
if (PhaseSpec.SERVER_PACKAGE.equals(phaseSpec)) {
serverPackage(fileSystem,root,collection,flowSpec,minTime,maxTime);
}
 else if (PhaseSpec.SERVER_UPLOAD.equals(phaseSpec)) {
serverUpload(fileSystem,root,collection,flowSpec,minTime,maxTime);
}
 else if (PhaseSpec.WAIT.equals(phaseSpec)) {
boolean pollEnable=Boolean.parseBoolean(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_POLL_ENABLE.getName(),DEFAULT_POLL_ENABLE));
if (pollEnable) {
long elapsedTime=0;
long pollStart=(new DateTime()).getMillis();
long pollFrequency=Long.parseLong(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_POLL_FREQUENCY.getName(),DEFAULT_POLL_FREQUENCY));
long pollTimeout=Long.parseLong(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_POLL_TIMEOUT.getName(),DEFAULT_POLL_TIMEOUT));
String[] inputs=inputConfig.getProperty(ThirdEyeJobConstants.INPUT_PATHS.getName()).split(INPUT_PATHS_JOINER);
List<String> missingInputs;
while (elapsedTime < pollTimeout) {
missingInputs=new ArrayList<String>();
for (String input : inputs) {
LOGGER.info("Checking path {}",input);
if (!fileSystem.exists(new Path(input))) {
  missingInputs.add(input);
  LOGGER.info("Missing input {}",input);
}
 else {
  try {
    fileSystem.getFileStatus(new Path(input));
    if (fileSystem.exists(new Path(input,TEMPORARY_FOLDER))) {
      missingInputs.add(input);
      LOGGER.info("Data generation in progress");
    }
 else {
      LOGGER.info("Path available {}",input);
    }
  }
 catch (  AccessControlException e) {
    missingInputs.add(input);
    LOGGER.warn("No access to path {}",input,e);
  }
}
}
if (missingInputs.size() == 0) {
LOGGER.info("All paths available");
break;
}
LOGGER.info("Poll after {} milliseconds",pollFrequency);
TimeUnit.MILLISECONDS.sleep(pollFrequency);
elapsedTime=new DateTime().getMillis() - pollStart;
LOGGER.info("Time elapsed {} milliseconds",elapsedTime);
inputs=missingInputs.toArray(new String[missingInputs.size()]);
}
if (elapsedTime > pollTimeout) {
LOGGER.info("Timed out waiting for input");
}
}
}
 else if (PhaseSpec.CLEANUP.equals(phaseSpec)) {
boolean cleanupSkip=Boolean.parseBoolean(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_CLEANUP_SKIP.getName(),DEFAULT_CLEANUP_SKIP));
LOGGER.info("cleanup skip {}",cleanupSkip);
if (cleanupSkip) {
LOGGER.info("Skipping cleanup");
}
 else {
int cleanupDaysAgo=Integer.valueOf(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_CLEANUP_DAYSAGO.getName(),DEFAULT_CLEANUP_DAYS_AGO));
DateTime cleanupDaysAgoDate=(new DateTime()).minusDays(cleanupDaysAgo);
Path dimensionIndexDir=new Path(getCollectionDir(root,collection) + File.separator + FlowSpec.DIMENSION_INDEX);
Path metricIndexDir=new Path(getCollectionDir(root,collection) + File.separator + FlowSpec.METRIC_INDEX);
LOGGER.info("Cleaning up {} {} days ago from paths {} and {}",cleanupDaysAgo,cleanupDaysAgoDate.getMillis(),dimensionIndexDir,metricIndexDir);
boolean preserveAggregation=Boolean.parseBoolean(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_PRESERVE_TIME_COMPACTION.getName(),DEFAULT_THIRDEYE_PRESERVE_TIME_COMPACTION));
FileStatus[] fileStatus=fileSystem.listStatus(dimensionIndexDir,new PathFilter(){
@Override public boolean accept(Path path){
return path.getName().startsWith(StarTreeConstants.DATA_DIR_PREFIX);
}
}
);
for (FileStatus file : fileStatus) {
if (preserveAggregation) {
FileStatus[] phases=fileSystem.listStatus(file.getPath(),new PathFilter(){
  @Override public boolean accept(  Path path){
    return !path.getName().equals(PhaseSpec.AGGREGATION.getName());
  }
}
);
for (FileStatus phase : phases) {
  cleanupFolder(phase,cleanupDaysAgoDate,fileSystem);
}
}
 else {
cleanupFolder(file,cleanupDaysAgoDate,fileSystem);
}
}
fileStatus=fileSystem.listStatus(metricIndexDir,new PathFilter(){
@Override public boolean accept(Path path){
return path.getName().startsWith(StarTreeConstants.DATA_DIR_PREFIX);
}
}
);
for (FileStatus file : fileStatus) {
DateTime lastModifiedDate=new DateTime(file.getModificationTime());
if (lastModifiedDate.isBefore(cleanupDaysAgoDate.getMillis())) {
Path startreeBootstrapPath1=new Path(file.getPath(),PhaseSpec.STARTREE_BOOTSTRAP_PHASE1.getName().toLowerCase());
if (fileSystem.exists(startreeBootstrapPath1)) {
  LOGGER.info("Deleting {}",startreeBootstrapPath1);
  fileSystem.delete(startreeBootstrapPath1,true);
}
Path startreeBootstrapPath2=new Path(file.getPath(),PhaseSpec.STARTREE_BOOTSTRAP_PHASE2.getName().toLowerCase());
if (fileSystem.exists(startreeBootstrapPath2)) {
  LOGGER.info("Deleting {}",startreeBootstrapPath2);
  fileSystem.delete(startreeBootstrapPath2,true);
}
}
}
String schedule=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_FLOW_SCHEDULE.getName());
LOGGER.info("schedule : {} ",schedule);
purgeLowerGranularity(minTime,maxTime,schedule,dimensionIndexDir,metricIndexDir);
}
}
 else {
if (FlowSpec.METRIC_INDEX.equals(flowSpec)) {
String dimensionIndexRef=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_DIMENSION_INDEX_REF.getName());
if (dimensionIndexRef == null) {
String msg="dimensionIndexRef:" + dimensionIndexRef + ".Must provide "+ ThirdEyeJobConstants.THIRDEYE_DIMENSION_INDEX_REF.getName()+ " in properties";
LOGGER.error(msg);
throw new IllegalArgumentException(msg);
}
}
Properties jobProperties=phaseSpec.getJobProperties(inputConfig,root,collection,flowSpec,minTime,maxTime,inputPaths);
String numReducers=inputConfig.getProperty(phaseSpec.getName() + ".num.reducers");
if (numReducers != null) {
jobProperties.put("num.reducers",numReducers);
}
Constructor<Configured> constructor=(Constructor<Configured>)phaseSpec.getKlazz().getConstructor(String.class,Properties.class);
Configured instance=constructor.newInstance(phaseSpec.getName(),jobProperties);
setMapreduceConfig(instance.getConf());
Method runMethod=instance.getClass().getMethod("run");
Job job=(Job)runMethod.invoke(instance);
JobStatus status=job.getStatus();
if (status.getState() != JobStatus.State.SUCCEEDED) {
throw new RuntimeException("Job " + job.getJobName() + " failed to execute: Ran with config:"+ jobProperties);
}
}
}
