{
  LOGGER.info("Input config:{}",inputConfig);
  PhaseSpec phaseSpec;
  try {
    phaseSpec=PhaseSpec.valueOf(phaseName.toUpperCase());
  }
 catch (  Exception e) {
    usage();
    throw e;
  }
  if (PhaseSpec.JOIN.equals(phaseSpec)) {
    JoinPhaseJob job=new JoinPhaseJob("Join Job",inputConfig);
    job.run();
    return;
  }
  String root=getAndCheck(ThirdEyeJobConstants.THIRDEYE_ROOT.getName(),inputConfig);
  String collection=getAndCheck(ThirdEyeJobConstants.THIRDEYE_COLLECTION.getName(),inputConfig);
  String inputPaths=getAndCheck(ThirdEyeJobConstants.INPUT_PATHS.getName(),inputConfig);
  FlowSpec flowSpec=null;
switch (phaseSpec) {
case WAIT:
case ANALYSIS:
case AGGREGATION:
case ROLLUP_PHASE1:
case ROLLUP_PHASE2:
case ROLLUP_PHASE3:
case ROLLUP_PHASE4:
case STARTREE_GENERATION:
    flowSpec=FlowSpec.DIMENSION_INDEX;
  break;
case STARTREE_BOOTSTRAP_PHASE1:
case STARTREE_BOOTSTRAP_PHASE2:
case SERVER_PUSH:
case CLEANUP:
flowSpec=FlowSpec.METRIC_INDEX;
break;
default :
break;
}
DateTime minTime;
DateTime maxTime;
String minTimeProp=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_MIN.getName());
String maxTimeProp=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_MAX.getName());
String timePathProp=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_PATH.getName());
if (minTimeProp != null && maxTimeProp != null) {
minTime=ISODateTimeFormat.dateTimeParser().parseDateTime(minTimeProp);
maxTime=ISODateTimeFormat.dateTimeParser().parseDateTime(maxTimeProp);
}
 else if (timePathProp != null) {
FileSystem fileSystem=FileSystem.get(new Configuration());
InputStream inputStream=fileSystem.open(new Path(timePathProp));
Properties timePathProps=new Properties();
timePathProps.load(inputStream);
inputStream.close();
minTimeProp=timePathProps.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_MIN.getName());
maxTimeProp=timePathProps.getProperty(ThirdEyeJobConstants.THIRDEYE_TIME_MAX.getName());
minTime=ISODateTimeFormat.dateTimeParser().parseDateTime(minTimeProp);
maxTime=ISODateTimeFormat.dateTimeParser().parseDateTime(maxTimeProp);
}
 else {
throw new IllegalStateException("Must specify either " + ThirdEyeJobConstants.THIRDEYE_TIME_PATH.getName() + " or "+ ThirdEyeJobConstants.THIRDEYE_TIME_MIN.getName()+ " and "+ ThirdEyeJobConstants.THIRDEYE_TIME_MAX.getName());
}
if (PhaseSpec.SERVER_PUSH.equals(phaseSpec)) {
String thirdEyeServerUri=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_SERVER_URI.getName());
if (thirdEyeServerUri == null) {
throw new IllegalArgumentException("Must provide " + ThirdEyeJobConstants.THIRDEYE_SERVER_URI.getName() + " in properties");
}
FileSystem fileSystem=FileSystem.get(new Configuration());
Path configPath=new Path(root + File.separator + collection+ File.separator+ StarTreeConstants.CONFIG_FILE_NAME);
InputStream configData=fileSystem.open(configPath);
int responseCode=StarTreeJobUtils.pushConfig(configData,thirdEyeServerUri,collection);
configData.close();
LOGGER.info("Load {} #=> {}",configPath,responseCode);
String schedule=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_FLOW_SCHEDULE.getName());
String metricIndexDir=PhaseSpec.STARTREE_BOOTSTRAP_PHASE2.getMetricIndexDir(root,collection,flowSpec,minTime,maxTime);
String bootstrapPhase2Output=metricIndexDir + File.separator + PhaseSpec.STARTREE_BOOTSTRAP_PHASE2.getName();
Path dataPath=new Path(bootstrapPhase2Output);
String outputTarGzFile=metricIndexDir + "/data.tar.gz";
Path outputTarGzFilePath=new Path(outputTarGzFile);
if (!fileSystem.exists(outputTarGzFilePath)) {
LOGGER.info("START: Creating output {} to upload to server ",outputTarGzFilePath.getName());
TarGzBuilder builder=new TarGzBuilder(outputTarGzFile,fileSystem,fileSystem);
RemoteIterator<LocatedFileStatus> listFiles=fileSystem.listFiles(dataPath,false);
List<IndexMetadata> indexMetadataList=new ArrayList<IndexMetadata>();
while (listFiles.hasNext()) {
Path path=listFiles.next().getPath();
IndexMetadata localIndexMetadata=builder.getMetadataObjectBootstrap(path);
if (localIndexMetadata != null) {
indexMetadataList.add(localIndexMetadata);
}
}
if (indexMetadataList.size() == 0) {
throw new IllegalStateException("No metadata files found");
}
Path metadataPath=new Path(bootstrapPhase2Output,StarTreeConstants.METADATA_FILE_NAME);
IndexMetadata mergedIndexMetadata=mergeIndexMetadata(indexMetadataList,minTime.getMillis(),maxTime.getMillis(),schedule);
writeMergedIndexMetadataServerPush(fileSystem,metadataPath,mergedIndexMetadata);
listFiles=fileSystem.listFiles(dataPath,false);
while (listFiles.hasNext()) {
Path path=listFiles.next().getPath();
LOGGER.info("Adding {}, to {}",path,outputTarGzFile);
if (path.getName().equals(StarTreeConstants.TREE_FILE_NAME) || path.getName().equals(StarTreeConstants.METADATA_FILE_NAME)) {
builder.addFileEntry(path);
}
 else {
builder.addTarGzFile(path);
}
}
builder.addFileEntry(configPath);
builder.finish();
if (fileSystem.exists(outputTarGzFilePath)) {
LOGGER.info("Successfully created {}.",outputTarGzFilePath);
}
 else {
throw new RuntimeException("Creation of" + outputTarGzFile + " failed");
}
}
 else {
LOGGER.info(outputTarGzFile + " already exists. Skipping the tar.gz creation step");
}
if (fileSystem.exists(outputTarGzFilePath)) {
LOGGER.info("Uploading {} of size:{} to ThirdEye Server: {}",outputTarGzFile,fileSystem.getFileStatus(outputTarGzFilePath).getLen(),thirdEyeServerUri);
FSDataInputStream outputDataStream=fileSystem.open(outputTarGzFilePath);
responseCode=StarTreeJobUtils.pushData(outputDataStream,thirdEyeServerUri,collection,minTime,maxTime,schedule);
LOGGER.info("Load {} #=> response code: {}",outputTarGzFile,responseCode);
}
 else {
throw new RuntimeException("Creation of" + outputTarGzFile + " failed");
}
String thirdeyeFolderPermission=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_FOLDER_PERMISSION.getName(),DEFAULT_FOLDER_PERMISSION);
if (!thirdeyeFolderPermission.matches(FOLDER_PERMISSION_REGEX)) {
throw new IllegalArgumentException("Invalid folder permission mode. Must provide octal " + FOLDER_PERMISSION_REGEX);
}
String dimensionIndexDir=PhaseSpec.STARTREE_BOOTSTRAP_PHASE2.getDimensionIndexDir(root,collection,Joiner.on(DATA_FOLDER_JOINER).join(StarTreeConstants.DATA_DIR_PREFIX,StarTreeConstants.DATE_TIME_FORMATTER.print(minTime),StarTreeConstants.DATE_TIME_FORMATTER.print(maxTime)));
FsShell shell=new FsShell(new Configuration());
LOGGER.info("Changing permission of {} to {}",dimensionIndexDir,thirdeyeFolderPermission);
shell.run(new String[]{"-chmod","-R",thirdeyeFolderPermission,dimensionIndexDir});
LOGGER.info("Changing permission of {} to {}",metricIndexDir,thirdeyeFolderPermission);
shell.run(new String[]{"-chmod","-R",thirdeyeFolderPermission,metricIndexDir});
}
 else if (PhaseSpec.WAIT.equals(phaseSpec)) {
boolean pollEnable=Boolean.parseBoolean(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_POLL_ENABLE.getName(),DEFAULT_POLL_ENABLE));
if (pollEnable) {
FileSystem fileSystem=FileSystem.get(new Configuration());
long elapsedTime=0;
long pollStart=(new DateTime()).getMillis();
long pollFrequency=Long.parseLong(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_POLL_FREQUENCY.getName(),DEFAULT_POLL_FREQUENCY));
long pollTimeout=Long.parseLong(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_POLL_TIMEOUT.getName(),DEFAULT_POLL_TIMEOUT));
String[] inputs=inputConfig.getProperty(ThirdEyeJobConstants.INPUT_PATHS.getName()).split(INPUT_PATHS_JOINER);
List<String> missingInputs;
while (elapsedTime < pollTimeout) {
missingInputs=new ArrayList<String>();
for (String input : inputs) {
if (!fileSystem.exists(new Path(input))) {
  missingInputs.add(input);
  LOGGER.info("Missing input {}",input);
}
}
if (missingInputs.size() == 0) {
LOGGER.info("All paths available");
break;
}
LOGGER.info("Poll after {} milliseconds",pollFrequency);
TimeUnit.MILLISECONDS.sleep(pollFrequency);
elapsedTime=new DateTime().getMillis() - pollStart;
LOGGER.info("Time elapsed {} milliseconds",elapsedTime);
inputs=missingInputs.toArray(new String[missingInputs.size()]);
}
if (elapsedTime > pollTimeout) {
LOGGER.info("Timed out waiting for input");
}
}
}
 else if (PhaseSpec.CLEANUP.equals(phaseSpec)) {
boolean cleanupSkip=Boolean.parseBoolean(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_CLEANUP_SKIP.getName(),DEFAULT_CLEANUP_SKIP));
LOGGER.info("cleanup skip {}",cleanupSkip);
if (cleanupSkip) {
LOGGER.info("Skipping cleanup");
}
 else {
int cleanupDaysAgo=Integer.valueOf(inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_CLEANUP_DAYSAGO.getName(),DEFAULT_CLEANUP_DAYS_AGO));
DateTime cleanupDaysAgoDate=(new DateTime()).minusDays(cleanupDaysAgo);
Path dimensionIndexDir=new Path(getCollectionDir(root,collection) + File.separator + FlowSpec.DIMENSION_INDEX);
Path metricIndexDir=new Path(getCollectionDir(root,collection) + File.separator + FlowSpec.METRIC_INDEX);
LOGGER.info("Cleaning up {} {} days ago from paths {} and {}",cleanupDaysAgo,cleanupDaysAgoDate.getMillis(),dimensionIndexDir,metricIndexDir);
FileSystem fileSystem=FileSystem.get(new Configuration());
FileStatus[] fileStatus=fileSystem.listStatus(dimensionIndexDir,new PathFilter(){
@Override public boolean accept(Path path){
return path.getName().startsWith(StarTreeConstants.DATA_DIR_PREFIX);
}
}
);
for (FileStatus file : fileStatus) {
DateTime lastModifiedDate=new DateTime(file.getModificationTime());
if (lastModifiedDate.isBefore(cleanupDaysAgoDate.getMillis())) {
LOGGER.info("Deleting {}",file.getPath());
fileSystem.delete(file.getPath(),true);
}
}
fileStatus=fileSystem.listStatus(metricIndexDir,new PathFilter(){
@Override public boolean accept(Path path){
return path.getName().startsWith(StarTreeConstants.DATA_DIR_PREFIX);
}
}
);
for (FileStatus file : fileStatus) {
DateTime lastModifiedDate=new DateTime(file.getModificationTime());
if (lastModifiedDate.isBefore(cleanupDaysAgoDate.getMillis())) {
Path startreeBootstrapPath1=new Path(file.getPath(),PhaseSpec.STARTREE_BOOTSTRAP_PHASE1.getName().toLowerCase());
if (fileSystem.exists(startreeBootstrapPath1)) {
  LOGGER.info("Deleting {}",startreeBootstrapPath1);
  fileSystem.delete(startreeBootstrapPath1,true);
}
Path startreeBootstrapPath2=new Path(file.getPath(),PhaseSpec.STARTREE_BOOTSTRAP_PHASE2.getName().toLowerCase());
if (fileSystem.exists(startreeBootstrapPath2)) {
  LOGGER.info("Deleting {}",startreeBootstrapPath2);
  fileSystem.delete(startreeBootstrapPath2,true);
}
}
}
String schedule=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_FLOW_SCHEDULE.getName());
LOGGER.info("schedule : {} ",schedule);
purgeLowerGranularity(minTime,maxTime,schedule,dimensionIndexDir,metricIndexDir);
}
}
 else {
if (FlowSpec.METRIC_INDEX.equals(flowSpec)) {
String dimensionIndexRef=inputConfig.getProperty(ThirdEyeJobConstants.THIRDEYE_DIMENSION_INDEX_REF.getName());
if (dimensionIndexRef == null) {
String msg="dimensionIndexRef:" + dimensionIndexRef + ".Must provide "+ ThirdEyeJobConstants.THIRDEYE_DIMENSION_INDEX_REF.getName()+ " in properties";
LOGGER.error(msg);
throw new IllegalArgumentException(msg);
}
}
Properties jobProperties=phaseSpec.getJobProperties(inputConfig,root,collection,flowSpec,minTime,maxTime,inputPaths);
String numReducers=inputConfig.getProperty(phaseSpec.getName() + ".num.reducers");
if (numReducers != null) {
jobProperties.put("num.reducers",numReducers);
}
Constructor<Configured> constructor=(Constructor<Configured>)phaseSpec.getKlazz().getConstructor(String.class,Properties.class);
Configured instance=constructor.newInstance(phaseSpec.getName(),jobProperties);
Method runMethod=instance.getClass().getMethod("run");
Job job=(Job)runMethod.invoke(instance);
JobStatus status=job.getStatus();
if (status.getState() != JobStatus.State.SUCCEEDED) {
throw new RuntimeException("Job " + job.getJobName() + " failed to execute: Ran with config:"+ jobProperties);
}
}
}
