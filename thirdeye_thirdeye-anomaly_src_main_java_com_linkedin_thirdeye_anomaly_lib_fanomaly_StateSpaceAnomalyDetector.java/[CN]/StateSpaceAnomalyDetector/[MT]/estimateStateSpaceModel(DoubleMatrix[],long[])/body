{
  DoubleMatrix[] trainingTimeSeries=DataUtils.getTrainingData(inputTimeSeries,inputTimeStamps,trainStart,trainEnd);
  DoubleMatrix[] processTrainingTimeSeries=DataUtils.removeTimeStamps(trainingTimeSeries,inputTimeStamps,omitTimestamps);
  if (processTrainingTimeSeries.length <= seasonal) {
    throw new FunctionDidNotEvaluateException("timestamp not long enough for one season.");
  }
  DoubleMatrix GG=new DoubleMatrix(numStates,numStates);
  DoubleMatrix FF=new DoubleMatrix(outputStates,numStates);
  for (int ii=0; ii < order; ii++) {
    GG.put(0,ii,1);
  }
  if (order == 2) {
    GG.put(1,1,1);
  }
  if (seasonal > 0) {
    for (int ii=order; ii < numStates; ii++) {
      GG.put(order,ii,-1);
    }
    for (int ii=order + 1; ii < numStates; ii++) {
      GG.put(ii,(ii - 1),1);
    }
  }
  FF.put(0,0,1);
  if (seasonal > 0) {
    FF.put(0,1,1);
  }
  double estimate2ndRawMoment=DataUtils.estimateTrainingRawMoment(processTrainingTimeSeries,seasonal,2);
  double estimateMean=DataUtils.estimateTrainingMean(processTrainingTimeSeries,seasonal);
  LOGGER.warn("estimated input data variance");
  LOGGER.warn(String.format("%f",estimate2ndRawMoment));
  if (estimate2ndRawMoment == 0) {
    throw new FunctionDidNotEvaluateException("no output");
  }
  DoubleMatrix m0=new DoubleMatrix(numStates,1);
  m0.put(0,0,estimateMean);
  DoubleMatrix c0=DoubleMatrix.eye(numStates).muli(estimate2ndRawMoment);
  BrentOptimizer optimizer=new BrentOptimizer(1e-6,1e-12);
  System.out.println("initial estimate : " + initialEstimatedStateNoise);
  if (initialEstimatedStateNoise != null) {
    UnivariatePointValuePair solution=optimizer.optimize(new UnivariateObjectiveFunction(new StateSpaceUnivariateObj(GG,FF,r,m0,c0,processTrainingTimeSeries)),new MaxEval(100),GoalType.MAXIMIZE,new SearchInterval((1 - ESTIMATE_NOISE_PROP_RANGE_DELTA) * initialEstimatedStateNoise,(1 + ESTIMATE_NOISE_PROP_RANGE_DELTA) * initialEstimatedStateNoise));
    double lowerAcceptabilityThreshold=(1 - ESTIMATE_NOISE_PROP_RANGE_DELTA + ESTIMATE_NOISE_PROP_THESHOLD_DELTA) * initialEstimatedStateNoise;
    double upperAcceptabilityThreshold=(1 + ESTIMATE_NOISE_PROP_RANGE_DELTA - ESTIMATE_NOISE_PROP_THESHOLD_DELTA) * initialEstimatedStateNoise;
    if (solution.getPoint() > lowerAcceptabilityThreshold && solution.getPoint() < upperAcceptabilityThreshold) {
      estimatedStateNoise=solution.getPoint();
    }
 else {
      LOGGER.warn("the solution from fine-tuning is unsatisfactory");
    }
  }
  if (estimatedStateNoise == null) {
    LOGGER.info("optimizing from scratch");
    UnivariatePointValuePair solution=optimizer.optimize(new UnivariateObjectiveFunction(new StateSpaceUnivariateObj(GG,FF,r,m0,c0,processTrainingTimeSeries)),new MaxEval(100),GoalType.MAXIMIZE,new SearchInterval(0.0001,estimate2ndRawMoment));
    estimatedStateNoise=solution.getPoint();
  }
  LOGGER.info("estimatedStateNoise : {}",estimatedStateNoise);
  DoubleMatrix StateNoiseMatrix=DoubleMatrix.eye(numStates).muli(estimatedStateNoise);
  DoubleMatrix ObservationNoiseMatrix=DoubleMatrix.eye(outputStates).muli(estimatedStateNoise * r);
  StateSpaceModel Subject=new StateSpaceModel(GG,FF,StateNoiseMatrix,ObservationNoiseMatrix,m0,c0,processTrainingTimeSeries);
  return Subject;
}
