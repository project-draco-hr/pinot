{
  long start=System.currentTimeMillis();
  Map<String,String> dimensionValuesMap=new HashMap<String,String>();
  for (int i=0; i < dimensionNames.size(); i++) {
    String dimensionName=dimensionNames.get(i);
    String dimensionValue="";
    Object val=record.datum().get(dimensionName);
    if (val != null) {
      dimensionValue=val.toString();
    }
    dimensionValues[i]=dimensionValue;
    dimensionValuesMap.put(dimensionName,dimensionValue);
  }
  DimensionKey key=new DimensionKey(dimensionValues);
  String sourceTimeWindow=record.datum().get(config.getTimeColumnName()).toString();
  long timeWindow=aggregationTimeUnit.convert(Long.parseLong(sourceTimeWindow),sourceTimeUnit);
  MetricTimeSeries series=new MetricTimeSeries(metricSchema);
  for (int i=0; i < metricNames.size(); i++) {
    String metricName=metricNames.get(i);
    Object object=record.datum().get(metricName);
    String metricValueStr="0";
    if (object != null) {
      metricValueStr=object.toString();
    }
    try {
      Number metricValue=metricTypes.get(i).toNumber(metricValueStr);
      series.increment(timeWindow,metricName,metricValue);
    }
 catch (    NumberFormatException e) {
      throw new NumberFormatException("Exception trying to convert " + metricValueStr + " to "+ metricTypes.get(i)+ " for metricName:"+ metricName);
    }
  }
  Map<UUID,StarTreeRecord> collector=new HashMap<UUID,StarTreeRecord>();
  Map<String,Number> metricValues=Collections.emptyMap();
  Map<String,MetricType> metricTypes=Collections.emptyMap();
  Long time=0L;
  StarTreeRecord starTreeRecord=new StarTreeRecordImpl(dimensionValuesMap,metricValues,metricTypes,time);
  StarTreeJobUtils.collectRecords(starTreeRootNode,starTreeRecord,collector);
  if (debug) {
    LOG.info("processing {}",key);
    LOG.info("times series {}",series);
  }
  for (  UUID uuid : collector.keySet()) {
    if (!leafNodesMap.containsKey(uuid)) {
      String msg="Got a mapping to non existant leaf node:" + uuid + " - "+ collector.get(uuid)+ " input :"+ starTreeRecord;
      LOG.error(msg);
      throw new RuntimeException(msg);
    }
    List<int[]> leafRecords=nodeIdToleafRecordsMap.get(uuid);
    Map<String,Map<String,Integer>> forwardIndex=forwardIndexMap.get(uuid);
    Map<String,Map<Integer,String>> reverseForwardIndex=StarTreeUtils.toReverseIndex(forwardIndex);
    int[] bestMatch=StarTreeJobUtils.findBestMatch(key,dimensionNames,leafRecords,forwardIndex);
    String[] dimValues=StarTreeUtils.convertToStringValue(reverseForwardIndex,bestMatch,dimensionNames);
    DimensionKey matchedDimensionKey=new DimensionKey(dimValues);
    if (debug) {
      LOG.info("Match: {} under {}",matchedDimensionKey,leafNodesMap.get(uuid).getPath());
    }
    BootstrapPhaseMapOutputKey outputKey=new BootstrapPhaseMapOutputKey(uuid,matchedDimensionKey.toMD5());
    BootstrapPhaseMapOutputValue outputValue=new BootstrapPhaseMapOutputValue(matchedDimensionKey,series);
    BytesWritable keyWritable=new BytesWritable(outputKey.toBytes());
    BytesWritable valWritable=new BytesWritable(outputValue.toBytes());
    context.write(keyWritable,valWritable);
  }
  long end=System.currentTimeMillis();
  inputCount=inputCount + 1;
  outputCount=outputCount + collector.size();
  totalTime=totalTime + (end - start);
  if (inputCount % 5000 == 0) {
    LOG.info("Processed {} in {}. avg time {} avg Fan out:{}",inputCount,totalTime,totalTime / inputCount,(outputCount / inputCount));
  }
}
