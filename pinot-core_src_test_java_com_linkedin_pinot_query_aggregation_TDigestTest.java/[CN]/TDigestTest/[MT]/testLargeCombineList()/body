{
  for (  Byte quantile : functionMap.keySet()) {
    LOGGER.info("[Test Quantile " + quantile + "]");
    AggregationFunction aggregationFunction=functionMap.get(quantile);
    AggregationFunction aggregationAccurateFunction=accurateFunctionMap.get(quantile);
    aggregationFunction.init(_paramsInfo);
    aggregationAccurateFunction.init(_paramsInfo);
    StringBuilder sb1=new StringBuilder();
    StringBuilder sb2=new StringBuilder();
    StringBuilder sb3=new StringBuilder();
    int maxSize=100000;
    for (int i=1; i <= maxSize; i+=maxSize / 17) {
      if (i == 1)       continue;
      RandomNumberArray arr=new RandomNumberArray(i * 10,1);
      long t1=System.nanoTime();
      List<Serializable> aggregationResults=getTDigestResultValues(arr,10,i);
      long t2=System.nanoTime();
      List<Serializable> combinedResult=aggregationFunction.combine(aggregationResults,CombineLevel.SEGMENT);
      long t3=System.nanoTime();
      double estimate=((TDigest)(combinedResult.get(0))).getQuantile(quantile);
      List<Serializable> aggregationResults2=getDoubleArrayListResultValues(arr,10,i);
      List<Serializable> combinedResult2=aggregationAccurateFunction.combine(aggregationResults2,CombineLevel.SEGMENT);
      double actual=(Double)QuantileUtil.getValueOnQuantile((DoubleArrayList)combinedResult2.get(0),quantile);
      TestUtils.assertApproximation(estimate,actual,threshold);
      println(i + ", " + ""+ (t2 - t1)+ ""+ ", "+ (t3 - t2)+ ", "+ getErrorString(actual,estimate));
    }
  }
}
