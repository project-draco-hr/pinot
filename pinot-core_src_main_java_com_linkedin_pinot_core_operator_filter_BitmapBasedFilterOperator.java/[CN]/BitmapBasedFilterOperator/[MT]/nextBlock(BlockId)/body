{
  Predicate predicate=getPredicate();
  InvertedIndexReader invertedIndex=dataSource.getInvertedIndex();
  Block dataSourceBlock=dataSource.nextBlock();
  Dictionary dictionary=dataSource.getDictionary();
  List<ImmutableRoaringBitmap> bitmapList=new ArrayList<ImmutableRoaringBitmap>();
switch (predicate.getType()) {
case EQ:
    final int valueToLookUP=dictionary.indexOf(((EqPredicate)predicate).getEqualsValue());
  if (valueToLookUP < 0) {
    bitmapList.add(new MutableRoaringBitmap());
  }
 else {
    bitmapList.add(invertedIndex.getImmutable(valueToLookUP));
  }
break;
case NEQ:
final int neq=dictionary.indexOf(((NEqPredicate)predicate).getNotEqualsValue());
for (int i=0; i < dictionary.length(); i++) {
if (i != neq) {
bitmapList.add(invertedIndex.getImmutable(i));
}
}
break;
case IN:
final String[] inValues=((InPredicate)predicate).getInRange();
for (final String value : inValues) {
final int index=dictionary.indexOf(value);
if (index >= 0) {
bitmapList.add(invertedIndex.getImmutable(index));
}
}
break;
case NOT_IN:
final String[] notInValues=((NotInPredicate)predicate).getNotInRange();
final List<Integer> notInIds=new ArrayList<Integer>();
for (final String notInValue : notInValues) {
notInIds.add(new Integer(dictionary.indexOf(notInValue)));
}
for (int i=0; i < dictionary.length(); i++) {
if (!notInIds.contains(new Integer(i))) {
bitmapList.add(invertedIndex.getImmutable(i));
}
}
break;
case RANGE:
if (dictionary instanceof ImmutableDictionaryReader) {
int[] rangeStartEndIndex=RangePredicateEvaluator.get().evalStartEndIndex(dictionary,(RangePredicate)predicate);
int rangeStartIndex=rangeStartEndIndex[0];
int rangeEndIndex=rangeStartEndIndex[1];
LOGGER.info("rangeStartIndex:{}, rangeEndIndex:{}",rangeStartIndex,rangeEndIndex);
for (int i=rangeStartIndex; i <= rangeEndIndex; i++) {
ImmutableRoaringBitmap immutable=invertedIndex.getImmutable(i);
bitmapList.add(immutable);
}
}
 else {
List<Integer> dicIds=RangePredicateEvaluator.get().evalRangeDicIdsFromMutableDictionary((MutableDictionaryReader)dictionary,(RangePredicate)predicate);
for (Integer id : dicIds) {
bitmapList.add(invertedIndex.getImmutable(id));
}
}
break;
case REGEX:
throw new UnsupportedOperationException("Regex not supported");
}
ImmutableRoaringBitmap[] bitmaps=new ImmutableRoaringBitmap[bitmapList.size()];
bitmapList.toArray(bitmaps);
bitmapBlock=new BitmapBlock(dataSourceBlock.getMetadata(),bitmaps);
return bitmapBlock;
}
