{
  List<String> dimensions=getDimensions(collection);
  DateTime baseline=new DateTime(baselineMillis);
  DateTime current=new DateTime(currentMillis);
  String firstMetric=getMetrics(collection).get(0);
  String dummyFunction=String.format(DIMENSION_VALUES_OPTIONS_METRIC_FUNCTION,firstMetric);
  MultivaluedMap<String,String> dimensionValues=new MultivaluedMapImpl();
  Map<String,Future<QueryResult>> resultFutures=new HashMap<>();
  for (  String dimension : dimensions) {
    dimensionValues.put(dimension,Arrays.asList("!"));
    String sql=SqlUtils.getSql(dummyFunction,collection,baseline,current,dimensionValues,null);
    LOGGER.info("Generated SQL for dimension retrieval {}: {}",serverUri,sql);
    dimensionValues.remove(dimension);
    resultFutures.put(dimension,queryCache.getQueryResultAsync(serverUri,sql));
  }
  Map<String,Collection<String>> collectedDimensionValues=new HashMap<>();
  for (int i=0; i < dimensions.size(); i++) {
    String dimension=dimensions.get(i);
    QueryResult queryResult=resultFutures.get(dimension).get();
    double total=0.0;
    Map<String,Number> summedValues=new HashMap<>();
    for (    Map.Entry<String,Map<String,Number[]>> entry : queryResult.getData().entrySet()) {
      double sum=0.0;
      for (      Map.Entry<String,Number[]> hourlyEntry : entry.getValue().entrySet()) {
        double value=hourlyEntry.getValue()[0].doubleValue();
        sum+=value;
      }
      summedValues.put(entry.getKey(),sum);
      total+=sum;
    }
    PriorityQueue<Pair<String,Double>> topNValues=new PriorityQueue<>(dimensionValuesLimit,new Comparator<Pair<String,Double>>(){
      @Override public int compare(      Pair<String,Double> a,      Pair<String,Double> b){
        return Double.compare(a.getValue().doubleValue(),b.getValue().doubleValue());
      }
    }
);
    double threshold=total * contributionThreshold;
    for (    Map.Entry<String,Number> entry : summedValues.entrySet()) {
      List<String> combination=objectMapper.readValue(entry.getKey(),LIST_TYPE_REF);
      String dimensionValue=combination.get(i);
      double dimensionValueContribution=entry.getValue().doubleValue();
      if (dimensionValueContribution >= threshold) {
        topNValues.add(new Pair<>(dimensionValue,dimensionValueContribution));
        if (topNValues.size() > dimensionValuesLimit) {
          topNValues.poll();
        }
      }
    }
    List<String> sortedValues=new LinkedList<>();
    while (!topNValues.isEmpty()) {
      Pair<String,Double> pair=topNValues.poll();
      sortedValues.add(0,pair.getKey());
    }
    collectedDimensionValues.put(dimension,sortedValues);
  }
  return collectedDimensionValues;
}
