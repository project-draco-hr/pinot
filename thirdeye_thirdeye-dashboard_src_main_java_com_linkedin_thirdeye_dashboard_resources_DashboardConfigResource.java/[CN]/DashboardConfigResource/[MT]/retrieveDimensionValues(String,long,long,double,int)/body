{
  List<String> dimensions=getAllDimensions(collection);
  DateTime baseline=new DateTime(baselineMillis);
  DateTime current=new DateTime(currentMillis);
  List<String> metrics=getMetrics(collection);
  String dummyFunction=String.format(DIMENSION_VALUES_OPTIONS_METRIC_FUNCTION,METRIC_FUNCTION_JOINER.join(metrics));
  Multimap<String,String> dimensionValues=LinkedListMultimap.create();
  Map<String,List<Future<QueryResult>>> resultFutures=new HashMap<>();
  for (  String dimension : dimensions) {
    ArrayList<Future<QueryResult>> futures=new ArrayList<>();
    ThirdEyeRequest req1=new ThirdEyeRequestBuilder().setCollection(collection).setMetricFunction(dummyFunction).setStartTime(baseline).setEndTime(baseline.plusDays(1)).setDimensionValues(dimensionValues).setGroupBy(dimension).build();
    LOGGER.info("Generated request for dimension retrieval: {}",req1);
    futures.add(queryCache.getQueryResultAsync(req1));
    ThirdEyeRequest req2=new ThirdEyeRequestBuilder().setCollection(collection).setMetricFunction(dummyFunction).setStartTime(current.minusDays(1)).setEndTime(current).setDimensionValues(dimensionValues).setGroupBy(dimension).build();
    LOGGER.info("Generated request for dimension retrieval: {}",req2);
    futures.add(queryCache.getQueryResultAsync(req2));
    resultFutures.put(dimension,futures);
  }
  Map<String,Collection<String>> collectedDimensionValues=new HashMap<>();
  for (int i=0; i < dimensions.size(); i++) {
    String dimension=dimensions.get(i);
    int metricCount=metrics.size();
    double[] total=new double[metricCount];
    Map<String,double[]> summedValues=new HashMap<>();
    QueryResult mergedQueryResult=new QueryResult();
    boolean inited=false;
    for (    Future<QueryResult> futureQueryResult : resultFutures.get(dimension)) {
      QueryResult queryResult=futureQueryResult.get();
      if (!inited) {
        mergedQueryResult.setDimensions(queryResult.getDimensions());
        mergedQueryResult.setMetrics(queryResult.getMetrics());
        mergedQueryResult.setData(new HashMap<>(queryResult.getData()));
        inited=true;
      }
 else {
        for (        String dimValue : queryResult.getData().keySet()) {
          if (mergedQueryResult.getData().containsKey(dimValue)) {
            mergedQueryResult.getData().get(dimValue).putAll(queryResult.getData().get(dimValue));
          }
          mergedQueryResult.getData().put(dimValue,queryResult.getData().get(dimValue));
        }
      }
    }
    QueryResult queryResult=mergedQueryResult;
    for (    Map.Entry<String,Map<String,Number[]>> entry : queryResult.getData().entrySet()) {
      double[] sum=new double[metricCount];
      for (      Map.Entry<String,Number[]> hourlyEntry : entry.getValue().entrySet()) {
        for (int j=0; j < metricCount; j++) {
          double value=hourlyEntry.getValue()[j].doubleValue();
          sum[j]+=value;
        }
      }
      summedValues.put(entry.getKey(),sum);
      for (int j=0; j < metricCount; j++) {
        total[j]+=sum[j];
      }
    }
    List<PriorityQueue<Pair<String,Double>>> topNValuesByMetric=new ArrayList<PriorityQueue<Pair<String,Double>>>(metricCount);
    double[] threshold=new double[metricCount];
    Comparator<Pair<String,Double>> valueComparator=new Comparator<Pair<String,Double>>(){
      @Override public int compare(      Pair<String,Double> a,      Pair<String,Double> b){
        return Double.compare(a.getValue().doubleValue(),b.getValue().doubleValue());
      }
    }
;
    for (int j=0; j < metricCount; j++) {
      threshold[j]=total[j] * contributionThreshold;
      topNValuesByMetric.add(new PriorityQueue<>(dimensionValuesLimit,valueComparator));
    }
    for (    Map.Entry<String,double[]> entry : summedValues.entrySet()) {
      List<String> combination=objectMapper.readValue(entry.getKey(),LIST_TYPE_REF);
      String dimensionValue=combination.get(i);
      for (int j=0; j < metricCount; j++) {
        double dimensionValueContribution=entry.getValue()[j];
        if (dimensionValueContribution >= threshold[j]) {
          PriorityQueue<Pair<String,Double>> topNValues=topNValuesByMetric.get(j);
          topNValues.add(new Pair<>(dimensionValue,dimensionValueContribution));
          if (topNValues.size() > dimensionValuesLimit) {
            topNValues.poll();
          }
        }
      }
    }
    List<String> sortedValues=new ArrayList<>();
    HashSet<String> sortedValuesSet=new HashSet<>();
    for (int j=0; j < metricCount; j++) {
      PriorityQueue<Pair<String,Double>> topNValues=topNValuesByMetric.get(j);
      int startIndex=sortedValues.size();
      while (!topNValues.isEmpty()) {
        Pair<String,Double> pair=topNValues.poll();
        String dimensionValue=pair.getKey();
        if (!sortedValuesSet.contains(dimensionValue)) {
          sortedValues.add(startIndex,dimensionValue);
          sortedValuesSet.add(dimensionValue);
        }
      }
    }
    collectedDimensionValues.put(dimension,sortedValues);
  }
  return collectedDimensionValues;
}
