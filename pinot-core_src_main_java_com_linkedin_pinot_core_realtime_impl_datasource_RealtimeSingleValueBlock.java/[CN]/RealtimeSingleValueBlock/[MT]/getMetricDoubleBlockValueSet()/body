{
  return new BlockValSet(){
    @Override public BlockValIterator iterator(){
      return new BlockSingleValIterator(){
        private int counter=0;
        private int max=docIdSearchableOffset;
        @Override public boolean skipTo(        int docId){
          if (docId > max) {
            return false;
          }
          counter=docId;
          return true;
        }
        @Override public int size(){
          return max;
        }
        @Override public boolean reset(){
          counter=0;
          return true;
        }
        @Override public boolean next(){
          counter++;
          return counter > max;
        }
        @Override public int nextIntVal(){
          if (counter > max) {
            return Constants.EOF;
          }
          ByteBuffer rawData=metBuffs[counter++];
          return (int)metSerDe.getDoubleVal(columnName,rawData);
        }
        @Override public long nextLongVal(){
          if (counter > max) {
            return Constants.EOF;
          }
          ByteBuffer rawData=metBuffs[counter++];
          return (long)metSerDe.getDoubleVal(columnName,rawData);
        }
        @Override public float nextFloatVal(){
          if (counter > max) {
            return Constants.EOF;
          }
          ByteBuffer rawData=metBuffs[counter++];
          return (float)metSerDe.getDoubleVal(columnName,rawData);
        }
        @Override public double nextDoubleVal(){
          if (counter > max) {
            return Constants.EOF;
          }
          ByteBuffer rawData=metBuffs[counter++];
          return metSerDe.getDoubleVal(columnName,rawData);
        }
        @Override public boolean hasNext(){
          return (counter <= max);
        }
        @Override public DataType getValueType(){
          return spec.getDataType();
        }
        @Override public int currentDocId(){
          return counter;
        }
      }
;
    }
    @Override public DataType getValueType(){
      return spec.getDataType();
    }
  }
;
}
