{
  LOG.info("AnomalyFunction: {}",anomalyFunction);
  AnomalyFunctionSpec spec=anomalyFunction.getSpec();
  LOG.info("AnomalyFunctionSpec: {}",spec);
  timeSeriesHandler=(TimeSeriesHandler)context.getJobDetail().getJobDataMap().get(TIME_SERIES_HANDLER);
  timeSeriesResponseConverter=(TimeSeriesResponseConverter)context.getJobDetail().getJobDataMap().get(TIME_SERIES_RESPONSE_CONVERTER);
  resultDAO=(AnomalyResultDAO)context.getJobDetail().getJobDataMap().get(RESULT_DAO);
  relationDAO=(AnomalyFunctionRelationDAO)context.getJobDetail().getJobDataMap().get(RELATION_DAO);
  sessionFactory=(SessionFactory)context.getJobDetail().getJobDataMap().get(SESSION_FACTORY);
  metricRegistry=(MetricRegistry)context.getJobDetail().getJobDataMap().get(METRIC_REGISTRY);
  String windowEndProp=context.getJobDetail().getJobDataMap().getString(WINDOW_END);
  String windowStartProp=context.getJobDetail().getJobDataMap().getString(WINDOW_START);
  String histogramName=context.getJobDetail().getKey().getName();
  histogram=metricRegistry.getHistograms().get(histogramName);
  if (histogram == null) {
    histogram=metricRegistry.histogram(histogramName);
  }
  if (windowEndProp == null) {
    long delayMillis=0;
    if (spec.getWindowDelay() != null) {
      delayMillis=TimeUnit.MILLISECONDS.convert(spec.getWindowDelay(),spec.getWindowDelayUnit());
    }
    Date scheduledFireTime=context.getScheduledFireTime();
    windowEnd=new DateTime(scheduledFireTime).minus(delayMillis);
    LOG.info("Running anomaly detection job with scheduledFireTime: {}, delayMillis: {}, windowEnd: {}",scheduledFireTime,delayMillis,windowEnd);
  }
 else {
    windowEnd=ISODateTimeFormat.dateTimeParser().parseDateTime(windowEndProp);
  }
  if (windowStartProp == null) {
    int windowSize=spec.getWindowSize();
    TimeUnit windowUnit=spec.getWindowUnit();
    long windowMillis=TimeUnit.MILLISECONDS.convert(windowSize,windowUnit);
    windowStart=windowEnd.minus(windowMillis);
    LOG.info("Running anomaly detection job with windowUnit: {}, windowMillis: {}, windowStart: {}",windowUnit,windowMillis,windowStart);
  }
 else {
    windowStart=ISODateTimeFormat.dateTimeParser().parseDateTime(windowStartProp);
  }
  TimeGranularity timeGranularity=new TimeGranularity(spec.getBucketSize(),spec.getBucketUnit());
  metricFunction=new MetricFunction(MetricFunction.SUM,spec.getMetric());
  collection=spec.getCollection();
  LOG.info("Running anomaly detection job with metricFunction: {}, collection: {}",metricFunction,collection);
  try {
    CollectionSchema collectionSchema=timeSeriesHandler.getClient().getCollectionSchema(collection);
    collectionDimensions=collectionSchema.getDimensionNames();
  }
 catch (  Exception e) {
    throw new JobExecutionException(e);
  }
  knownAnomalies=getExistingAnomalies();
  Queue<TimeSeriesRequest> timeSeriesRequestQueue=new LinkedList<>();
  TimeSeriesRequest topLevelRequest=new TimeSeriesRequest();
  topLevelRequest.setCollectionName(collection);
  List<MetricFunction> metricFunctions=Collections.singletonList(metricFunction);
  List<MetricExpression> metricExpressions=Utils.convertToMetricExpressions(metricFunctions);
  topLevelRequest.setMetricExpressions(metricExpressions);
  topLevelRequest.setAggregationTimeGranularity(timeGranularity);
  topLevelRequest.setStart(windowStart);
  topLevelRequest.setEnd(windowEnd);
  topLevelRequest.setEndDateInclusive(false);
  LOG.info("Running anomaly detection job with windowStartProp: {}, windowEndProp: {}, metricExpressions: {}, timeGranularity: {}, windowStart: {}, windowEnd: {}",windowStartProp,windowEndProp,metricExpressions,timeGranularity,windowStart,windowEnd);
  String filters=spec.getFilters();
  if (StringUtils.isNotBlank(filters)) {
    topLevelRequest.setFilterSet(spec.getFilterSet());
  }
  String exploreDimensionsString=spec.getExploreDimensions();
  if (StringUtils.isBlank(exploreDimensionsString)) {
    timeSeriesRequestQueue.add(topLevelRequest);
  }
 else {
    List<String> exploreDimensions=Arrays.asList(exploreDimensionsString.split(","));
    for (    String exploreDimension : exploreDimensions) {
      TimeSeriesRequest groupByRequest=new TimeSeriesRequest(topLevelRequest);
      groupByRequest.setGroupByDimensions(Collections.singletonList(exploreDimension));
      timeSeriesRequestQueue.add(groupByRequest);
    }
  }
  while (!timeSeriesRequestQueue.isEmpty()) {
    try {
      List<TimeSeriesRequest> nextRequests=exploreCombination(timeSeriesRequestQueue.remove());
    }
 catch (    Exception e) {
      throw new JobExecutionException(e);
    }
  }
  LOG.info("{} anomalies found in total",anomalyCounter);
}
