{
  Map<Pair<String,String>,Map<String,MetricTable>> table=new HashMap<>();
  List<MetricDataRow> referenceRows=null;
  Map<String,Double> totalCounts=new HashMap<>();
  for (  String metric : metrics) {
    if (referenceRows == null) {
      referenceRows=totalRow.get(metric).getRows();
    }
    totalCounts.put(metric,getContributionCount(totalRow.get(metric)));
  }
  for (  String dimension : dimensionCurrentResults.keySet()) {
    Map<String,Map<String,Double>> weightsByMetric=new HashMap<>();
    Map<String,Map<String,MetricTable>> tablesByMetric=new HashMap<>();
    for (    String metric : metrics) {
      weightsByMetric.put(metric,new HashMap<String,Double>());
      tablesByMetric.put(metric,new HashMap<String,MetricTable>());
    }
    QueryResult queryBaselineResult=dimensionBaselineResults.get(dimension);
    QueryResult queryCurrentResult=dimensionCurrentResults.get(dimension);
    int dimensionValueIndex=queryCurrentResult.getDimensions().indexOf(dimension);
    for (    String dimensionValuesKey : queryCurrentResult.getData().keySet()) {
      List<String> dimensionValues=objectMapper.readValue(dimensionValuesKey.getBytes(),LIST_TYPE_REF);
      String dimensionValue=dimensionValues.get(dimensionValueIndex);
      Map<String,Number[]> currentValues=queryCurrentResult.getData().get(dimensionValuesKey);
      Map<String,Number[]> baselineValues=queryBaselineResult.getData().get(dimensionValuesKey);
      MetricTable row=generateTableRowWithReference(queryBaselineResult,baselineStart,currentStart,intraPeriod,baselineOffset,baselineValues,currentValues,referenceRows);
      Map<String,MetricTable> metricRows=expandMetrics(row,metrics);
      for (      String metric : metrics) {
        MetricTable metricRow=metricRows.get(metric);
        Map<String,MetricTable> tables=tablesByMetric.get(metric);
        Map<String,Double> weights=weightsByMetric.get(metric);
        double contributionCount=getContributionCount(metricRow);
        double totalCount=totalCounts.get(metric);
        double contribution=(contributionCount / totalCount);
        LOGGER.debug("Meets threshold? {} : {} / {} for {} {} {}",contribution >= MINIMUM_DIMENSION_VALUE_THRESHOLD,contributionCount,totalCount,metric,dimension,dimensionValue);
        if (OTHER_DIMENSION_VALUE.equals(dimensionValue) || OTHER_DIMENSION_VALUE_MATCH_STR.equalsIgnoreCase(dimensionValue) || contribution < MINIMUM_DIMENSION_VALUE_THRESHOLD) {
          MetricTable otherRow=tables.get(OTHER_DIMENSION_VALUE);
          if (otherRow != null) {
            LOGGER.debug("Adding {} ({}) to OTHER ({})",dimensionValue,contributionCount,getContributionCount(otherRow));
            metricRow=mergeTables(metricRow,otherRow,1);
          }
          dimensionValue=OTHER_DIMENSION_VALUE;
          contributionCount=getContributionCount(metricRow);
          contribution=(contributionCount / totalCount);
        }
        weights.put(dimensionValue,contribution);
        tables.put(dimensionValue,metricRow);
      }
    }
    for (    String metric : metrics) {
      LinkedHashMap<String,MetricTable> dimensionValueTable=new LinkedHashMap<String,MetricTable>();
      table.put(new Pair<String,String>(metric,dimension),dimensionValueTable);
      Map<String,Double> weights=weightsByMetric.get(metric);
      Map<String,MetricTable> tables=tablesByMetric.get(metric);
      List<Entry<String,Double>> sortedEntries=sortedEntriesByValue(weights);
      Collections.reverse(sortedEntries);
      for (      Entry<String,Double> entry : sortedEntries) {
        String dimensionValue=entry.getKey();
        MetricTable metricRow=tables.get(dimensionValue);
        dimensionValueTable.put(dimensionValue,metricRow);
      }
    }
  }
  return table;
}
