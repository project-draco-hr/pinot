{
  IntraPeriod intraPeriod=ViewUtils.getIntraPeriod(metricFunction);
  long intraPeriodMillis=intraPeriod.getMillis();
  baselineStart=ViewUtils.standardizeDate(baselineStart,intraPeriod);
  currentStart=ViewUtils.standardizeDate(currentStart,intraPeriod);
  long baselineOffset=currentStart.getMillis() - baselineStart.getMillis();
  Multimap<String,String> expandedDimensionValues=ThirdEyeRequestUtils.expandDimensionGroups(selectedDimensions,reverseDimensionGroups);
  ThirdEyeRequest baselineTotalReq=new ThirdEyeRequestBuilder().setCollection(collection).setMetricFunction(metricFunction).setStartTime(baselineStart).setEndTime(baselineStart.plus(intraPeriodMillis)).setDimensionValues(expandedDimensionValues).build();
  ThirdEyeRequest currentTotalReq=new ThirdEyeRequestBuilder().setCollection(collection).setMetricFunction(metricFunction).setStartTime(currentStart).setEndTime(currentStart.plus(intraPeriodMillis)).setDimensionValues(expandedDimensionValues).build();
  LOGGER.info("Generated request for contributor baseline total: {}",baselineTotalReq);
  LOGGER.info("Generated request for contributor current total: {}",currentTotalReq);
  Future<QueryResult> baselineTotalResultFuture=queryCache.getQueryResultAsync(baselineTotalReq);
  Future<QueryResult> currentTotalResultFuture=queryCache.getQueryResultAsync(currentTotalReq);
  Map<String,Future<QueryResult>> baselineResultFutures=new HashMap<>();
  Map<String,Future<QueryResult>> currentResultFutures=new HashMap<>();
  for (  String dimension : dimensions) {
    if (!selectedDimensions.containsKey(dimension)) {
      ThirdEyeRequest baselineGroupByReq=new ThirdEyeRequestBuilder().setCollection(collection).setMetricFunction(metricFunction).setStartTime(baselineStart).setEndTime(baselineStart.plus(intraPeriodMillis)).setDimensionValues(expandedDimensionValues).setGroupBy(dimension).build();
      ThirdEyeRequest currentGroupByReq=new ThirdEyeRequestBuilder().setCollection(collection).setMetricFunction(metricFunction).setStartTime(currentStart).setEndTime(currentStart.plus(intraPeriodMillis)).setDimensionValues(expandedDimensionValues).setGroupBy(dimension).build();
      LOGGER.info("Generated request for contributor baseline {} : {}",dimension,baselineGroupByReq);
      LOGGER.info("Generated request for contributor current {}: {}",dimension,currentGroupByReq);
      baselineResultFutures.put(dimension,queryCache.getQueryResultAsync(baselineGroupByReq));
      currentResultFutures.put(dimension,queryCache.getQueryResultAsync(currentGroupByReq));
    }
 else {
      LOGGER.warn("Found overlap between dimensions to query and pre-selected dimensions: ({}:{})",dimension,selectedDimensions.get(dimension));
    }
  }
  QueryResult baselineTotalResult=baselineTotalResultFuture.get();
  QueryResult currentTotalResult=currentTotalResultFuture.get();
  Map<String,QueryResult> dimensionBaselineResults=new HashMap<>(baselineResultFutures.size());
  Map<String,QueryResult> dimensionCurrentResults=new HashMap<>(currentResultFutures.size());
  for (  Map.Entry<String,Future<QueryResult>> entry : baselineResultFutures.entrySet()) {
    dimensionBaselineResults.put(entry.getKey(),entry.getValue().get());
  }
  for (  Map.Entry<String,Future<QueryResult>> entry : currentResultFutures.entrySet()) {
    dimensionCurrentResults.put(entry.getKey(),entry.getValue().get());
  }
  Map<String,MetricTable> totalRow=generateMetricTotalTable(baselineTotalResult,currentTotalResult,baselineStart.getMillis(),currentStart.getMillis(),intraPeriodMillis,baselineOffset);
  List<String> metrics=currentTotalResult.getMetrics();
  Map<Pair<String,String>,Map<String,MetricTable>> tables=generateDimensionTables(metrics,totalRow,dimensionBaselineResults,dimensionCurrentResults,baselineStart.getMillis(),currentStart.getMillis(),intraPeriodMillis,baselineOffset);
  return new DimensionViewContributors(metrics,dimensions,totalRow,tables);
}
