{
  IntraPeriod intraPeriod=ViewUtils.getIntraPeriod(metricFunction);
  long intraPeriodMillis=intraPeriod.getMillis();
  baselineStart=ViewUtils.standardizeDate(baselineStart,intraPeriod);
  currentStart=ViewUtils.standardizeDate(currentStart,intraPeriod);
  long baselineOffset=currentStart.getMillis() - baselineStart.getMillis();
  String baselineTotalSql=SqlUtils.getSql(metricFunction,collection,baselineStart,baselineStart.plus(intraPeriodMillis),selectedDimensions,reverseDimensionGroups);
  String currentTotalSql=SqlUtils.getSql(metricFunction,collection,currentStart,currentStart.plus(intraPeriodMillis),selectedDimensions,reverseDimensionGroups);
  LOGGER.info("Generated SQL for contributor baseline total {}: {}",uriInfo.getRequestUri(),baselineTotalSql);
  LOGGER.info("Generated SQL for contributor current total {}: {}",uriInfo.getRequestUri(),currentTotalSql);
  Future<QueryResult> baselineTotalResultFuture=queryCache.getQueryResultAsync(serverUri,baselineTotalSql);
  Future<QueryResult> currentTotalResultFuture=queryCache.getQueryResultAsync(serverUri,currentTotalSql);
  Map<String,Future<QueryResult>> baselineResultFutures=new HashMap<>();
  Map<String,Future<QueryResult>> currentResultFutures=new HashMap<>();
  for (  String dimension : dimensions) {
    if (!selectedDimensions.containsKey(dimension)) {
      selectedDimensions.put(dimension,Arrays.asList("!"));
      String baselineGroupBySql=SqlUtils.getSql(metricFunction,collection,baselineStart,baselineStart.plus(intraPeriodMillis),selectedDimensions,reverseDimensionGroups);
      String currentGroupBySql=SqlUtils.getSql(metricFunction,collection,currentStart,currentStart.plus(intraPeriodMillis),selectedDimensions,reverseDimensionGroups);
      LOGGER.info("Generated SQL for contributor baseline {} {}: {}",dimension,uriInfo.getRequestUri(),baselineGroupBySql);
      LOGGER.info("Generated SQL for contributor current {} {}: {}",dimension,uriInfo.getRequestUri(),currentGroupBySql);
      selectedDimensions.remove(dimension);
      baselineResultFutures.put(dimension,queryCache.getQueryResultAsync(serverUri,baselineGroupBySql));
      currentResultFutures.put(dimension,queryCache.getQueryResultAsync(serverUri,currentGroupBySql));
    }
 else {
      LOGGER.warn("Found overlap between dimensions to query and pre-selected dimensions: ({}:{})",dimension,selectedDimensions.get(dimension));
    }
  }
  QueryResult baselineTotalResult=baselineTotalResultFuture.get();
  QueryResult currentTotalResult=currentTotalResultFuture.get();
  Map<String,QueryResult> dimensionBaselineResults=new HashMap<>(baselineResultFutures.size());
  Map<String,QueryResult> dimensionCurrentResults=new HashMap<>(currentResultFutures.size());
  for (  Map.Entry<String,Future<QueryResult>> entry : baselineResultFutures.entrySet()) {
    dimensionBaselineResults.put(entry.getKey(),entry.getValue().get());
  }
  for (  Map.Entry<String,Future<QueryResult>> entry : currentResultFutures.entrySet()) {
    dimensionCurrentResults.put(entry.getKey(),entry.getValue().get());
  }
  Map<String,MetricTable> totalRow=generateMetricTotalTable(baselineTotalResult,currentTotalResult,baselineStart.getMillis(),currentStart.getMillis(),intraPeriodMillis,baselineOffset);
  List<String> metrics=currentTotalResult.getMetrics();
  Map<Pair<String,String>,Map<String,MetricTable>> tables=generateDimensionTables(metrics,totalRow,dimensionBaselineResults,dimensionCurrentResults,baselineStart.getMillis(),currentStart.getMillis(),intraPeriodMillis,baselineOffset);
  return new DimensionViewContributors(metrics,dimensions,totalRow,tables);
}
