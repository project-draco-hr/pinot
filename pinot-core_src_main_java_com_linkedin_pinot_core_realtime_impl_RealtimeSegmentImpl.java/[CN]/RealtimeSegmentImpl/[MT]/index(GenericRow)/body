{
  if (numDocsIndexed >= capacity) {
    return false;
  }
  for (  String dimension : dataSchema.getDimensionNames()) {
    dictionaryMap.get(dimension).index(row.getValue(dimension));
    if (!dataSchema.getFieldSpecFor(dimension).isSingleValueField()) {
      Object[] entries=(Object[])row.getValue(dimension);
      if ((entries != null) && (maxNumberOfMultivaluesMap.get(dimension) < entries.length)) {
        maxNumberOfMultivaluesMap.put(dimension,entries.length);
      }
    }
  }
  Object timeValueObj=timeConverter.convert(row.getValue(incomingTimeColumnName));
  long timeValue=-1;
  if (timeValueObj instanceof Integer) {
    timeValue=((Integer)timeValueObj).longValue();
  }
 else {
    timeValue=(Long)timeValueObj;
  }
  dictionaryMap.get(outgoingTimeColumnName).index(timeValueObj);
  minTimeVal=Math.min(minTimeVal,timeValue);
  maxTimeVal=Math.max(maxTimeVal,timeValue);
  Map<String,Object> rawRowToDicIdMap=new HashMap<String,Object>();
  int docId=docIdGenerator.incrementAndGet();
  for (  String dimension : dataSchema.getDimensionNames()) {
    if (dataSchema.getFieldSpecFor(dimension).isSingleValueField()) {
      int dicId=dictionaryMap.get(dimension).indexOf(row.getValue(dimension));
      ((FixedByteSingleColumnSingleValueReaderWriter)columnIndexReaderWrtierMap.get(dimension)).setInt(docId,dicId);
      rawRowToDicIdMap.put(dimension,dicId);
    }
 else {
      Object[] mValues=(Object[])row.getValue(dimension);
      int[] dicIds=new int[mValues.length];
      for (int i=0; i < dicIds.length; i++) {
        dicIds[i]=dictionaryMap.get(dimension).indexOf(mValues[i]);
      }
      ((FixedByteSingleColumnMultiValueReaderWriter)columnIndexReaderWrtierMap.get(dimension)).setIntArray(docId,dicIds);
      rawRowToDicIdMap.put(dimension,dicIds);
    }
  }
  for (  String metric : dataSchema.getMetricNames()) {
    FixedByteSingleColumnSingleValueReaderWriter rederWriter=(FixedByteSingleColumnSingleValueReaderWriter)columnIndexReaderWrtierMap.get(metric);
switch (dataSchema.getFieldSpecFor(metric).getDataType()) {
case INT:
      int intEntry=((Integer)row.getValue(metric)).intValue();
    rederWriter.setInt(docId,intEntry);
  break;
case FLOAT:
float floatEntry=((Float)row.getValue(metric)).floatValue();
rederWriter.setFloat(docId,floatEntry);
break;
case LONG:
long longEntry=((Long)row.getValue(metric)).longValue();
rederWriter.setLong(docId,longEntry);
break;
case DOUBLE:
double doubleEntry=((Double)row.getValue(metric)).doubleValue();
rederWriter.setDouble(docId,doubleEntry);
break;
default :
throw new UnsupportedOperationException("unsupported metric data type for : " + metric + " of type : "+ dataSchema.getFieldSpecFor(metric).getDataType());
}
}
int timeDicId=dictionaryMap.get(outgoingTimeColumnName).indexOf(timeValueObj);
((FixedByteSingleColumnSingleValueReaderWriter)columnIndexReaderWrtierMap.get(outgoingTimeColumnName)).setInt(docId,timeDicId);
rawRowToDicIdMap.put(outgoingTimeColumnName,timeDicId);
for (String metric : dataSchema.getMetricNames()) {
invertedIndexMap.get(metric).add(row.getValue(metric),docId);
}
for (String dimension : dataSchema.getDimensionNames()) {
if (dataSchema.getFieldSpecFor(dimension).isSingleValueField()) {
invertedIndexMap.get(dimension).add(rawRowToDicIdMap.get(dimension),docId);
}
 else {
int[] dicIds=(int[])rawRowToDicIdMap.get(dimension);
for (int dicId : dicIds) {
invertedIndexMap.get(dimension).add(dicId,docId);
}
}
}
invertedIndexMap.get(outgoingTimeColumnName).add(rawRowToDicIdMap.get(outgoingTimeColumnName),docId);
docIdSearchableOffset=docId;
numDocsIndexed++;
numSuccessIndexed++;
return true;
}
