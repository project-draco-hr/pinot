{
  StarTree starTree=starTreeManager.getStarTree(collection);
  if (starTree == null) {
    throw new NotFoundException("No collection " + collection);
  }
  Funnel.Type funnelType;
  try {
    funnelType=Funnel.Type.valueOf(type.toUpperCase());
  }
 catch (  Exception e) {
    throw new NotFoundException("Unrecognized funnel type " + type);
  }
  List<String> funnelMetrics=Arrays.asList(metrics.split(","));
  if (funnelMetrics.size() < 2) {
    throw new WebApplicationException(new IllegalStateException("Funnel must specify at least two metrics: " + funnelMetrics),Response.Status.BAD_REQUEST);
  }
  MetricSpec topMetric=null;
  Map<String,MetricSpec> metricSpecs=new HashMap<String,MetricSpec>();
  for (  MetricSpec metricSpec : starTree.getConfig().getMetrics()) {
    if (metricSpec.getName().equals(funnelMetrics.get(0))) {
      topMetric=metricSpec;
    }
    metricSpecs.put(metricSpec.getName(),metricSpec);
  }
  if (topMetric == null) {
    throw new WebApplicationException(new IllegalStateException("Baseline metric not found " + funnelMetrics.get(0)),500);
  }
  int bucketSize=starTree.getConfig().getTime().getBucket().getSize();
  TimeUnit bucketUnit=starTree.getConfig().getTime().getBucket().getUnit();
  Long aggregateValue="".equals(aggregate) ? null : bucketUnit.convert(Long.valueOf(aggregate.split("/")[2]),TimeUnit.MILLISECONDS) / bucketSize;
  Long movingAverageValue="".equals(movingAverage) ? null : bucketUnit.convert(Long.valueOf(movingAverage.split("/")[2]),TimeUnit.MILLISECONDS) / bucketSize;
  long start=bucketUnit.convert(startMillis,TimeUnit.MILLISECONDS) / bucketSize;
  long end=bucketUnit.convert(endMillis,TimeUnit.MILLISECONDS) / bucketSize;
  if (aggregateValue != null) {
    start=(start / aggregateValue) * aggregateValue;
    end=(end / aggregateValue) * aggregateValue;
  }
  StarTreeStats stats=starTree.getStats();
  if (!new TimeRange(stats.getMinTime(),stats.getMaxTime()).contains(new TimeRange(start,end))) {
    throw new NotFoundException("Query (" + QueryUtils.getDateTime(start,bucketSize,bucketUnit) + ", "+ QueryUtils.getDateTime(end,bucketSize,bucketUnit)+ ") not in range ("+ QueryUtils.getDateTime(stats.getMinTime(),bucketSize,bucketUnit)+ ", "+ QueryUtils.getDateTime(stats.getMaxTime(),bucketSize,bucketUnit)+ ")");
  }
  Map<DimensionKey,MetricTimeSeries> result;
  if (movingAverageValue == null && aggregateValue == null) {
    result=QueryUtils.doQuery(starTree,start,end,uriInfo);
  }
 else   if (movingAverageValue != null && aggregateValue == null) {
    result=QueryUtils.doQuery(starTree,start - movingAverageValue,end,uriInfo);
  }
 else   if (movingAverageValue == null && aggregateValue != null) {
    result=QueryUtils.doQuery(starTree,start,end + aggregateValue,uriInfo);
  }
 else {
    result=QueryUtils.doQuery(starTree,start - (movingAverageValue / aggregateValue) * aggregateValue,end + aggregateValue,uriInfo);
  }
  List<Funnel> funnels=new ArrayList<Funnel>();
  for (  Map.Entry<DimensionKey,MetricTimeSeries> entry : result.entrySet()) {
    List<FunnelRow> rows=new ArrayList<FunnelRow>();
    rows.add(FunnelRow.createTopRow(topMetric));
    double topStartValue=entry.getValue().get(start,topMetric.getName()).doubleValue();
    double topEndValue=entry.getValue().get(end,topMetric.getName()).doubleValue();
    for (int i=1; i < funnelMetrics.size(); i++) {
      MetricSpec previousMetric=metricSpecs.get(funnelMetrics.get(i - 1));
      if (previousMetric == null) {
        throw new WebApplicationException(new IllegalStateException("Metric not found " + funnelMetrics.get(i - 1)),500);
      }
      double previousStartValue=entry.getValue().get(start,previousMetric.getName()).doubleValue();
      double previousEndValue=entry.getValue().get(end,previousMetric.getName()).doubleValue();
      MetricSpec currentMetric=metricSpecs.get(funnelMetrics.get(i));
      if (currentMetric == null) {
        throw new WebApplicationException(new IllegalStateException("Metric not found " + funnelMetrics.get(i)),500);
      }
      double currentStartValue=entry.getValue().get(start,currentMetric.getName()).doubleValue();
      double currentEndValue=entry.getValue().get(end,currentMetric.getName()).doubleValue();
switch (funnelType) {
case TOP:
        double currentToTopStart=Double.POSITIVE_INFINITY;
      double currentToTopEnd=Double.POSITIVE_INFINITY;
    if (topStartValue > 0) {
      currentToTopStart=currentStartValue / topStartValue;
    }
  if (topEndValue > 0) {
    currentToTopEnd=currentEndValue / topEndValue;
  }
rows.add(new FunnelRow(currentMetric,currentToTopStart,currentToTopEnd));
break;
case PREVIOUS:
double currentToPreviousStart=Double.POSITIVE_INFINITY;
double currentToPreviousEnd=Double.POSITIVE_INFINITY;
if (previousStartValue > 0) {
currentToPreviousStart=currentStartValue / previousStartValue;
}
if (previousEndValue > 0) {
currentToPreviousEnd=currentEndValue / previousEndValue;
}
rows.add(new FunnelRow(currentMetric,currentToPreviousStart,currentToPreviousEnd));
break;
default :
throw new IllegalArgumentException("Unsupported funnel type " + type);
}
}
funnels.add(new Funnel(QueryUtils.convertDimensionKey(starTree.getConfig().getDimensions(),entry.getKey()),rows));
}
return funnels;
}
