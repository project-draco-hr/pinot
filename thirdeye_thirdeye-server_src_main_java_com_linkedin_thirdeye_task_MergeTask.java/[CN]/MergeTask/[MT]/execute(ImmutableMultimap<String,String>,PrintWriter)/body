{
  for (  String collection : params.get("collection")) {
    printWriter.println("NOTE: WILL ONLY MERGE data_KAFKA* trees currently!");
    printWriter.println("Merging trees for " + collection);
    printWriter.flush();
    Map<File,StarTree> toMerge=new HashMap<>();
    for (    Map.Entry<File,StarTree> entry : starTreeManager.getStarTrees(collection).entrySet()) {
      File dataDir=entry.getKey();
      if (dataDir.getName().startsWith("data_KAFKA")) {
        printWriter.println("Will merge " + dataDir);
        printWriter.flush();
        toMerge.put(entry.getKey(),entry.getValue());
      }
    }
    DateTime minTime=null;
    DateTime maxTime=null;
    for (    File dataDir : toMerge.keySet()) {
      String[] tokens=dataDir.getName().split("_");
      DateTime segmentMinTime=StarTreeConstants.DATE_TIME_FORMATTER.parseDateTime(tokens[2]);
      DateTime segmentMaxTime=StarTreeConstants.DATE_TIME_FORMATTER.parseDateTime(tokens[3]);
      if (minTime == null || segmentMinTime.compareTo(minTime) < 0) {
        minTime=segmentMinTime.toDateTime(DateTimeZone.UTC);
      }
      if (maxTime == null || segmentMaxTime.compareTo(maxTime) > 0) {
        maxTime=segmentMaxTime.toDateTime(DateTimeZone.UTC);
      }
    }
    printWriter.println("Min time for merged tree " + minTime);
    printWriter.println("Max time for merged tree " + maxTime);
    printWriter.flush();
    printWriter.println("Merging...");
    printWriter.flush();
    StarTree mergedTree=dataUpdateManager.mergeTrees(toMerge.values());
    printWriter.println("Persisting merged tree...");
    printWriter.flush();
    dataUpdateManager.persistTree(collection,"KAFKA-MERGED",minTime,maxTime,mergedTree);
    printWriter.println("Removing original trees...");
    printWriter.flush();
    for (    File dataDir : toMerge.keySet()) {
      printWriter.println("Removing " + dataDir);
      printWriter.flush();
      FileUtils.forceDelete(dataDir);
    }
    printWriter.println("Done!");
    printWriter.flush();
  }
}
