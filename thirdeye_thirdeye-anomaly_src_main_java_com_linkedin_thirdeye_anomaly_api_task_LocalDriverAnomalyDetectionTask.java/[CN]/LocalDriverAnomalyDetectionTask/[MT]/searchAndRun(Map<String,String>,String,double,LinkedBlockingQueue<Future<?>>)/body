{
  boolean shouldContinueExploring=true;
  Map<DimensionKey,MetricTimeSeries> dataset=getDataset(dimensionValues,groupByDimension);
  Map<DimensionKey,Double> dimensionKeyContributionMap=computeDatasetProportions(dataset,dimensionKeyContributionMetric);
  Set<DimensionKey> dimensionKeysEvaluated=new HashSet<>();
  Set<DimensionKey> dimensionKeysWithAnomalies=new HashSet<>();
  for (  DimensionKey dimensionKey : dataset.keySet()) {
    if (dimensionKeyContributionMap != null) {
      double proportion=dimensionKeyContributionMap.get(dimensionKey) * proportionMultiplier;
      if (proportion <= driverConfig.getContributionMinProportion()) {
        LOGGER.info("skipping series {} - proportion ({}) below threshold",dimensionKey,String.format("%.4f",proportion));
        continue;
      }
 else {
        LOGGER.info("analyzing series {} - proportion ({})",dimensionKey,String.format("%.4f",proportion));
      }
    }
    LOGGER.info("evaluating series for key {}",dimensionKey);
    MetricTimeSeries series=dataset.get(dimensionKey);
    List<AnomalyResult> anomalyResults=null;
    try {
      anomalyResults=analyze(dimensionKey,series);
    }
 catch (    FunctionDidNotEvaluateException e) {
      LOGGER.warn("failed to execute function - {}",getFunction().toString(),e);
      continue;
    }
    handleAnomalyResults(dimensionKey,dimensionKeyContributionMap.get(dimensionKey),anomalyResults);
    dimensionKeysEvaluated.add(dimensionKey);
    if (anomalyResults.isEmpty() == false) {
      dimensionKeysWithAnomalies.add(dimensionKey);
    }
    LOGGER.info("finished analysis on {} between {} ({})",dimensionKey,getTaskInfo().getTimeRange(),DateTimeZone.getDefault());
  }
  int currentExplorationDepth=dimensionValues.size();
  if (groupByDimension != null) {
    currentExplorationDepth++;
  }
  if (currentExplorationDepth >= driverConfig.getMaxExplorationDepth()) {
    shouldContinueExploring=false;
  }
  if (shouldContinueExploring) {
    List<Runnable> runnables=new LinkedList<>();
    Set<String> dimensionsExplored=new HashSet<>(dimensionValues.keySet());
    if (groupByDimension != null) {
      dimensionsExplored.add(groupByDimension);
    }
    Set<String> nextGroupByCandidates=getDimensionKeysToGroupBy(dimensionsExplored);
    for (    DimensionKey dimensionKey : dimensionKeysEvaluated) {
      if (driverConfig.isPruneExplortaionUsingFeedback() && dimensionKeysWithAnomalies.contains(dimensionKey)) {
        LOGGER.info("pruned computation due to anomaly in enclosing series");
        continue;
      }
      if (groupByDimension != null) {
        String fixedDimensionValue=dimensionKey.getDimensionValue(getStarTreeConfig().getDimensions(),groupByDimension);
        LOGGER.info("fixing dimension '{}' to '{}'",groupByDimension,fixedDimensionValue);
        dimensionValues.put(groupByDimension,fixedDimensionValue);
      }
      for (      final String nextGroupByDimension : nextGroupByCandidates) {
        LOGGER.info("grouping by '{}'",nextGroupByDimension);
        final double nextProportionMultiplier=proportionMultiplier * dimensionKeyContributionMap.get(dimensionKey);
        final HashMap<String,String> nextDimensionValues=new HashMap<>(dimensionValues);
        runnables.add(getRunnableSearchAndRun(futures,nextGroupByDimension,nextProportionMultiplier,nextDimensionValues));
      }
    }
    for (    Runnable runnable : runnables) {
      futures.add(SHARED_EXECUTORS.submit(runnable));
    }
  }
}
