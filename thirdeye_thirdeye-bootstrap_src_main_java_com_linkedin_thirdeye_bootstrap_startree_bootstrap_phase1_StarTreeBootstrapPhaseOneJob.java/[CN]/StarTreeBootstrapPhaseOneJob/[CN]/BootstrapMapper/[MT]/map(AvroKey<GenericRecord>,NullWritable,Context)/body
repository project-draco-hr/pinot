{
  long start=System.currentTimeMillis();
  StarTreeRecord parsedRecord=ThirdEyeAvroUtils.convert(starTreeConfig,record.datum());
  if (parsedRecord == null) {
    context.getCounter(StarTreeBootstrapPhase1Counter.INVALID_TIME_RECORDS).increment(1);
    return;
  }
  for (  Long time : parsedRecord.getMetricTimeSeries().getTimeWindowSet()) {
    for (    MetricSpec metricSpec : starTreeConfig.getMetrics()) {
      Number metricValue=parsedRecord.getMetricTimeSeries().get(time,metricSpec.getName());
      context.getCounter(config.getCollectionName(),metricSpec.getName()).increment(metricValue.longValue());
    }
  }
  collector.clear();
  MetricTimeSeries emptyTimeSeries=new MetricTimeSeries(metricSchema);
  StarTreeRecord starTreeRecord=new StarTreeRecordImpl(starTreeConfig,parsedRecord.getDimensionKey(),emptyTimeSeries);
  StarTreeJobUtils.collectRecords(starTreeConfig,starTreeRootNode,starTreeRecord,collector);
  LOGGER.debug("processing {}",parsedRecord.getDimensionKey());
  LOGGER.debug("times series {}",parsedRecord.getMetricTimeSeries());
  for (  UUID uuid : collector.keySet()) {
    if (!leafNodesMap.containsKey(uuid)) {
      String msg="Got a mapping to non existant leaf node:" + uuid + " - "+ collector.get(uuid)+ " input :"+ starTreeRecord;
      LOGGER.error(msg);
      throw new RuntimeException(msg);
    }
    List<int[]> leafRecords=nodeIdToleafRecordsMap.get(uuid);
    Map<String,Map<String,Integer>> forwardIndex=forwardIndexMap.get(uuid);
    Map<String,Map<Integer,String>> reverseForwardIndex=StarTreeUtils.toReverseIndex(forwardIndex);
    int[] bestMatch=StarTreeJobUtils.findBestMatch(parsedRecord.getDimensionKey(),dimensionNames,leafRecords,forwardIndex);
    String[] dimValues=StarTreeUtils.convertToStringValue(reverseForwardIndex,bestMatch,dimensionNames);
    DimensionKey matchedDimensionKey=new DimensionKey(dimValues);
    if (debug) {
      LOGGER.info("Match: {} under {}",matchedDimensionKey,leafNodesMap.get(uuid).getPath());
    }
    BootstrapPhaseMapOutputKey outputKey=new BootstrapPhaseMapOutputKey(uuid,matchedDimensionKey.toMD5());
    BootstrapPhaseMapOutputValue bootstrapPhaseMapOutputValue=outputKeyValueCache.get(outputKey);
    if (bootstrapPhaseMapOutputValue == null) {
      MetricTimeSeries timeSeries=new MetricTimeSeries(metricSchema);
      timeSeries.aggregate(parsedRecord.getMetricTimeSeries());
      BootstrapPhaseMapOutputValue outputValue=new BootstrapPhaseMapOutputValue(matchedDimensionKey,timeSeries);
      outputKeyValueCache.put(outputKey,outputValue);
      totalDimensionKeys=totalDimensionKeys + 1;
      totalTimeSeriesSize=totalTimeSeriesSize + parsedRecord.getMetricTimeSeries().getTimeWindowSet().size();
    }
 else {
      int oldSize=bootstrapPhaseMapOutputValue.metricTimeSeries.getTimeWindowSet().size();
      bootstrapPhaseMapOutputValue.metricTimeSeries.aggregate(parsedRecord.getMetricTimeSeries());
      int newSize=bootstrapPhaseMapOutputValue.metricTimeSeries.getTimeWindowSet().size();
      totalTimeSeriesSize=totalTimeSeriesSize + (newSize - oldSize);
    }
  }
  if (totalTimeSeriesSize > maxTimeSeriesToCache) {
    flushCache(context);
    outputKeyValueCache.clear();
    totalDimensionKeys=0;
    totalTimeSeriesSize=0;
  }
  long end=System.currentTimeMillis();
  inputCount=inputCount + 1;
  outputCount=outputCount + collector.size();
  totalTime=totalTime + (end - start);
  if (inputCount % 5000 == 0) {
    LOGGER.info("Processed {} in {}. avg time {} avg Fan out:{}",inputCount,totalTime,totalTime / inputCount,(outputCount / inputCount));
  }
}
