{
  for (; ; ) {
    WatchKey key=null;
    try {
      try {
        key=watchService.take();
      }
 catch (      InterruptedException e) {
        continue;
      }
      Path dir=keys.get(key);
      if (dir == null) {
        LOGGER.error("WatchKey not recognized: {}",key);
        continue;
      }
      for (      WatchEvent<?> event : key.pollEvents()) {
        if (event.kind() == OVERFLOW) {
          LOGGER.info("Received an overflow event");
          for (          Entry<String,ConcurrentMap<File,StarTree>> collectionEntry : trees.entrySet()) {
            for (            Entry<File,StarTree> mapEntry : collectionEntry.getValue().entrySet()) {
              if (!mapEntry.getKey().exists()) {
                collectionEntry.getValue().remove(mapEntry.getKey());
              }
            }
          }
          continue;
        }
        WatchEvent<Path> ev=(WatchEvent<Path>)event;
        Path path=dir.resolve(ev.context());
        File file=path.toFile();
        LOGGER.info("{} {}",ev.kind(),path);
        if (file.getName().startsWith(StorageUtils.getDataDirPrefix()) && ev.kind().equals(ENTRY_DELETE)) {
          for (          Entry<String,ConcurrentMap<File,StarTree>> entry : trees.entrySet()) {
            entry.getValue().get(path.toFile()).close();
            entry.getValue().remove(path.toFile());
          }
        }
 else         if (file.getName().startsWith(StorageUtils.getDataDirPrefix())) {
          StorageUtils.waitForModifications(file,REFRESH_WAIT_SLEEP_MILLIS,REFRESH_WAIT_TIMEOUT_MILLIS);
synchronized (trees) {
            File treeFile=new File(file,StarTreeConstants.TREE_FILE_NAME);
            ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(treeFile));
            StarTreeNode root=(StarTreeNode)inputStream.readObject();
            inputStream.close();
            InputStream indexMetadataFile=new FileInputStream(new File(file,StarTreeConstants.METADATA_FILE_NAME));
            Properties indexMetadataProps=new Properties();
            indexMetadataProps.load(indexMetadataFile);
            indexMetadataFile.close();
            IndexMetadata indexMetadata=IndexMetadata.fromProperties(indexMetadataProps);
            allIndexMetadata.put(root.getId(),indexMetadata);
            Map<File,StarTree> existingTrees=trees.get(config.getCollection());
            if (existingTrees == null) {
              LOGGER.error("There is a watch on collection {} but no open trees!",config.getCollection());
            }
 else {
              StarTree existingTree=existingTrees.get(file);
              if (existingTree != null) {
                existingTree.close();
                LOGGER.info("Closed existing tree {} in {}",existingTree.getRoot().getId(),file);
              }
              try {
                StarTree starTree=new StarTreeImpl(config,file,root);
                starTree.open();
                trees.get(config.getCollection()).put(file,starTree);
                LOGGER.info("Opened tree {} from {}",starTree.getRoot().getId(),file);
              }
 catch (              Exception e) {
                if (LOGGER.isDebugEnabled()) {
                  LOGGER.debug("Error while watching collection directory",e);
                }
              }
            }
          }
        }
      }
    }
 catch (    Exception e) {
      LOGGER.error("Error while watching collection directory",e);
    }
    if (key != null) {
      boolean valid=key.reset();
      if (!valid) {
        keys.remove(key);
        if (keys.isEmpty()) {
          break;
        }
      }
    }
  }
  try {
    watchService.close();
  }
 catch (  IOException e) {
    LOGGER.warn("Failed to close watcher service ",e);
  }
}
