{
  for (; ; ) {
    WatchKey key=null;
    try {
      try {
        key=watchService.take();
      }
 catch (      InterruptedException e) {
        continue;
      }
      Path dir=keys.get(key);
      if (dir == null) {
        LOG.error("WatchKey not recognized: {}",key);
        continue;
      }
      for (      WatchEvent<?> event : key.pollEvents()) {
        if (event.kind() == OVERFLOW) {
          LOG.info("Received a overflow event");
          continue;
        }
        WatchEvent<Path> ev=(WatchEvent<Path>)event;
        Path path=dir.resolve(ev.context());
        File file=path.toFile();
        LOG.info("{} {}",ev.kind(),path);
        if (file.getName().startsWith(StorageUtils.getDataDirPrefix())) {
          StorageUtils.waitForModifications(file,REFRESH_WAIT_SLEEP_MILLIS,REFRESH_WAIT_TIMEOUT_MILLIS);
synchronized (trees) {
            File treeFile=new File(file,StarTreeConstants.TREE_FILE_NAME);
            ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(treeFile));
            StarTreeNode root=(StarTreeNode)inputStream.readObject();
            Map<File,StarTree> existingTrees=trees.get(config.getCollection());
            if (existingTrees == null) {
              LOG.error("There is a watch on collection {} but no open trees!",config.getCollection());
            }
 else {
              StarTree existingTree=existingTrees.get(file);
              if (existingTree != null) {
                existingTree.close();
                LOG.info("Closed existing tree {} in {}",existingTree.getRoot().getId(),file);
              }
              try {
                StarTree starTree=new StarTreeImpl(config,file,root);
                starTree.open();
                trees.get(config.getCollection()).put(file,starTree);
                LOG.info("Opened tree {} from {}",starTree.getRoot().getId(),file);
              }
 catch (              Exception e) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("{}",e);
                }
              }
            }
          }
        }
      }
    }
 catch (    Exception e) {
      LOG.error("{}",e);
    }
    if (key != null) {
      boolean valid=key.reset();
      if (!valid) {
        keys.remove(key);
        if (keys.isEmpty()) {
          break;
        }
      }
    }
  }
  try {
    watchService.close();
  }
 catch (  IOException e) {
    LOG.warn("Failed to close watcher service ",e);
  }
}
