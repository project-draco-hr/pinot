{
  long startMillis;
  long endMillis;
  if (node.getLevel() >= splitOrder.size() || table.size() <= maxLeafRecords) {
    return 0;
  }
  Integer splitDimensionId=splitOrder.get(node.getLevel());
  LOG.info("Splitting on dimension {} at level {} (table.size={})",splitDimensionId,node.getLevel(),table.size());
  int aggregateCombinations=0;
  Iterator<StarTreeTableRow> uniqueItr=table.getUniqueCombinations(Collections.singletonList(splitDimensionId));
  while (uniqueItr.hasNext()) {
    StarTreeTableRow row=uniqueItr.next();
    table.append(row);
    aggregateCombinations++;
  }
  LOG.info("Added {} aggregate combinations at {}",aggregateCombinations,node);
  List<Integer> pathDimensions=node.getPathDimensions();
  pathDimensions.add(splitDimensionId);
  LOG.info("Sorting sub-table at {} by dimensions {}",node,pathDimensions);
  startMillis=System.currentTimeMillis();
  table.sort(pathDimensions);
  endMillis=System.currentTimeMillis();
  LOG.info("Sort of sub-table {} took {} ms",node,endMillis - startMillis);
  node.setChildDimensionName(splitDimensionId);
  node.setChildren(new HashMap<Integer,StarTreeIndexNode>());
  LOG.info("Computing group by stats at {}",node);
  startMillis=System.currentTimeMillis();
  StarTreeTableGroupByStats groupByStats=table.groupBy(splitDimensionId);
  endMillis=System.currentTimeMillis();
  LOG.info("Group by stats computation at {} took {} ms",node,endMillis - startMillis);
  int subTreeAggregateCombinations=0;
  for (  Integer valueId : groupByStats.getValues()) {
    StarTreeIndexNode child=new StarTreeIndexNode();
    child.setDimensionName(splitDimensionId);
    child.setDimensionValue(valueId);
    child.setParent(node);
    child.setLevel(node.getLevel() + 1);
    node.getChildren().put(valueId,child);
    Integer minRecordId=groupByStats.getMinRecordId(valueId) + subTreeAggregateCombinations;
    Integer rawRecordCount=groupByStats.getRawCount(valueId);
    StarTreeTable subTable=table.view(minRecordId,rawRecordCount);
    subTreeAggregateCombinations+=constructStarTree(child,subTable);
  }
  return aggregateCombinations + subTreeAggregateCombinations;
}
