{
  return new BlockDocIdIterator(){
    final PriorityQueue<IntPair> queue=new PriorityQueue<IntPair>(docIdIterators.length,new Pairs.AscendingIntPairComparator());
    final boolean[] iteratorIsInQueue=new boolean[docIdIterators.length];
    int currentDocId=-1;
    @Override public int advance(    int targetDocId){
      if (currentDocId == Constants.EOF) {
        return Constants.EOF;
      }
      if (targetDocId < getMinDocId()) {
        targetDocId=getMinDocId();
      }
 else       if (targetDocId > getMaxDocId()) {
        currentDocId=Constants.EOF;
        return currentDocId;
      }
      long start=System.nanoTime();
      Iterator<IntPair> iterator=queue.iterator();
      while (iterator.hasNext()) {
        IntPair pair=iterator.next();
        if (pair.getA() < targetDocId) {
          iterator.remove();
          iteratorIsInQueue[pair.getB()]=false;
        }
      }
      for (int i=0; i < docIdIterators.length; i++) {
        if (!iteratorIsInQueue[i]) {
          int nextDocId=docIdIterators[i].advance(targetDocId);
          if (nextDocId != Constants.EOF) {
            queue.add(new IntPair(nextDocId,i));
          }
          iteratorIsInQueue[i]=true;
        }
      }
      if (queue.size() > 0) {
        currentDocId=queue.peek().getA();
      }
 else {
        currentDocId=Constants.EOF;
      }
      long end=System.nanoTime();
      timeMeasure.addAndGet(end - start);
      return currentDocId;
    }
    @Override public int next(){
      long start=System.nanoTime();
      if (currentDocId == Constants.EOF) {
        return currentDocId;
      }
      while (queue.size() > 0 && queue.peek().getA() <= currentDocId) {
        IntPair pair=queue.remove();
        iteratorIsInQueue[pair.getB()]=false;
      }
      currentDocId++;
      for (int i=0; i < docIdIterators.length; i++) {
        if (!iteratorIsInQueue[i]) {
          int nextDocId=docIdIterators[i].advance(currentDocId);
          if (nextDocId != Constants.EOF) {
            if (!(nextDocId <= getMaxDocId() && nextDocId >= getMinDocId() && nextDocId >= currentDocId)) {
              throw new RuntimeException("next Doc : " + nextDocId + " should never crossing the range : [ "+ getMinDocId()+ ", "+ getMaxDocId()+ " ]");
            }
            queue.add(new IntPair(nextDocId,i));
          }
          iteratorIsInQueue[i]=true;
        }
      }
      if (queue.size() > 0) {
        currentDocId=queue.peek().getA();
      }
 else {
        currentDocId=Constants.EOF;
      }
      long end=System.nanoTime();
      timeMeasure.addAndGet(end - start);
      return currentDocId;
    }
    @Override public int currentDocId(){
      return currentDocId;
    }
  }
;
}
