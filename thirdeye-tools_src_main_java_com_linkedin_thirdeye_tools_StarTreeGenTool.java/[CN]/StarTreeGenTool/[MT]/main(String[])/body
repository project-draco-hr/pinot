{
  Path inputPath=new Path(args[0]);
  Path configPath=new Path(args[1]);
  String outputDir=args[2];
  Path outputPath=new Path(outputDir);
  SequenceFile.Reader reader=new SequenceFile.Reader(new Configuration(),Reader.file(inputPath));
  System.out.println(reader.getKeyClass());
  System.out.println(reader.getValueClassName());
  WritableComparable<?> key=(WritableComparable<?>)reader.getKeyClass().newInstance();
  Writable val=(Writable)reader.getValueClass().newInstance();
  FileSystem fs=FileSystem.get(new Configuration());
  StarTreeGenerationConfig config=new ObjectMapper().readValue(fs.open(configPath),StarTreeGenerationConfig.class);
  String collectionName=config.getCollectionName();
  String timeColumnName=config.getTimeColumnName();
  List<String> splitOrder=config.getSplitOrder();
  int maxRecordStoreEntries=config.getSplitThreshold();
  List<String> dimensionNames=config.getDimensionNames();
  List<String> metricNames=config.getMetricNames();
  String recordStoreFactoryClass="com.linkedin.thirdeye.impl.StarTreeRecordStoreFactoryCircularBufferImpl";
  Properties recordStoreFactoryConfig=new Properties();
  recordStoreFactoryConfig.setProperty("numTimeBuckets","672");
  System.out.println(outputPath.toUri().toString());
  recordStoreFactoryConfig.setProperty("rootDir","");
  List<MetricSpec> metricSpecs=new ArrayList<MetricSpec>(metricNames.size());
  for (  String metricName : metricNames) {
    metricSpecs.add(new MetricSpec(metricName,MetricType.INT));
  }
  List<DimensionSpec> dimensionSpecs=new ArrayList<DimensionSpec>(dimensionNames.size());
  for (  String dimensionName : dimensionNames) {
    dimensionSpecs.add(new DimensionSpec(dimensionName));
  }
  TimeSpec timeSpec=new TimeSpec(config.getTimeColumnName(),new TimeGranularity(1,TimeUnit.HOURS),new TimeGranularity(1,TimeUnit.HOURS),new TimeGranularity(672,TimeUnit.HOURS));
  StarTreeConfig starTreeConfig=new StarTreeConfig.Builder().setCollection(collectionName).setDimensions(dimensionSpecs).setMetrics(metricSpecs).setTime(timeSpec).setSplit(new SplitSpec(maxRecordStoreEntries,splitOrder)).build();
  System.out.println(starTreeConfig.encode());
  int rowCount=0;
  StarTree starTree=new StarTreeImpl(starTreeConfig);
  Map<String,MetricType> metricTypesMap=Collections.emptyMap();
  Map<String,Number> metricValuesMap=Collections.emptyMap();
  while (reader.next(key,val)) {
    BytesWritable writable=(BytesWritable)key;
    DimensionKey dimensionKey=DimensionKey.fromBytes(writable.getBytes());
    System.out.println(dimensionKey);
    Map<String,String> dimensionValuesMap=new HashMap<String,String>();
    for (int i=0; i < dimensionNames.size(); i++) {
      dimensionValuesMap.put(dimensionNames.get(i),dimensionKey.getDimensionsValues()[i]);
    }
    Long time=0l;
    StarTreeRecord record=new StarTreeRecordImpl(dimensionValuesMap,metricValuesMap,metricTypesMap,time);
    starTree.add(record);
    rowCount=rowCount + 1;
  }
  System.out.println("Number of records added:" + rowCount);
  PrintWriter printWriter=new PrintWriter(System.out);
  StarTreeNode root=starTree.getRoot();
  StarTreeDumperTool tool=new StarTreeDumperTool(root,printWriter);
  tool.print();
  System.out.println("Saving tree at " + outputDir);
  StarTreePersistanceUtil.saveTree(starTree,outputDir);
  new File(outputDir + "/data").mkdirs();
  System.out.println("Saving leaf data at " + outputDir + "/data");
  StarTreePersistanceUtil.saveLeafDimensionData(starTree,outputDir + "/data");
}
