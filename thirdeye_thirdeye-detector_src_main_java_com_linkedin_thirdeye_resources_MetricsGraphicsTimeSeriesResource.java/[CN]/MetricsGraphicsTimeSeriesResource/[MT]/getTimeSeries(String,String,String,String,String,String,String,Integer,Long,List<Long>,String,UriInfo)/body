{
  DateTime startTime=parseDateTime(startTimeISO,timeZone);
  DateTime endTime=parseDateTime(endTimeISO,timeZone);
  Multimap<String,String> fixedValues=extractDimensionValues(uriInfo);
  ThirdEyeMetricFunction metricFunction=getMetricFunction(metric,bucketSize,collection);
  ThirdEyeRequestBuilder requestBuilder=new ThirdEyeRequestBuilder().setCollection(collection).setMetricFunction(metricFunction).setStartTimeInclusive(startTime).setEndTime(endTime).setDimensionValues(fixedValues);
  if (groupBy != null) {
    requestBuilder.setGroupBy(groupBy);
  }
  ThirdEyeRequest request=requestBuilder.build();
  Map<DimensionKey,MetricTimeSeries> res=thirdEyeClient.execute(request);
  Map<DimensionKey,List<Map<String,Object>>> dataByDimensionKey=new HashMap<>(res.size());
  final Map<DimensionKey,Double> totalVolume=new HashMap<>(res.size());
  for (  Map.Entry<DimensionKey,MetricTimeSeries> entry : res.entrySet()) {
    List<Map<String,Object>> series=convertSeries(entry.getKey(),entry.getValue(),metric,totalVolume);
    if (!series.isEmpty()) {
      dataByDimensionKey.put(entry.getKey(),series);
    }
  }
  List<DimensionKey> sortedAndFilteredKeys=new ArrayList<>(dataByDimensionKey.keySet());
  Collections.sort(sortedAndFilteredKeys,new Comparator<DimensionKey>(){
    @Override public int compare(    DimensionKey o1,    DimensionKey o2){
      return (int)(totalVolume.get(o2) - totalVolume.get(o1));
    }
  }
);
  if (topK < sortedAndFilteredKeys.size()) {
    sortedAndFilteredKeys=sortedAndFilteredKeys.subList(0,topK);
  }
  List<String> legend=new ArrayList<>();
  List<List<Map<String,Object>>> data=new ArrayList<>();
  for (  DimensionKey key : sortedAndFilteredKeys) {
    data.add(dataByDimensionKey.get(key));
    List<String> dimensionValues=new ArrayList<>();
    for (    String value : key.getDimensionValues()) {
      if ("*".equals(value)) {
        dimensionValues.add("ALL");
      }
 else {
        dimensionValues.add(String.format("\"%s\"",value));
      }
    }
    legend.add(CSV.join(dimensionValues));
  }
  if (overlay != null) {
    if (groupBy != null) {
      throw new BadRequestException("Cannot specify both overlay and groupBy");
    }
    String overlayUnit=overlay.substring(overlay.length() - 1);
    int overlaySize=Integer.valueOf(overlay.substring(0,overlay.length() - 1));
    DateTime overlayStart;
    DateTime overlayEnd;
    if ("d".equals(overlayUnit)) {
      overlayStart=startTime.minusDays(overlaySize);
      overlayEnd=endTime.minusDays(overlaySize);
    }
 else     if ("w".equals(overlayUnit)) {
      overlayStart=startTime.minusWeeks(overlaySize);
      overlayEnd=endTime.minusWeeks(overlaySize);
    }
 else     if ("m".equals(overlayUnit)) {
      overlayStart=startTime.minusMonths(overlaySize);
      overlayEnd=endTime.minusMonths(overlaySize);
    }
 else     if ("y".equals(overlayUnit)) {
      overlayStart=startTime.minusYears(overlaySize);
      overlayEnd=endTime.minusYears(overlaySize);
    }
 else {
      throw new BadRequestException("Invalid overlay unit " + overlayUnit);
    }
    long shiftMillis=endTime.getMillis() - overlayEnd.getMillis();
    ThirdEyeRequest overlayReq=new ThirdEyeRequestBuilder().setCollection(collection).setMetricFunction(metricFunction).setStartTimeInclusive(overlayStart).setEndTime(overlayEnd).setDimensionValues(fixedValues).build();
    Map<DimensionKey,MetricTimeSeries> overlayRes=thirdEyeClient.execute(overlayReq);
    for (    Map.Entry<DimensionKey,MetricTimeSeries> entry : overlayRes.entrySet()) {
      List<Map<String,Object>> overlaySeries=convertSeries(entry.getKey(),entry.getValue(),metric,null);
      overlaySeries=shiftSeries(overlaySeries,shiftMillis);
      data.add(overlaySeries);
    }
  }
  MetricsGraphicsTimeSeries timeSeries=new MetricsGraphicsTimeSeries();
  timeSeries.setTitle(metric + (groupBy == null || "".equals(groupBy) ? "" : " by " + groupBy));
  timeSeries.setDescription(request.toString());
  timeSeries.setData(data);
  timeSeries.setxAccessor("time");
  timeSeries.setyAccessor("value");
  List<AnomalyResult> anomalies;
  boolean isAnomalyIdsSpecified=(anomalyIds != null && !anomalyIds.isEmpty());
  if (functionId != null && isAnomalyIdsSpecified) {
    throw new BadRequestException("Cannot specify both functionId and anomalyIds");
  }
 else   if (functionId != null) {
    anomalies=resultDAO.findAllByCollectionTimeFunctionIdAndMetric(collection,metric,functionId,startTime,endTime);
  }
 else   if (isAnomalyIdsSpecified) {
    anomalies=new ArrayList<>(anomalyIds.size());
    for (    Long anomalyId : anomalyIds) {
      AnomalyResult anomaly=resultDAO.findById(anomalyId);
      if (anomaly != null) {
        anomalies.add(anomaly);
      }
    }
  }
 else {
    anomalies=resultDAO.findAllByCollectionTimeAndMetric(collection,metric,startTime,endTime);
  }
  StarTreeConfig config=thirdEyeClient.getStarTreeConfig(collection);
  if (groupBy == null) {
    List<AnomalyResult> filtered=new ArrayList<>();
    for (    AnomalyResult anomaly : anomalies) {
      String[] dimensions=anomaly.getDimensions().split(",");
      boolean matches=true;
      for (int i=0; i < config.getDimensions().size(); i++) {
        DimensionSpec spec=config.getDimensions().get(i);
        if (!fixedValues.containsKey(spec.getName()) && !"*".equals(dimensions[i])) {
          matches=false;
          break;
        }
 else         if (fixedValues.containsKey(spec.getName()) && !fixedValues.get(spec.getName()).contains(dimensions[i])) {
          matches=false;
          break;
        }
      }
      if (matches) {
        filtered.add(anomaly);
      }
    }
    anomalies=filtered;
  }
 else {
    int idx=-1;
    for (int i=0; i < config.getDimensions().size(); i++) {
      if (config.getDimensions().get(i).getName().equals(groupBy)) {
        idx=i;
        break;
      }
    }
    Set<String> representedValues=new HashSet<>();
    for (    DimensionKey key : sortedAndFilteredKeys) {
      representedValues.add(key.getDimensionValues()[idx]);
    }
    List<AnomalyResult> filtered=new ArrayList<>();
    for (    AnomalyResult anomaly : anomalies) {
      String[] dimensions=anomaly.getDimensions().split(",");
      if (representedValues.contains(dimensions[idx])) {
        filtered.add(anomaly);
      }
    }
    anomalies=filtered;
  }
  List<Map<String,Object>> markers=new ArrayList<>();
  for (  AnomalyResult anomaly : anomalies) {
    if (anomaly.getEndTimeUtc() == null) {
      if (anomaly.getStartTimeUtc() >= startTime.getMillis() && anomaly.getStartTimeUtc() <= endTime.getMillis()) {
        markers.add(ImmutableMap.of("time",anomaly.getStartTimeUtc(),"label",(Object)anomaly.getId()));
      }
    }
 else {
      if (anomaly.getStartTimeUtc() >= startTime.getMillis() && anomaly.getStartTimeUtc() <= endTime.getMillis()) {
        markers.add(ImmutableMap.of("time",anomaly.getStartTimeUtc(),"label",(Object)("START_" + anomaly.getId())));
      }
      if (anomaly.getEndTimeUtc() >= startTime.getMillis() && anomaly.getEndTimeUtc() <= endTime.getMillis()) {
        markers.add(ImmutableMap.of("time",anomaly.getEndTimeUtc(),"label",(Object)("END_" + anomaly.getId())));
      }
    }
  }
  timeSeries.setMarkers(markers);
  timeSeries.setAnomalyResults(anomalies);
  if (legend.size() > 1) {
    timeSeries.setLegend(legend);
  }
  return timeSeries;
}
