{
  DateTime startTime=parseDateTime(startTimeISO,timeZone);
  DateTime endTime=parseDateTime(endTimeISO,timeZone);
  Multimap<String,String> fixedValues=extractDimensionValues(uriInfo);
  ThirdEyeRequest req=new ThirdEyeRequest().setCollection(collection).setMetricFunction(getMetricFunction(metric,bucketSize)).setStartTime(startTime).setEndTime(endTime).setDimensionValues(fixedValues);
  if (groupBy != null) {
    req.setGroupBy(groupBy);
  }
  Map<DimensionKey,MetricTimeSeries> res=thirdEyeClient.execute(req);
  Map<DimensionKey,List<Map<String,Object>>> dataByDimensionKey=new HashMap<>(res.size());
  final Map<DimensionKey,Double> totalVolume=new HashMap<>(res.size());
  for (  Map.Entry<DimensionKey,MetricTimeSeries> entry : res.entrySet()) {
    MetricTimeSeries timeSeries=entry.getValue();
    List<Long> sortedTimes=new ArrayList<>(timeSeries.getTimeWindowSet());
    Collections.sort(sortedTimes);
    Set<Long> timeSet=new HashSet<>();
    if (sortedTimes.size() > 1) {
      Long minDiff=null;
      for (int i=0; i < sortedTimes.size() - 1; i++) {
        long diff=sortedTimes.get(i + 1) - sortedTimes.get(i);
        if (minDiff == null || diff < minDiff) {
          minDiff=diff;
        }
      }
      for (long time=sortedTimes.get(0); time <= sortedTimes.get(sortedTimes.size() - 1); time+=minDiff) {
        timeSet.add(time);
      }
    }
 else {
      timeSet.addAll(sortedTimes);
    }
    List<Map<String,Object>> series=new ArrayList<>(timeSeries.getTimeWindowSet().size());
    for (    Long time : timeSet) {
      Number value=timeSeries.get(time,metric);
      if (value == null) {
        value=0;
      }
      series.add(ImmutableMap.of("time",time,"value",(Object)value));
      Double volume=totalVolume.get(entry.getKey());
      if (volume == null) {
        volume=0.0;
      }
      totalVolume.put(entry.getKey(),volume + value.doubleValue());
    }
    if (!series.isEmpty()) {
      dataByDimensionKey.put(entry.getKey(),series);
    }
  }
  List<DimensionKey> sortedAndFilteredKeys=new ArrayList<>(dataByDimensionKey.keySet());
  Collections.sort(sortedAndFilteredKeys,new Comparator<DimensionKey>(){
    @Override public int compare(    DimensionKey o1,    DimensionKey o2){
      return (int)(totalVolume.get(o2) - totalVolume.get(o1));
    }
  }
);
  if (topK < sortedAndFilteredKeys.size()) {
    sortedAndFilteredKeys=sortedAndFilteredKeys.subList(0,topK);
  }
  List<String> legend=new ArrayList<>();
  List<List<Map<String,Object>>> data=new ArrayList<>();
  for (  DimensionKey key : sortedAndFilteredKeys) {
    data.add(dataByDimensionKey.get(key));
    List<String> dimensionValues=new ArrayList<>();
    for (    String value : key.getDimensionValues()) {
      if ("*".equals(value)) {
        dimensionValues.add("ALL");
      }
 else {
        dimensionValues.add(String.format("\"%s\"",value));
      }
    }
    legend.add(CSV.join(dimensionValues));
  }
  MetricsGraphicsTimeSeries timeSeries=new MetricsGraphicsTimeSeries();
  timeSeries.setTitle(metric + (groupBy == null || "".equals(groupBy) ? "" : " by " + groupBy));
  timeSeries.setDescription(req.toSql());
  timeSeries.setData(data);
  timeSeries.setxAccessor("time");
  timeSeries.setyAccessor("value");
  List<AnomalyResult> anomalies;
  if (functionId == null) {
    anomalies=resultDAO.findAllByCollectionTimeAndMetric(collection,metric,startTime,endTime);
  }
 else {
    anomalies=resultDAO.findAllByCollectionTimeFunctionIdAndMetric(collection,metric,functionId,startTime,endTime);
  }
  StarTreeConfig config=thirdEyeClient.getStarTreeConfig(collection);
  if (groupBy == null) {
    List<AnomalyResult> filtered=new ArrayList<>();
    for (    AnomalyResult anomaly : anomalies) {
      String[] dimensions=anomaly.getDimensions().split(",");
      boolean matches=true;
      for (int i=0; i < config.getDimensions().size(); i++) {
        DimensionSpec spec=config.getDimensions().get(i);
        if (!fixedValues.containsKey(spec.getName()) && !"*".equals(dimensions[i])) {
          matches=false;
          break;
        }
 else         if (fixedValues.containsKey(spec.getName()) && !fixedValues.get(spec.getName()).contains(dimensions[i])) {
          matches=false;
          break;
        }
      }
      if (matches) {
        filtered.add(anomaly);
      }
    }
    anomalies=filtered;
  }
 else {
    int idx=-1;
    for (int i=0; i < config.getDimensions().size(); i++) {
      if (config.getDimensions().get(i).getName().equals(groupBy)) {
        idx=i;
        break;
      }
    }
    Set<String> representedValues=new HashSet<>();
    for (    DimensionKey key : sortedAndFilteredKeys) {
      representedValues.add(key.getDimensionValues()[idx]);
    }
    List<AnomalyResult> filtered=new ArrayList<>();
    for (    AnomalyResult anomaly : anomalies) {
      String[] dimensions=anomaly.getDimensions().split(",");
      if (representedValues.contains(dimensions[idx])) {
        filtered.add(anomaly);
      }
    }
    anomalies=filtered;
  }
  List<Map<String,Object>> markers=new ArrayList<>();
  for (  AnomalyResult anomaly : anomalies) {
    if (anomaly.getEndTimeUtc() == null) {
      markers.add(ImmutableMap.of("time",anomaly.getStartTimeUtc(),"label",(Object)anomaly.getId()));
    }
 else {
      markers.add(ImmutableMap.of("time",anomaly.getStartTimeUtc(),"label",(Object)("START_" + anomaly.getId())));
      markers.add(ImmutableMap.of("time",anomaly.getEndTimeUtc(),"label",(Object)("END_" + anomaly.getId())));
    }
  }
  timeSeries.setMarkers(markers);
  timeSeries.setAnomalyResults(anomalies);
  if (legend.size() > 1) {
    timeSeries.setLegend(legend);
  }
  return timeSeries;
}
