{
  StarTreeConfig config=configs.get(collection);
  if (config == null) {
    throw new IllegalArgumentException("Cannot build for collection with no config: " + collection);
  }
  final StarTree tree;
synchronized (trees) {
    StarTree previousTree=trees.get(collection);
    if (previousTree == null) {
      previousTree=new StarTreeImpl(config);
      previousTree.open();
      trees.put(collection,previousTree);
    }
    tree=previousTree;
  }
  final BlockingQueue<StarTreeRecord> recordQueue=new ArrayBlockingQueue<StarTreeRecord>(DEFAULT_LOAD_QUEUE_SIZE);
  final AtomicInteger numLoaded=new AtomicInteger(0);
  final int numWorkers=Runtime.getRuntime().availableProcessors();
  final CountDownLatch latch=new CountDownLatch(numWorkers);
  for (int i=0; i < Runtime.getRuntime().availableProcessors(); i++) {
    executorService.submit(new Runnable(){
      @Override public void run(){
        try {
          StarTreeRecord record;
          while (!((record=recordQueue.take()) instanceof StarTreeRecordEndMarker)) {
            tree.add(record);
            int n=numLoaded.incrementAndGet();
            if (n % 5000 == 0) {
              LOG.info(n + " records loaded into " + collection);
            }
          }
          latch.countDown();
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
    }
);
  }
  try {
    for (    StarTreeRecord record : records) {
      recordQueue.put(record);
    }
    for (int i=0; i < Runtime.getRuntime().availableProcessors(); i++) {
      recordQueue.put(new StarTreeRecordEndMarker());
    }
    latch.await();
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}
