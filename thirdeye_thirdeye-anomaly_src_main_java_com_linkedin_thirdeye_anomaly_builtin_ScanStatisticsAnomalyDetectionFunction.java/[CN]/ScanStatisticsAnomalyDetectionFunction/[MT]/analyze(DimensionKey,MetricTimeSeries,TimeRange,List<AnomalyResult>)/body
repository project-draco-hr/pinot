{
  long bucketMillis=bucketUnit.toMillis(bucketSize);
  Pair<long[],double[]> arraysFromSeries=MetricTimeSeriesUtils.toArray(series,metric,bucketMillis,null,Double.NaN);
  long[] timestamps=arraysFromSeries.getFirst();
  double[] observations=arraysFromSeries.getSecond();
  removeMissingValuesByAveragingNeighbors(observations);
  double[] observationsMinusSeasonality=removeSeasonality(timestamps,observations,seasonal);
  int effectiveMaxWindowLength=(int)(detectionInterval.totalBuckets() / bucketMillis);
  effectiveMaxWindowLength=Math.min(effectiveMaxWindowLength,maxWindowLength);
  ScanStatistics scanStatistics=new ScanStatistics(numSimulation,minWindowLength,effectiveMaxWindowLength,pValueThreshold,pattern,minIncrement,bootstrap);
  int numBucketsToScan=(int)((detectionInterval.getEnd() - detectionInterval.getStart()) / bucketMillis);
  int totalNumBuckets=observationsMinusSeasonality.length;
  int numTrain=totalNumBuckets - numBucketsToScan;
  Set<Long> anomalousTimestamps=new HashSet<Long>();
  for (  AnomalyResult ar : anomalyHistory) {
    anomalousTimestamps.add(ar.getTimeWindow());
  }
  double[] trainingData=Arrays.copyOfRange(observationsMinusSeasonality,0,numTrain);
  long[] trainingTimestamps=Arrays.copyOfRange(timestamps,0,numTrain);
  double[] trainingDataWithOutAnomalies=removeAnomalies(trainingTimestamps,trainingData,anomalousTimestamps);
  double[] monitoringData=Arrays.copyOfRange(observationsMinusSeasonality,numTrain,observationsMinusSeasonality.length);
  long[] monitoringTimestamps=Arrays.copyOfRange(timestamps,numTrain,observationsMinusSeasonality.length);
  LOGGER.info("detecting anomalies using scan statistics");
  long startTime=System.nanoTime();
  Range<Integer> anomalousInterval=scanStatistics.getInterval(trainingDataWithOutAnomalies,monitoringData);
  LOGGER.info("scan statistics took {} seconds",TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime));
  LOGGER.info("found interval : {}",anomalousInterval);
  List<AnomalyResult> anomalyResults=new ArrayList<AnomalyResult>();
  if (anomalousInterval != null) {
    for (int i=anomalousInterval.lowerEndpoint(); i < anomalousInterval.upperEndpoint(); i++) {
      ResultProperties properties=new ResultProperties();
      properties.setProperty("anomalyStart",new DateTime(monitoringTimestamps[anomalousInterval.lowerEndpoint()]).toString());
      properties.setProperty("anomalyEnd",new DateTime(monitoringTimestamps[anomalousInterval.upperEndpoint()]).toString());
      anomalyResults.add(new AnomalyResult(true,monitoringTimestamps[i],pValueThreshold,observations[i],properties));
    }
  }
  return anomalyResults;
}
