{
  Predicate predicate=getPredicate();
  final SortedInvertedIndexReader invertedIndex=(SortedInvertedIndexReader)dataSource.getInvertedIndex();
  Dictionary dictionary=dataSource.getDictionary();
  DataSourceMetadata dataSourceMetadata=dataSource.getDataSourceMetadata();
  List<Pair<Integer,Integer>> pairs=new ArrayList<Pair<Integer,Integer>>();
switch (predicate.getType()) {
case EQ:
    final int valueToLookUP=dictionary.indexOf(((EqPredicate)predicate).getEqualsValue());
  if (valueToLookUP >= 0) {
    int[] minMax=invertedIndex.getMinMaxRangeFor(valueToLookUP);
    pairs.add(ImmutablePair.of(minMax[0],minMax[1]));
  }
break;
case NEQ:
final int neq=dictionary.indexOf(((NEqPredicate)predicate).getNotEqualsValue());
for (int i=0; i < dictionary.length(); i++) {
if (i != neq) {
int[] minMax=invertedIndex.getMinMaxRangeFor(i);
pairs.add(ImmutablePair.of(minMax[0],minMax[1]));
}
}
break;
case IN:
final String[] inValues=((InPredicate)predicate).getInRange();
for (final String value : inValues) {
final int index=dictionary.indexOf(value);
if (index >= 0) {
int[] minMax=invertedIndex.getMinMaxRangeFor(index);
pairs.add(ImmutablePair.of(minMax[0],minMax[1]));
}
}
break;
case NOT_IN:
final String[] notInValues=((NotInPredicate)predicate).getNotInRange();
final List<Integer> notInIds=new ArrayList<Integer>();
for (final String notInValue : notInValues) {
notInIds.add(new Integer(dictionary.indexOf(notInValue)));
}
final MutableRoaringBitmap notINHolder=new MutableRoaringBitmap();
for (int i=0; i < dictionary.length(); i++) {
if (!notInIds.contains(new Integer(i))) {
int[] minMax=invertedIndex.getMinMaxRangeFor(i);
pairs.add(ImmutablePair.of(minMax[0],minMax[1]));
}
}
break;
case RANGE:
int rangeStartIndex=0;
int rangeEndIndex=0;
final boolean incLower=((RangePredicate)predicate).includeLowerBoundary();
final boolean incUpper=((RangePredicate)predicate).includeUpperBoundary();
final String lower=((RangePredicate)predicate).getLowerBoundary();
final String upper=((RangePredicate)predicate).getUpperBoundary();
if (lower.equals("*")) {
rangeStartIndex=0;
}
 else {
rangeStartIndex=dictionary.indexOf(lower);
}
if (upper.equals("*")) {
rangeEndIndex=dictionary.length() - 1;
}
 else {
rangeEndIndex=dictionary.indexOf(upper);
}
if (rangeStartIndex < 0) {
rangeStartIndex=-(rangeStartIndex + 1);
}
 else if (!incLower && !lower.equals("*")) {
rangeStartIndex+=1;
}
if (rangeEndIndex < 0) {
rangeEndIndex=-(rangeEndIndex + 1);
rangeEndIndex=Math.max(0,rangeEndIndex - 1);
}
 else if (!incUpper && !upper.equals("*")) {
rangeEndIndex-=1;
}
for (int i=rangeStartIndex; i <= rangeEndIndex; i++) {
int[] minMax=invertedIndex.getMinMaxRangeFor(i);
pairs.add(ImmutablePair.of(minMax[0],minMax[1]));
}
break;
case REGEX:
throw new UnsupportedOperationException("Regex not supported");
}
sortedBlock=new SortedBlock(pairs);
return sortedBlock;
}
