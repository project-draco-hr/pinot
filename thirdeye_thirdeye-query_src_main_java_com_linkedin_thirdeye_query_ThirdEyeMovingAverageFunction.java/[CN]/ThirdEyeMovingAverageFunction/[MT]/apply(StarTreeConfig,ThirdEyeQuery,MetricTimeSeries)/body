{
  List<MetricType> metricTypes=new ArrayList<>(metricNames.size());
  for (  String metricName : metricNames) {
    metricTypes.add(MetricType.DOUBLE);
  }
  MetricTimeSeries movingAverage=new MetricTimeSeries(new MetricSchema(metricNames,metricTypes));
  if (timeSeries.getTimeWindowSet().isEmpty()) {
    return movingAverage;
  }
  Long minTime=Collections.min(timeSeries.getTimeWindowSet());
  Long maxTime=Collections.max(timeSeries.getTimeWindowSet());
  long collectionWindow=config.getTime().getBucket().getUnit().convert(window.getSize(),window.getUnit()) / config.getTime().getBucket().getSize();
  Long startTime=minTime + collectionWindow;
  Number[] currentSum=new Number[timeSeries.getSchema().getNumMetrics()];
  Arrays.fill(currentSum,0);
  for (long time=minTime; time <= maxTime; time++) {
    for (int j=0; j < movingAverage.getSchema().getNumMetrics(); j++) {
      String metricName=movingAverage.getSchema().getMetricName(j);
      MetricType metricType=movingAverage.getSchema().getMetricType(j);
      Number newValue=timeSeries.get(time,metricName);
      currentSum[j]=NumberUtils.sum(currentSum[j],newValue.doubleValue() / collectionWindow,metricType);
      if (time >= startTime) {
        Number oldValue=timeSeries.get(time - collectionWindow,metricName);
        currentSum[j]=NumberUtils.difference(currentSum[j],oldValue.doubleValue() / collectionWindow,metricType);
        movingAverage.increment(time,metricName,currentSum[j]);
      }
    }
  }
  return movingAverage;
}
