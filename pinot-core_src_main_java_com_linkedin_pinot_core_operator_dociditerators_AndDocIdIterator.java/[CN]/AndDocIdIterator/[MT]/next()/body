{
  long start=System.currentTimeMillis();
  if (currentDocId == Constants.EOF) {
    return currentDocId;
  }
  currentMax=currentMax + 1;
  long childStart, childEnd;
  for (int i=0; i < docIdIterators.length; i++) {
    childStart=System.currentTimeMillis();
    docIdPointers[i]=docIdIterators[i].advance(currentMax);
    childEnd=System.currentTimeMillis();
    timeMeasures[i].addAndGet((childEnd - childStart));
    if (docIdPointers[i] == Constants.EOF) {
      reachedEnd=true;
      currentMax=Constants.EOF;
      break;
    }
    if (docIdPointers[i] > currentMax) {
      currentMax=docIdPointers[i];
      if (i > 0) {
        i=-1;
      }
    }
 else     if (docIdPointers[i] < currentMax) {
      LOGGER.warn("Should never happen, {} returns docIdPointer : {} should always >= currentMax : {}",docIdIterators[i],docIdPointers[i],currentMax);
      throw new IllegalStateException("Should never happen, docIdPointer should always >= currentMax");
    }
  }
  currentDocId=currentMax;
  long end=System.currentTimeMillis();
  timeMeasure.addAndGet(end - start);
  if (currentDocId == Constants.EOF) {
    LOGGER.info("AND operator took:{}. Break down by child iterators:{} times:{}",timeMeasure.get(),Arrays.toString(docIdIterators),Arrays.toString(timeMeasures));
  }
  return currentDocId;
}
