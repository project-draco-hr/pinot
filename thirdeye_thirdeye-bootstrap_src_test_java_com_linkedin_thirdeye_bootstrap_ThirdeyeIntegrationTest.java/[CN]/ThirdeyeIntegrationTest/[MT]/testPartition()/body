{
  LOGGER.info("Starting startree_generation job");
  Job job=Job.getInstance(conf);
  job.setJobName("Partition");
  job.setJarByClass(PartitionPhaseJob.class);
  job.setMapperClass(PartitionMapper.class);
  job.setInputFormatClass(SequenceFileInputFormat.class);
  job.setMapOutputKeyClass(BytesWritable.class);
  job.setMapOutputValueClass(BytesWritable.class);
  job.setNumReduceTasks(0);
  job.setOutputKeyClass(BytesWritable.class);
  job.setOutputValueClass(BytesWritable.class);
  job.setOutputFormatClass(SequenceFileOutputFormat.class);
  int numPartitions=5;
  Configuration configuration=job.getConfiguration();
  configuration.set(PARTITION_PHASE_INPUT_PATH.toString(),rollupPhase4OutputPath.toString());
  configuration.set(PARTITION_PHASE_CONFIG_PATH.toString(),configFilePath.toString());
  configuration.set(PARTITION_PHASE_OUTPUT_PATH.toString(),partitionOutputPath.toString());
  configuration.set(PARTITION_PHASE_NUM_PARTITIONS.toString(),"5");
  FileInputFormat.addInputPath(job,new Path(configuration.get(PARTITION_PHASE_INPUT_PATH.toString())));
  for (int i=0; i < numPartitions; i++) {
    MultipleOutputs.addNamedOutput(job,"partition" + i,SequenceFileOutputFormat.class,BytesWritable.class,BytesWritable.class);
  }
  FileOutputFormat.setOutputPath(job,new Path(configuration.get(PARTITION_PHASE_OUTPUT_PATH.toString())));
  job.waitForCompletion(true);
  assertTrue("partition job failed",job.isSuccessful());
  assertTrue("partition folder not created",fs.exists(partitionOutputPath));
  for (int i=0; i < numPartitions; i++) {
    Path partition=new Path(partitionOutputPath,"partition" + i);
    assertTrue("partition folder " + i + "not created",fs.exists(partition));
    FileStatus[] partitionStatus=fs.listStatus(partition,new PathFilter(){
      @Override public boolean accept(      Path path){
        return path.getName().startsWith("part");
      }
    }
);
    assertTrue("partition " + i + " data not generated",partitionStatus.length != 0);
  }
  LOGGER.info("partition job completed");
}
