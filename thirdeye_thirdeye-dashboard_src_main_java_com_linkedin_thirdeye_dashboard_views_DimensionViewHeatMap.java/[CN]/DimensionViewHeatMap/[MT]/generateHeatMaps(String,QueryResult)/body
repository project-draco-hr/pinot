{
  int dimensionIdx=queryResult.getDimensions().indexOf(dimension);
  if (queryResult.getData().isEmpty()) {
    return Collections.emptyList();
  }
  Map<String,String> metricAliases=new HashMap<>();
  for (int i=0; i < schema.getMetrics().size(); i++) {
    metricAliases.put(schema.getMetrics().get(i),schema.getMetricAliases().get(i));
  }
  Map<String,String> dimensionAliases=new HashMap<>();
  for (int i=0; i < schema.getDimensions().size(); i++) {
    dimensionAliases.put(schema.getDimensions().get(i),schema.getDimensionAliases().get(i));
  }
  Map<String,Set<String>> snapshotValues=new HashMap<>();
  for (  String metricName : queryResult.getMetrics()) {
    snapshotValues.put(metricName,new HashSet<String>());
  }
  Map<String,List<HeatMapCell>> allCells=new HashMap<>();
  Map<String,DescriptiveStatistics> allBaselineStats=new HashMap<>();
  Map<String,DescriptiveStatistics> allCurrentStats=new HashMap<>();
  for (int i=0; i < queryResult.getMetrics().size(); i++) {
    String metric=queryResult.getMetrics().get(i);
    allCells.put(metric,new ArrayList<HeatMapCell>());
    allBaselineStats.put(metric,new DescriptiveStatistics());
    allCurrentStats.put(metric,new DescriptiveStatistics());
  }
  Map<List<String>,Map<String,Number[]>> processedResult=ViewUtils.processDimensionGroups(queryResult,objectMapper,dimensionGroupMap,dimensionRegexMap,dimension);
  for (  Map.Entry<List<String>,Map<String,Number[]>> entry : processedResult.entrySet()) {
    List<String> combination=entry.getKey();
    String value=combination.get(dimensionIdx);
    long minTime=-1;
    long maxTime=-1;
    for (    String timeString : entry.getValue().keySet()) {
      long time=Long.valueOf(timeString);
      if (minTime == -1 || time < minTime) {
        minTime=time;
      }
      if (maxTime == -1 || time > maxTime) {
        maxTime=time;
      }
    }
    for (int i=0; i < queryResult.getMetrics().size(); i++) {
      String metric=queryResult.getMetrics().get(i);
      Number baselineValue=getMetricValue(entry.getValue().get(String.valueOf(minTime)),i);
      Number currentValue=getMetricValue(entry.getValue().get(String.valueOf(maxTime)),i);
      if (baselineValue == null) {
        baselineValue=new Double(0);
      }
      if (currentValue == null) {
        currentValue=new Double(0);
      }
      allBaselineStats.get(metric).addValue(baselineValue.doubleValue());
      allCurrentStats.get(metric).addValue(currentValue.doubleValue());
      HeatMapCell cell=new HeatMapCell(objectMapper,value);
      cell.addStat(Stat.BASELINE_VALUE,baselineValue);
      cell.addStat(Stat.CURRENT_VALUE,currentValue);
      allCells.get(metric).add(cell);
    }
  }
  List<HeatMap> heatMaps=new ArrayList<>();
  for (  Map.Entry<String,List<HeatMapCell>> entry : allCells.entrySet()) {
    String metric=entry.getKey();
    DescriptiveStatistics baselineStats=allBaselineStats.get(metric);
    DescriptiveStatistics currentStats=allCurrentStats.get(metric);
    NormalDistribution baselineDist=getDistribution(baselineStats);
    NormalDistribution currentDist=getDistribution(currentStats);
    List<HeatMapCell> cells=entry.getValue();
    Collections.sort(cells,new Comparator<HeatMapCell>(){
      @Override public int compare(      HeatMapCell o1,      HeatMapCell o2){
        Number number1=o1.getStats().get(1);
        Number number2=o2.getStats().get(1);
        double val1=(number1 == null) ? 0 : number1.doubleValue();
        double val2=(number2 == null) ? 0 : number2.doubleValue();
        return NumberUtils.compare(val2,val1);
      }
    }
);
    for (    HeatMapCell cell : cells) {
      Number baseline=cell.getStats().get(0);
      Number current=cell.getStats().get(1);
      double currentValue=current == null ? 0 : current.doubleValue();
      double baselineValue=baseline == null ? 0 : baseline.doubleValue();
      if (baseline == null || baselineDist == null) {
        cell.addStat(Stat.BASELINE_CDF_VALUE,null);
      }
 else {
        cell.addStat(Stat.BASELINE_CDF_VALUE,baselineDist.cumulativeProbability(baseline.doubleValue()));
      }
      if (current == null || currentDist == null) {
        cell.addStat(Stat.CURRENT_CDF_VALUE,null);
      }
 else {
        cell.addStat(Stat.CURRENT_CDF_VALUE,currentDist.cumulativeProbability(current.doubleValue()));
      }
      if (Double.isNaN(baselineStats.getSum())) {
        cell.addStat(Stat.BASELINE_TOTAL,null);
      }
 else {
        cell.addStat(Stat.BASELINE_TOTAL,baselineStats.getSum());
      }
      if (Double.isNaN(baselineStats.getSum())) {
        cell.addStat(Stat.CURRENT_TOTAL,null);
      }
 else {
        cell.addStat(Stat.CURRENT_TOTAL,currentStats.getSum());
      }
      if (baselineStats.getSum() > 0) {
        double baselineRatio=baseline == null ? 0 : baseline.doubleValue() / baselineStats.getSum();
        cell.addStat(Stat.BASELINE_RATIO,baselineRatio);
      }
 else {
        cell.addStat(Stat.BASELINE_RATIO,null);
      }
      if (currentStats.getSum() > 0) {
        double currentRatio=current == null ? 0 : current.doubleValue() / currentStats.getSum();
        cell.addStat(Stat.CURRENT_RATIO,currentRatio);
      }
 else {
        cell.addStat(Stat.CURRENT_RATIO,null);
      }
      if (baselineStats.getSum() > 0 && currentStats.getSum() > 0) {
        double currentContribution=current == null ? 0 : current.doubleValue() / currentStats.getSum();
        double baselineContribution=baseline == null ? 0 : baseline.doubleValue() / baselineStats.getSum();
        cell.addStat(Stat.CONTRIBUTION_DIFFERENCE,currentContribution - baselineContribution);
      }
 else {
        cell.addStat(Stat.CONTRIBUTION_DIFFERENCE,null);
      }
      if (baselineStats.getSum() > 0) {
        cell.addStat(Stat.VOLUME_DIFFERENCE,(currentValue - baselineValue) / baselineStats.getSum());
      }
 else {
        cell.addStat(Stat.VOLUME_DIFFERENCE,null);
      }
      if (baselineValue > 0) {
        cell.addStat(Stat.DELTA_PERCENT_CHANGE,(currentValue - baselineValue) / baselineValue);
      }
 else {
        cell.addStat(Stat.DELTA_PERCENT_CHANGE,0);
      }
      if (snapshotValues.get(metric).contains(cell.getValue())) {
        cell.addStat(Stat.SNAPSHOT_CATEGORY,1);
      }
 else {
        cell.addStat(Stat.SNAPSHOT_CATEGORY,0);
      }
    }
    heatMaps.add(new HeatMap(objectMapper,entry.getKey(),metricAliases.get(entry.getKey()),dimension,dimensionAliases.get(dimension),cells,Arrays.asList(Stat.BASELINE_VALUE.toString(),Stat.CURRENT_VALUE.toString(),Stat.BASELINE_CDF_VALUE.toString(),Stat.CURRENT_CDF_VALUE.toString(),Stat.BASELINE_TOTAL.toString(),Stat.CURRENT_TOTAL.toString(),Stat.BASELINE_RATIO.toString(),Stat.CURRENT_RATIO.toString(),Stat.CONTRIBUTION_DIFFERENCE.toString(),Stat.VOLUME_DIFFERENCE.toString(),Stat.SNAPSHOT_CATEGORY.toString(),Stat.DELTA_PERCENT_CHANGE.toString())));
  }
  for (  String metric : queryResult.getMetrics()) {
    Map<String,Number> map=new HashMap<String,Number>();
    double baselineTotal=allBaselineStats.get(metric).getSum();
    double currentTotal=allCurrentStats.get(metric).getSum();
    map.put(Stat.BASELINE_TOTAL.toString(),baselineTotal);
    map.put(Stat.CURRENT_TOTAL.toString(),currentTotal);
    double delta=currentTotal - baselineTotal;
    map.put(Stat.DELTA_ABSOLUTE_CHANGE.toString(),delta);
    if (baselineTotal > 0) {
      map.put(Stat.DELTA_PERCENT_CHANGE.toString(),(delta / baselineTotal) * 100.0);
    }
    metricGlobalStats.put(metric,map);
  }
  return heatMaps;
}
