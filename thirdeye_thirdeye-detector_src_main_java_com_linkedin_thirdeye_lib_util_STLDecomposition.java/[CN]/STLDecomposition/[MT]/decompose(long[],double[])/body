{
  double[] trend=new double[series.length];
  double[] seasonal=new double[series.length];
  double[] remainder=new double[series.length];
  double[] robustness=null;
  for (int l=0; l < config.getNumberOfRobustnessIterations(); l++) {
    for (int k=0; k < config.getNumberOfInnerLoopPasses(); k++) {
      double[] detrend=new double[series.length];
      for (int i=0; i < series.length; i++) {
        detrend[i]=series[i] - trend[i];
      }
      int numberOfObservations=config.getNumberOfObservations();
      CycleSubSeries cycle=new CycleSubSeries(times,series,robustness,detrend,numberOfObservations);
      cycle.compute();
      List<double[]> cycleSubseries=cycle.getCycleSubSeries();
      List<double[]> cycleTimes=cycle.getCycleTimes();
      List<double[]> cycleRobustnessWeights=cycle.getCycleRobustnessWeights();
      for (int i=0; i < cycleSubseries.size(); i++) {
        double[] smoothed=loessSmooth(cycleTimes.get(i),cycleSubseries.get(i),config.getSeasonalComponentBandwidth(),cycleRobustnessWeights.get(i));
        cycleSubseries.set(i,smoothed);
      }
      double[] combinedSmoothed=new double[series.length];
      for (int i=0; i < cycleSubseries.size(); i++) {
        double[] subseriesValues=cycleSubseries.get(i);
        for (int cycleIdx=0; cycleIdx < subseriesValues.length; cycleIdx++) {
          combinedSmoothed[numberOfObservations * cycleIdx + i]=subseriesValues[cycleIdx];
        }
      }
      double[] filtered=lowPassFilter(combinedSmoothed,robustness);
      for (int i=0; i < seasonal.length; i++) {
        seasonal[i]=combinedSmoothed[i] - filtered[i];
      }
      for (int i=0; i < series.length; i++) {
        trend[i]=series[i] - seasonal[i];
      }
      trend=loessSmooth(trend,config.getTrendComponentBandwidth(),robustness);
    }
    for (int i=0; i < series.length; i++) {
      remainder[i]=series[i] - trend[i] - seasonal[i];
    }
    robustness=robustnessWeights(remainder);
  }
  return new STLResult(times,series,trend,seasonal,remainder);
}
