{
  if (!isStarted.getAndSet(true)) {
    LOG.info("Constructing decoder {}",kafkaConfig.getDecoderClass());
    Class<?> decoderClass=Class.forName(kafkaConfig.getDecoderClass());
    ThirdEyeKafkaDecoder decoder=(ThirdEyeKafkaDecoder)decoderClass.getConstructor().newInstance();
    decoder.init(starTree.getConfig(),kafkaConfig);
    Properties props=new Properties();
    props.put("zookeeper.connect",kafkaConfig.getZkAddress());
    props.put("group.id",kafkaConfig.getGroupId());
    props.put("auto.commit.enable","false");
    props.put("auto.offset.reset","smallest");
    kafka.consumer.ConsumerConfig consumerConfig=new ConsumerConfig(props);
    ConsumerConnector consumer=Consumer.createJavaConsumerConnector(consumerConfig);
    LOG.info("Configuring kafka with {}",props);
    LOG.info("Creating Kafka message streams");
    Map<String,Integer> topicMap=Collections.singletonMap(kafkaConfig.getTopicName(),1);
    Map<String,List<KafkaStream<byte[],byte[]>>> streams=consumer.createMessageStreams(topicMap);
    if (streams.size() != 1) {
      throw new IllegalStateException("Can only consume one stream for " + kafkaConfig.getTopicName());
    }
    List<KafkaStream<byte[],byte[]>> topicStreams=streams.values().iterator().next();
    if (topicStreams.size() != 1) {
      throw new IllegalStateException("Can only consume one stream for " + kafkaConfig.getTopicName());
    }
    KafkaStream<byte[],byte[]> stream=topicStreams.get(0);
    LOG.info("Starting event iterator for topic {}",kafkaConfig.getTopicName());
    EventIterator eventIterator=new EventIterator(starTree,decoder,stream);
    consumerExecutors.submit(eventIterator);
    persistTask.set(new PersistTask(consumer,starTree));
    TimeGranularity interval=kafkaConfig.getPersistInterval();
    LOG.info("Scheduling persist task at {}",interval);
    taskScheduler.scheduleAtFixedRate(persistTask.get(),interval.getSize(),interval.getSize(),interval.getUnit());
  }
}
