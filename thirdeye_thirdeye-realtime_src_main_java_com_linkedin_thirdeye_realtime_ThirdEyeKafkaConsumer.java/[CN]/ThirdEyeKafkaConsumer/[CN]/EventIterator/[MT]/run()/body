{
  ConsumerIterator<byte[],byte[]> itr=stream.iterator();
  while (isStarted.get() && itr.hasNext()) {
    try {
      MessageAndMetadata<byte[],byte[]> next=itr.next();
      long currentTime=System.currentTimeMillis();
      stats.getBytesRead().mark(next.message().length);
      stats.getLastConsumedRecordTimeMillis().set(currentTime);
      StarTreeRecord record=decoder.decode(next.message());
      if (record == null) {
        stats.getRecordsSkippedInvalid().mark();
        continue;
      }
      long minTimeMillis=getMinCollectionTimeMillis(record.getMetricTimeSeries());
      if (minTimeMillis < kafkaConfig.getStartTime().getMillis()) {
        stats.getRecordsSkippedExpired().mark();
        continue;
      }
      lock.readLock().lock();
      try {
        starTree.add(record);
        stats.getRecordsAdded().mark();
      }
  finally {
        lock.readLock().unlock();
      }
      if (!record.getMetricTimeSeries().getTimeWindowSet().isEmpty()) {
        long maxTimeMillis=getMaxCollectionTimeMillis(record.getMetricTimeSeries());
        if (maxTimeMillis > stats.getDataTimeMillis().get()) {
          stats.getDataTimeMillis().set(maxTimeMillis);
        }
      }
    }
 catch (    Exception e) {
      String collection=starTree.getConfig().getCollection();
      LOG.error("Error consuming message from kafka for {}",collection,e);
    }
  }
}
