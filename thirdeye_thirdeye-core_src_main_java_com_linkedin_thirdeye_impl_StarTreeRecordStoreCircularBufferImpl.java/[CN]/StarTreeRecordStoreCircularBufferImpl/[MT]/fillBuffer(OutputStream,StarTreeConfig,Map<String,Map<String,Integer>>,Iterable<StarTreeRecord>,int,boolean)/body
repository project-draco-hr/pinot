{
  final List<DimensionSpec> dimensionSpecs=config.getDimensions();
  final List<MetricSpec> metricSpecs=config.getMetrics();
  DataOutputStream dataOutputStream=new DataOutputStream(outputStream);
  Map<DimensionKey,StarTreeRecord> groups=new HashMap<DimensionKey,StarTreeRecord>();
  for (  StarTreeRecord record : records) {
    StarTreeRecord group=groups.get(record.getDimensionKey());
    if (group == null) {
      group=new StarTreeRecordImpl(config,record.getDimensionKey(),new MetricTimeSeries(MetricSchema.fromMetricSpecs(config.getMetrics())));
      groups.put(record.getDimensionKey(),group);
    }
    group.getMetricTimeSeries().aggregate(record.getMetricTimeSeries());
  }
  List<DimensionKey> orderedCombinations=new ArrayList<DimensionKey>(groups.keySet());
  Collections.sort(orderedCombinations,new Comparator<DimensionKey>(){
    @Override public int compare(    DimensionKey o1,    DimensionKey o2){
      for (int i=0; i < dimensionSpecs.size(); i++) {
        String v1=o1.getDimensionValues()[i];
        String v2=o2.getDimensionValues()[i];
        int i1=forwardIndex.get(dimensionSpecs.get(i).getName()).get(v1);
        int i2=forwardIndex.get(dimensionSpecs.get(i).getName()).get(v2);
        if (i1 != i2) {
          return i1 - i2;
        }
      }
      return 0;
    }
  }
);
  for (  DimensionKey combination : orderedCombinations) {
    StarTreeRecord record=groups.get(combination);
    Long minTime=Collections.min(record.getMetricTimeSeries().getTimeWindowSet());
    Long maxTime=Collections.max(record.getMetricTimeSeries().getTimeWindowSet());
    Set<Long> representedTimes=new HashSet<Long>(record.getMetricTimeSeries().getTimeWindowSet());
    Map<Integer,Long> bucketToTime=new HashMap<Integer,Long>();
    for (long i=minTime; i <= maxTime; i++) {
      if (!representedTimes.contains(i)) {
        for (        MetricSpec metricSpec : metricSpecs) {
          record.getMetricTimeSeries().set(i,metricSpec.getName(),0);
        }
      }
      bucketToTime.put((int)i % numTimeBuckets,i);
    }
    for (int i=0; i < dimensionSpecs.size(); i++) {
      String dimensionValue=combination.getDimensionValues()[i];
      Integer valueId=forwardIndex.get(dimensionSpecs.get(i).getName()).get(dimensionValue);
      if (valueId == null) {
        throw new IllegalStateException("No ID for dimension value " + dimensionSpecs.get(i).getName() + ":"+ dimensionValue);
      }
      dataOutputStream.writeInt(valueId);
    }
    for (long i=0; i < numTimeBuckets; i++) {
      Long time=bucketToTime.get(i);
      if (time == null) {
        time=i;
      }
      dataOutputStream.writeLong(time);
      for (int j=0; j < metricSpecs.size(); j++) {
        String metricName=metricSpecs.get(j).getName();
        if (keepMetricValues) {
          Number val=record.getMetricTimeSeries().get(time,metricName);
          NumberUtils.addToDataOutputStream(dataOutputStream,val,metricSpecs.get(j).getType());
        }
 else {
          NumberUtils.addToDataOutputStream(dataOutputStream,0,metricSpecs.get(j).getType());
        }
      }
    }
  }
}
