{
  Map<List<String>,Map<String,Number[]>> processedResult=new HashMap<>(queryResult.getData().size());
  for (  Map.Entry<String,Map<String,Number[]>> entry : queryResult.getData().entrySet()) {
    List<String> combination=objectMapper.readValue(entry.getKey(),LIST_TYPE_REFERENCE);
    Integer dimensionIdx=queryResult.getDimensions().indexOf(dimensionName);
    String value=combination.get(dimensionIdx);
    boolean appliedExplicitMapping=false;
    if (dimensionGroupMap != null) {
      Map<String,String> mapping=dimensionGroupMap.get(dimensionName);
      if (mapping != null) {
        String groupValue=mapping.get(value);
        if (groupValue != null) {
          combination.set(dimensionIdx,groupValue);
          appliedExplicitMapping=true;
        }
      }
    }
    if (!appliedExplicitMapping && dimensionRegexMap != null) {
      Map<Pattern,String> patterns=dimensionRegexMap.get(dimensionName);
      if (patterns != null) {
        int matches=0;
        for (        Map.Entry<Pattern,String> pattern : patterns.entrySet()) {
          if (pattern.getKey().matcher(value).find()) {
            matches++;
            combination.set(dimensionIdx,pattern.getValue());
          }
        }
        if (matches > 1) {
          LOGGER.warn("Multiple regexes match {}! {}",value,patterns);
        }
      }
    }
    Map<String,Number[]> existing=processedResult.get(combination);
    if (existing == null) {
      processedResult.put(combination,entry.getValue());
    }
 else {
      for (      Map.Entry<String,Number[]> point : entry.getValue().entrySet()) {
        Number[] existingValues=existing.get(point.getKey());
        if (existingValues == null) {
          existingValues=new Number[point.getValue().length];
          Arrays.fill(existingValues,0);
          existing.put(point.getKey(),existingValues);
        }
        Number[] incrementValues=point.getValue();
        for (int i=0; i < existingValues.length; i++) {
          existingValues[i]=existingValues[i].doubleValue() + incrementValues[i].doubleValue();
        }
      }
    }
  }
  return processedResult;
}
