{
  final List<Integer> includedDimensions=new ArrayList<>();
  for (int i=0; i < dimensionTypes.size(); i++) {
    if (excludedDimensions == null || !excludedDimensions.contains(i)) {
      includedDimensions.add(i);
    }
  }
  final Comparator<StarTreeTableRow> includedComparator=new Comparator<StarTreeTableRow>(){
    @Override public int compare(    StarTreeTableRow o1,    StarTreeTableRow o2){
      for (      Integer dimension : includedDimensions) {
        Integer v1=o1.getDimensions().get(dimension);
        Integer v2=o2.getDimensions().get(dimension);
        if (!v1.equals(v2)) {
          return v1 - v2;
        }
      }
      return 0;
    }
  }
;
  final List<ByteBuffer> listCopy=new LinkedList<>(list);
  Collections.sort(listCopy,new Comparator<ByteBuffer>(){
    @Override public int compare(    ByteBuffer o1,    ByteBuffer o2){
      for (      Integer dimension : includedDimensions) {
        o1.position(dimension * Integer.SIZE / 8);
        o2.position(dimension * Integer.SIZE / 8);
        Integer v1=o1.getInt();
        Integer v2=o2.getInt();
        if (!v1.equals(v2)) {
          return v1 - v2;
        }
      }
      return 0;
    }
  }
);
  final Iterator<ByteBuffer> itr=listCopy.iterator();
  return new Iterator<StarTreeTableRow>(){
    private StarTreeTableRow nextToReturn=new StarTreeTableRow(dimensionTypes.size(),metricTypes.size());
    private StarTreeTableRow nextFromItr=new StarTreeTableRow(dimensionTypes.size(),metricTypes.size());
    private boolean shouldReset=true;
    private boolean hasReturnedCurrent=true;
    private boolean hasStarted=false;
    private int numReturned=0;
    @Override public boolean hasNext(){
      if (itr.hasNext() && hasReturnedCurrent) {
        if (shouldReset) {
          if (!hasStarted) {
            ByteBuffer buffer=itr.next();
            fromByteBuffer(buffer,nextFromItr);
            hasStarted=true;
          }
          copyStarTreeTableRow(nextFromItr,nextToReturn,excludedDimensions);
          shouldReset=false;
        }
        while (itr.hasNext()) {
          ByteBuffer buffer=itr.next();
          fromByteBuffer(buffer,nextFromItr);
          if (includedComparator.compare(nextFromItr,nextToReturn) == 0) {
            aggregateStarTreeTableRow(nextFromItr,nextToReturn);
          }
 else {
            shouldReset=true;
            break;
          }
        }
        hasReturnedCurrent=false;
      }
      if (!itr.hasNext() && hasReturnedCurrent && shouldReset) {
        copyStarTreeTableRow(nextFromItr,nextToReturn,excludedDimensions);
        shouldReset=false;
        hasReturnedCurrent=false;
      }
      return itr.hasNext() || !hasReturnedCurrent;
    }
    @Override public StarTreeTableRow next(){
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      hasReturnedCurrent=true;
      numReturned++;
      return nextToReturn;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}
