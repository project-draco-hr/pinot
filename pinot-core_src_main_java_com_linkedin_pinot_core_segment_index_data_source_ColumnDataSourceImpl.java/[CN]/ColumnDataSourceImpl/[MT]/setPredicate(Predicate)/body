{
  predicate=p;
switch (predicate.getType()) {
case EQ:
    final int valueToLookUP=dictionary.indexOf(predicate.getRhs().get(0));
  if (valueToLookUP < 0) {
    filteredBitmap=new MutableRoaringBitmap();
  }
 else {
    filteredBitmap=invertedIndex.getMutable(valueToLookUP);
  }
break;
case NEQ:
final int neq=dictionary.indexOf(predicate.getRhs().get(0));
final MutableRoaringBitmap holderNEQ=new MutableRoaringBitmap();
for (int i=0; i < dictionary.length(); i++) {
if (i != neq) {
holderNEQ.or(invertedIndex.getImmutable(i));
}
}
filteredBitmap=holderNEQ;
break;
case IN:
final String[] inValues=predicate.getRhs().get(0).split(",");
final MutableRoaringBitmap inHolder=new MutableRoaringBitmap();
for (final String value : inValues) {
final int index=dictionary.indexOf(value);
if (index >= 0) {
inHolder.or(invertedIndex.getImmutable(index));
}
}
filteredBitmap=inHolder;
break;
case NOT_IN:
final String[] notInValues=predicate.getRhs().get(0).split(",");
final List<Integer> notInIds=new ArrayList<Integer>();
for (final String notInValue : notInValues) {
notInIds.add(new Integer(dictionary.indexOf(notInValue)));
}
final MutableRoaringBitmap notINHolder=new MutableRoaringBitmap();
for (int i=0; i < dictionary.length(); i++) {
if (!notInIds.contains(new Integer(i))) {
notINHolder.or(invertedIndex.getImmutable(i));
}
}
filteredBitmap=notINHolder;
break;
case RANGE:
int rangeStartIndex=0;
int rangeEndIndex=0;
final String rangeString=predicate.getRhs().get(0);
boolean incLower=true;
boolean incUpper=true;
if (rangeString.trim().startsWith("(")) {
incLower=false;
}
if (rangeString.trim().endsWith(")")) {
incUpper=false;
}
final String lower=rangeString.split(",")[0].substring(1,rangeString.split(",")[0].length());
final String upper=rangeString.split(",")[1].substring(0,rangeString.split(",")[1].length() - 1);
if (lower.equals("*")) {
rangeStartIndex=0;
}
 else {
rangeStartIndex=dictionary.indexOf(lower);
}
if (upper.equals("*")) {
rangeEndIndex=dictionary.length() - 1;
}
 else {
rangeEndIndex=dictionary.indexOf(upper);
}
if (rangeStartIndex < 0) {
rangeStartIndex=-(rangeStartIndex + 1);
}
 else if (!incLower && !lower.equals("*")) {
rangeStartIndex+=1;
}
if (rangeEndIndex < 0) {
rangeEndIndex=-(rangeEndIndex + 1);
rangeEndIndex=Math.max(0,rangeEndIndex - 1);
}
 else if (!incUpper && !upper.equals("*")) {
rangeEndIndex-=1;
}
if (rangeStartIndex > rangeEndIndex) {
return false;
}
final MutableRoaringBitmap rangeBitmapHolder=invertedIndex.getMutable(rangeStartIndex);
for (int i=(rangeStartIndex + 1); i <= rangeEndIndex; i++) {
rangeBitmapHolder.or(invertedIndex.getMutable(i));
}
filteredBitmap=rangeBitmapHolder;
break;
case REGEX:
throw new UnsupportedOperationException("unsupported type : " + columnMetadata.getDataType().toString() + " for filter type : regex");
}
return true;
}
