{
  String nodeId=new String(keyWritable.copyBytes());
  LOGGER.info("START: processing {}",nodeId);
  Map<DimensionKey,MetricTimeSeries> records=new HashMap<DimensionKey,MetricTimeSeries>();
  String dimensionStoreIndexDir=localInputDataDir + "/dimensionStore";
  DimensionDictionary dictionary=new DimensionDictionary(StarTreePersistanceUtil.readForwardIndex(nodeId,dimensionStoreIndexDir));
  List<int[]> allCombinations=StarTreePersistanceUtil.readLeafRecords(dimensionStoreIndexDir,nodeId,starTreeConfig.getDimensions().size());
  for (  BytesWritable recordBytes : bootstrapMapOutputValueWritableIterable) {
    BootstrapPhaseMapOutputValue record=BootstrapPhaseMapOutputValue.fromBytes(recordBytes.copyBytes(),metricSchema);
    if (!records.containsKey(record.getDimensionKey())) {
      records.put(record.getDimensionKey(),record.getMetricTimeSeries());
    }
 else {
      records.get(record.getDimensionKey()).aggregate(record.getMetricTimeSeries());
    }
    List<Long> timeWindowSet=new ArrayList<Long>(record.getMetricTimeSeries().getTimeWindowSet());
    if (timeWindowSet != null && timeWindowSet.size() != 0) {
      Collections.sort(timeWindowSet);
      long recordMin=timeWindowSet.get(0);
      long recordMax=timeWindowSet.get(timeWindowSet.size() - 1);
      if (recordMin < minDataTime) {
        minDataTime=recordMin;
      }
      if (recordMax > maxDataTime) {
        maxDataTime=recordMax;
      }
    }
  }
  for (  int[] combination : allCombinations) {
    DimensionKey dimensionKey=dictionary.translate(starTreeConfig.getDimensions(),combination);
    if (!records.containsKey(dimensionKey)) {
      MetricTimeSeries emptyTimeSeries=new MetricTimeSeries(metricSchema);
      records.put(dimensionKey,emptyTimeSeries);
    }
  }
  FixedBufferUtil.createLeafBufferFiles(new File(localTmpDataDir),nodeId,starTreeConfig,records,dictionary);
  long minDataTimeMillis=TimeUnit.MILLISECONDS.convert(minDataTime * config.getBucketSize(),TimeUnit.valueOf(config.getTimeUnit()));
  long maxDataTimeMillis=TimeUnit.MILLISECONDS.convert(maxDataTime * config.getBucketSize(),TimeUnit.valueOf(config.getTimeUnit()));
  indexMetadata=new IndexMetadata(minDataTimeMillis,maxDataTimeMillis,startTime,endTime,schedule);
  LOGGER.info("END: processing {}",nodeId);
}
