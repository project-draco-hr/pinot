{
  String nodeId=new String(keyWritable.copyBytes());
  LOG.info("START: processing {}",nodeId);
  Map<DimensionKey,MetricTimeSeries> records=new HashMap<DimensionKey,MetricTimeSeries>();
  String dimensionStoreIndexDir=localInputDataDir + "/dimensionStore";
  DimensionDictionary dictionary=new DimensionDictionary(StarTreePersistanceUtil.readForwardIndex(nodeId,dimensionStoreIndexDir));
  List<int[]> allCombinations=StarTreePersistanceUtil.readLeafRecords(dimensionStoreIndexDir,nodeId,starTreeConfig.getDimensions().size());
  for (  BytesWritable recordBytes : bootstrapMapOutputValueWritableIterable) {
    BootstrapPhaseMapOutputValue record=BootstrapPhaseMapOutputValue.fromBytes(recordBytes.copyBytes(),metricSchema);
    if (!records.containsKey(record.getDimensionKey())) {
      records.put(record.getDimensionKey(),record.getMetricTimeSeries());
    }
 else {
      records.get(record.getDimensionKey()).aggregate(record.getMetricTimeSeries());
    }
    List<Long> timeWindowSet=new ArrayList<Long>(record.getMetricTimeSeries().getTimeWindowSet());
    if (timeWindowSet != null && timeWindowSet.size() != 0) {
      Collections.sort(timeWindowSet);
      long recordMin=timeWindowSet.get(0);
      long recordMax=timeWindowSet.get(timeWindowSet.size() - 1);
      if (recordMin < minTime) {
        minTime=recordMin;
      }
      if (recordMax > maxTime) {
        maxTime=recordMax;
      }
    }
  }
  for (  int[] combination : allCombinations) {
    DimensionKey dimensionKey=dictionary.translate(starTreeConfig.getDimensions(),combination);
    if (!records.containsKey(dimensionKey)) {
      MetricTimeSeries emptyTimeSeries=new MetricTimeSeries(metricSchema);
      records.put(dimensionKey,emptyTimeSeries);
    }
  }
  FixedBufferUtil.createLeafBufferFiles(new File(localTmpDataDir),nodeId,starTreeConfig,records,dictionary);
  metadata=new HashMap<String,String>();
  metadata.put("mintime",Long.toString(minTime));
  metadata.put("maxtime",Long.toString(maxTime));
  LOG.info("END: processing {}",nodeId);
}
