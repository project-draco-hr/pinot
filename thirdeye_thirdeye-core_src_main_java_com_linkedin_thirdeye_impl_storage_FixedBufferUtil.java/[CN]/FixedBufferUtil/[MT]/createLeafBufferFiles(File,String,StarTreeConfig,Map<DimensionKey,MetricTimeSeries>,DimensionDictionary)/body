{
  File dictDir=new File(outputDir,StarTreeConstants.DICT_STORE);
  FileUtils.forceMkdir(dictDir);
  File dictFile=new File(dictDir,nodeId);
  FileOutputStream fos=new FileOutputStream(dictFile);
  ObjectOutputStream oos=new ObjectOutputStream(fos);
  oos.writeObject(dictionary);
  oos.flush();
  oos.close();
  List<DimensionKey> dimensionKeys=new ArrayList<DimensionKey>(records.keySet());
  Collections.sort(dimensionKeys);
  int dimensionBufferSize=dimensionKeys.size() * config.getDimensions().size() * Integer.SIZE / 8;
  File dimensionDir=new File(outputDir,StarTreeConstants.DIMENSION_STORE);
  File dimensionFile=new File(dimensionDir,nodeId);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Dimension buffer for node {}: bytes={}, numKeys={}, numDimensions={}, file={}",nodeId,dimensionBufferSize,dimensionKeys.size(),config.getDimensions().size(),dimensionFile);
  }
  ByteBuffer dimensionBuffer=ByteBuffer.allocate(dimensionBufferSize);
  for (  DimensionKey dimensionKey : dimensionKeys) {
    StorageUtils.addToDimensionStore(config,dimensionBuffer,dimensionKey,dictionary);
  }
  dimensionBuffer.flip();
  FileUtils.forceMkdir(dimensionDir);
  FileChannel dimensionFileChannel=new RandomAccessFile(dimensionFile,"rw").getChannel();
  dimensionFileChannel.write(dimensionBuffer);
  dimensionFileChannel.close();
  long minTime=-1;
  long maxTime=-1;
  for (  DimensionKey dimensionKey : dimensionKeys) {
    MetricTimeSeries timeSeries=records.get(dimensionKey);
    for (    Long time : timeSeries.getTimeWindowSet()) {
      if (minTime == -1 || time < minTime) {
        minTime=time;
      }
      if (maxTime == -1 || time > maxTime) {
        maxTime=time;
      }
    }
  }
  TimeRange timeRange=new TimeRange(minTime,maxTime);
  ByteBuffer metricBuffer;
  if (minTime == -1 || maxTime == -1) {
    metricBuffer=ByteBuffer.allocate(0);
  }
 else {
    int metricSize=MetricSchema.fromMetricSpecs(config.getMetrics()).getRowSizeInBytes();
    metricBuffer=ByteBuffer.allocate(dimensionKeys.size() * timeRange.totalBuckets() * (Long.SIZE / 8 + metricSize));
    for (    DimensionKey dimensionKey : dimensionKeys) {
      MetricTimeSeries timeSeries=records.get(dimensionKey);
      for (long i=minTime; i <= maxTime; i++) {
        for (        MetricSpec metricSpec : config.getMetrics()) {
          timeSeries.increment(i,metricSpec.getName(),0);
        }
      }
      StorageUtils.addToMetricStore(config,metricBuffer,timeSeries);
    }
  }
  metricBuffer.flip();
  File metricDir=new File(outputDir,StarTreeConstants.METRIC_STORE);
  FileUtils.forceMkdir(metricDir);
  FileChannel metricFile=new RandomAccessFile(new File(metricDir,nodeId + "_" + timeRange.getStart()+ ":"+ timeRange.getEnd()),"rw").getChannel();
  metricFile.write(metricBuffer);
  metricFile.close();
}
