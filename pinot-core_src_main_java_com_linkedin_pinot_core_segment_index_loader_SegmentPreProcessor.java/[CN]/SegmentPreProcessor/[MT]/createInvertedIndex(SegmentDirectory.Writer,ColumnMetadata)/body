{
  String columnName=columnMetadata.getColumnName();
  File inProgress=new File(segmentWriter.toSegmentDirectory().getPath().toFile(),columnName + ".inv.inprogress");
  if (!inProgress.exists()) {
    if (segmentWriter.hasIndexFor(columnName,ColumnIndexType.INVERTED_INDEX)) {
      LOGGER.info("Found inverted index for segment: {}, column: {}",segmentName,columnName);
      return;
    }
    FileUtils.touch(inProgress);
  }
 else {
    if (segmentVersion == SegmentVersion.v1 || segmentVersion == SegmentVersion.v2) {
      segmentWriter.removeIndex(columnName,ColumnIndexType.INVERTED_INDEX);
    }
  }
  LOGGER.info("Creating new inverted index for segment: {}, column: {}",segmentName,columnName);
  int totalDocs=columnMetadata.getTotalDocs();
  OffHeapBitmapInvertedIndexCreator creator=new OffHeapBitmapInvertedIndexCreator(indexDir,columnMetadata.getCardinality(),totalDocs,columnMetadata.getTotalNumberOfEntries(),columnMetadata.toFieldSpec());
  try (DataFileReader fwdIndex=getForwardIndexReader(columnMetadata,segmentWriter)){
    if (columnMetadata.isSingleValue()) {
      FixedBitSingleValueReader svFwdIndex=(FixedBitSingleValueReader)fwdIndex;
      for (int i=0; i < totalDocs; i++) {
        creator.add(i,svFwdIndex.getInt(i));
      }
    }
 else {
      SingleColumnMultiValueReader mvFwdIndex=(SingleColumnMultiValueReader)fwdIndex;
      int[] dictIds=new int[columnMetadata.getMaxNumberOfMultiValues()];
      for (int i=0; i < totalDocs; i++) {
        int len=mvFwdIndex.getIntArray(i,dictIds);
        creator.add(i,dictIds,len);
      }
    }
  }
   creator.seal();
  if (segmentVersion == SegmentVersion.v3) {
    File invertedIndexFile=creator.getInvertedIndexFile();
    int fileLength=(int)invertedIndexFile.length();
    PinotDataBuffer buffer=null;
    try {
      if (segmentWriter.hasIndexFor(columnName,ColumnIndexType.INVERTED_INDEX)) {
        buffer=segmentWriter.getIndexFor(columnName,ColumnIndexType.INVERTED_INDEX);
        if (buffer.size() != fileLength) {
          String failureMessage="V3 format segment: {} already has inverted index that cannot be removed.";
          LOGGER.error(failureMessage);
          throw new IllegalStateException(failureMessage);
        }
      }
 else {
        buffer=segmentWriter.newIndexFor(columnName,ColumnIndexType.INVERTED_INDEX,fileLength);
      }
      buffer.readFrom(invertedIndexFile);
    }
  finally {
      FileUtils.deleteQuietly(invertedIndexFile);
      if (buffer != null) {
        buffer.close();
      }
    }
  }
  FileUtils.deleteQuietly(inProgress);
  LOGGER.info("Created inverted index for segment: {}, column: {}",segmentName,columnName);
}
