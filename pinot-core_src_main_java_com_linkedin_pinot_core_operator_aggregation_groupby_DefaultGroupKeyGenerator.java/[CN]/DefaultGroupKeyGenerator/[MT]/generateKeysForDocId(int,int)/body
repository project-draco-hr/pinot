{
  List<Long> groupByKeys=new ArrayList<>();
  groupByKeys.add(0L);
  for (int i=0; i < _numGroupByColumns; i++) {
    if (_isSingleValueGroupByColumn[i]) {
      int dictId=_singleDictIds[i][index];
      for (int j=0; j < groupByKeys.size(); j++) {
        groupByKeys.set(j,groupByKeys.get(j) * _cardinalities[i] + dictId);
      }
    }
 else {
      BlockMultiValIterator blockValIterator=_multiValIterators[i];
      blockValIterator.skipTo(docId);
      int numMultiValues=blockValIterator.nextIntVal(_reusableMultiValDictIdArray);
      int originalSize=groupByKeys.size();
      for (int j=0; j < numMultiValues - 1; ++j) {
        for (int k=0; k < originalSize; k++) {
          groupByKeys.add(groupByKeys.get(k));
        }
      }
      for (int j=0; j < numMultiValues; j++) {
        for (int k=0; k < originalSize; k++) {
          int idx=j * originalSize + k;
          groupByKeys.set(idx,(groupByKeys.get(idx) * _cardinalities[i]) + _reusableMultiValDictIdArray[j]);
        }
      }
    }
  }
  int numGroupKeys=groupByKeys.size();
  int[] groupKeys=new int[numGroupKeys];
  for (int i=0; i < numGroupKeys; i++) {
    int groupKey=updateRawKeyToGroupKeyMapping(groupByKeys.get(i));
    groupKeys[i]=groupKey;
  }
  return groupKeys;
}
