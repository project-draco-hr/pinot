{
  if (resourceMetadata.getMetadata().containsKey(CONFIG_TIME_IN_MILLIS_TO_STOP_INDEXING)) {
    try {
      this.timeInMillisToStopIndexing=Long.parseLong(resourceMetadata.getMetadata().get(CONFIG_TIME_IN_MILLIS_TO_STOP_INDEXING));
    }
 catch (    Exception e) {
      this.timeInMillisToStopIndexing=DEFAULT_TIME_IN_MILLIS_TO_STOP_INDEXING;
    }
  }
  segmentEndTimeThreshold=start + this.timeInMillisToStopIndexing;
  if (resourceMetadata.getMetadata().containsKey(CONFIG_NUM_INDEXED_EVENTS_TO_STOP_INDEXING)) {
    try {
      this.numIndexedEventsToStopIndexing=Long.parseLong(resourceMetadata.getMetadata().get(CONFIG_NUM_INDEXED_EVENTS_TO_STOP_INDEXING));
    }
 catch (    Exception e) {
      this.numIndexedEventsToStopIndexing=DEFAULT_NUM_INDEXED_EVENTS_TO_STOP_INDEXING;
    }
  }
  this.schema=resourceMetadata.getDataSchema();
  this.segmentMetatdaZk=segmentMetadata;
  this.segmentName=segmentMetadata.getSegmentName();
  this.kafkaStreamProviderConfig=new KafkaHighLevelStreamProviderConfig();
  this.kafkaStreamProviderConfig.init(resourceMetadata,instanceMetadata);
  this.resourceDir=new File(resourceDataDir);
  this.resourceTmpDir=new File(resourceDataDir,"_tmp");
  if (!resourceTmpDir.exists()) {
    resourceTmpDir.mkdirs();
  }
  this.mode=mode;
  this.kafkaStreamProvider=new KafkaHighLevelConsumerStreamProvider();
  this.kafkaStreamProvider.init(kafkaStreamProviderConfig);
  this.kafkaStreamProvider.start();
  realtimeSegment=new RealtimeSegmentImpl(schema);
  ((RealtimeSegmentImpl)(realtimeSegment)).setSegmentName(segmentMetadata.getSegmentName());
  ((RealtimeSegmentImpl)(realtimeSegment)).setSegmentMetadata(segmentMetadata);
  notifier=realtimeResourceManager;
  segmentStatusTask=new TimerTask(){
    @Override public void run(){
      computeKeepIndexing();
    }
  }
;
  TimerService.timer.schedule(segmentStatusTask,ONE_MINUTE_IN_MILLSEC,ONE_MINUTE_IN_MILLSEC);
  indexingThread=new Thread(new Runnable(){
    @Override public void run(){
      while (index()) {
      }
      segmentStatusTask.cancel();
      logger.info("Trying to persist a realtimeSegment - " + realtimeSegment.getSegmentName());
      logger.info("Indexed " + ((RealtimeSegmentImpl)realtimeSegment).getRawDocumentCount() + " raw events, current number of docs = "+ ((RealtimeSegmentImpl)realtimeSegment).getTotalDocs());
      File tempSegmentFolder=new File(resourceTmpDir,"tmp-" + String.valueOf(System.currentTimeMillis()));
      RealtimeSegmentConverter conveter=new RealtimeSegmentConverter((RealtimeSegmentImpl)realtimeSegment,tempSegmentFolder.getAbsolutePath(),schema,segmentMetadata.getResourceName(),segmentMetadata.getTableName(),segmentMetadata.getSegmentName());
      try {
        logger.info("Trying to build segment!");
        conveter.build();
        FileUtils.moveDirectory(tempSegmentFolder.listFiles()[0],new File(resourceDataDir,segmentMetadata.getSegmentName()));
        FileUtils.deleteQuietly(tempSegmentFolder);
        long startTime=((RealtimeSegmentImpl)realtimeSegment).getMinTime();
        long endTime=((RealtimeSegmentImpl)realtimeSegment).getMaxTime();
        TimeUnit timeUnit=resourceMetadata.getDataSchema().getTimeSpec().getOutgoingGranularitySpec().getTimeType();
        swap();
        RealtimeSegmentZKMetadata metadaToOverrite=new RealtimeSegmentZKMetadata();
        metadaToOverrite.setResourceName(segmentMetadata.getResourceName());
        metadaToOverrite.setTableName(segmentMetadata.getTableName());
        metadaToOverrite.setSegmentName(segmentMetadata.getSegmentName());
        metadaToOverrite.setSegmentType(SegmentType.OFFLINE);
        metadaToOverrite.setStatus(Status.DONE);
        metadaToOverrite.setStartTime(startTime);
        metadaToOverrite.setEndTime(endTime);
        metadaToOverrite.setTotalDocs(realtimeSegment.getTotalDocs());
        metadaToOverrite.setTimeUnit(timeUnit);
        notifier.notify(metadaToOverrite);
        kafkaStreamProvider.commit();
        kafkaStreamProvider.shutdown();
      }
 catch (      Exception e) {
        logger.error("Caught exception in the realtime indexing thread",e);
      }
    }
  }
);
  indexingThread.start();
}
