{
synchronized (sync) {
    Map<Long,Number[]> allSums=new HashMap<Long,Number[]>();
    Set<Long> timeBuckets=getTimeBuckets(query);
    if (timeBuckets == null) {
      throw new IllegalArgumentException("Must specify time range in query " + query);
    }
    int[] targetDimensions=translateDimensions(query.getDimensionValues());
    int idx=binarySearch(targetDimensions);
    if (idx >= 0) {
      buffer.clear();
      buffer.position(idx + dimensionSize);
      updateAllSums(allSums,timeBuckets);
    }
 else {
      buffer.clear();
      int[] currentDimensions=new int[dimensionSpecs.size()];
      while (buffer.position() < buffer.limit()) {
        buffer.mark();
        getDimensions(currentDimensions);
        if (matches(targetDimensions,currentDimensions)) {
          updateAllSums(allSums,timeBuckets);
        }
        buffer.reset();
        buffer.position(buffer.position() + entrySize);
      }
    }
    List<StarTreeRecord> timeSeries=new ArrayList<StarTreeRecord>();
    for (    Map.Entry<Long,Number[]> entry : allSums.entrySet()) {
      StarTreeRecordImpl.Builder record=new StarTreeRecordImpl.Builder().setTime(entry.getKey()).setDimensionValues(query.getDimensionValues());
      for (int i=0; i < metricSpecs.size(); i++) {
        record.setMetricValue(metricSpecs.get(i).getName(),entry.getValue()[i]);
        record.setMetricType(metricSpecs.get(i).getName(),metricSpecs.get(i).getType());
      }
      timeSeries.add(record.build());
    }
    Collections.sort(timeSeries);
    return timeSeries;
  }
}
