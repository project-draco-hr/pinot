{
  DataOutputStream dataOutputStream=new DataOutputStream(outputStream);
  Map<Map<String,String>,List<StarTreeRecord>> groups=new HashMap<Map<String,String>,List<StarTreeRecord>>();
  for (  StarTreeRecord record : records) {
    List<StarTreeRecord> group=groups.get(record.getDimensionValues());
    if (group == null) {
      group=new ArrayList<StarTreeRecord>();
      groups.put(record.getDimensionValues(),group);
    }
    group.add(record);
  }
  List<Map<String,String>> orderedCombinations=new ArrayList<Map<String,String>>(groups.keySet());
  Collections.sort(orderedCombinations,new Comparator<Map<String,String>>(){
    @Override public int compare(    Map<String,String> c1,    Map<String,String> c2){
      for (      DimensionSpec dimensionSpec : dimensionSpecs) {
        String v1=c1.get(dimensionSpec.getName());
        String v2=c2.get(dimensionSpec.getName());
        int i1=forwardIndex.get(dimensionSpec.getName()).get(v1);
        int i2=forwardIndex.get(dimensionSpec.getName()).get(v2);
        if (i1 != i2) {
          return i1 - i2;
        }
      }
      return 0;
    }
  }
);
  for (  Map<String,String> combination : orderedCombinations) {
    List<StarTreeRecord> group=groups.get(combination);
    Map<Long,List<StarTreeRecord>> timeGroup=new HashMap<Long,List<StarTreeRecord>>();
    for (    StarTreeRecord r : group) {
      List<StarTreeRecord> rs=timeGroup.get(r.getTime());
      if (rs == null) {
        rs=new ArrayList<StarTreeRecord>();
        timeGroup.put(r.getTime(),rs);
      }
      rs.add(r);
    }
    Long minTime=null;
    List<StarTreeRecord> merged=new ArrayList<StarTreeRecord>();
    Set<Integer> representedBuckets=new HashSet<Integer>();
    for (    List<StarTreeRecord> rs : timeGroup.values()) {
      StarTreeRecord r=StarTreeUtils.merge(rs);
      merged.add(r);
      representedBuckets.add((int)(r.getTime() % numTimeBuckets));
      if (minTime == null || r.getTime() < minTime) {
        minTime=r.getTime();
      }
    }
    if (minTime != null) {
      int startBucket=(int)(minTime % numTimeBuckets);
      int currentBucket=startBucket;
      long currentTime=minTime;
      do {
        if (!representedBuckets.contains(currentBucket)) {
          StarTreeRecordImpl.Builder builder=new StarTreeRecordImpl.Builder().setDimensionValues(combination).setTime(currentTime);
          for (int i=0; i < metricSpecs.size(); i++) {
            String metricName=metricSpecs.get(i).getName();
            builder.setMetricValue(metricName,0);
            builder.setMetricType(metricName,metricSpecs.get(i).getType());
          }
          merged.add(builder.build());
        }
        currentTime++;
        currentBucket=(int)(currentTime % numTimeBuckets);
      }
 while (currentBucket != startBucket);
    }
    Collections.sort(merged,new Comparator<StarTreeRecord>(){
      @Override public int compare(      StarTreeRecord r1,      StarTreeRecord r2){
        int b1=(int)(r1.getTime() % numTimeBuckets);
        int b2=(int)(r2.getTime() % numTimeBuckets);
        return b1 - b2;
      }
    }
);
    for (    DimensionSpec dimensionSpec : dimensionSpecs) {
      String dimensionValue=combination.get(dimensionSpec.getName());
      Integer valueId=forwardIndex.get(dimensionSpec.getName()).get(dimensionValue);
      if (valueId == null) {
        throw new IllegalStateException("No ID for dimension value " + dimensionSpec.getName() + ":"+ dimensionValue);
      }
      dataOutputStream.writeInt(valueId);
    }
    for (    StarTreeRecord record : merged) {
      dataOutputStream.writeLong(record.getTime());
      for (int i=0; i < metricSpecs.size(); i++) {
        String metricName=metricSpecs.get(i).getName();
        if (keepMetricValues) {
          Number val=record.getMetricValues().get(metricName);
          NumberUtils.addToDataOutputStream(dataOutputStream,val,metricSpecs.get(i).getType());
        }
 else {
          NumberUtils.addToDataOutputStream(dataOutputStream,0,metricSpecs.get(i).getType());
        }
      }
    }
  }
}
