{
  Lock lock=collectionLocks.get(collection);
  if (lock == null) {
    collectionLocks.putIfAbsent(collection,new ReentrantLock());
    lock=collectionLocks.get(collection);
  }
  lock.lock();
  LOGGER.info("Locked collection {} using lock {} for data update",collection,lock);
  try {
    File collectionDir=new File(rootDir,collection);
    if (!collectionDir.exists()) {
      FileUtils.forceMkdir(collectionDir);
      LOGGER.info("Created {}",collectionDir);
    }
    if (schedule.contains("_")) {
      throw new IOException("schedule cannot contain '_'");
    }
    String loadId="load_" + UUID.randomUUID();
    File tmpDir=new File(new File(rootDir,collection),loadId);
    try {
      FileUtils.forceMkdir(tmpDir);
      File tarGzFile=new File(tmpDir,"data.tar.gz");
      OutputStream os=new FileOutputStream(tarGzFile);
      IOUtils.copy(data,os);
      os.close();
      TarGzCompressionUtils.unTar(tarGzFile,tmpDir);
      LOGGER.info("Extracted data into {}",tmpDir);
      File tmpTreeFile=new File(tmpDir,StarTreeConstants.TREE_FILE_NAME);
      ObjectInputStream treeStream=new ObjectInputStream(new FileInputStream(tmpTreeFile));
      StarTreeNode rootNode=(StarTreeNode)treeStream.readObject();
      String treeId=rootNode.getId().toString();
      LOGGER.info("Tree ID for {} is {}",loadId,treeId);
      File dataDir=new File(collectionDir,StorageUtils.getDataDirName(treeId,schedule,minTime,maxTime));
      if (dataDir.exists()) {
        throw new Exception("Data is already uploaded for timerange:" + minTime + " to "+ maxTime+ ". Please delete the existing data for this range and try again");
      }
      FileUtils.forceMkdir(dataDir);
      StorageUtils.moveAllFiles(tmpDir,dataDir);
      LOGGER.info("Moved files from {} to {}",tmpDir,dataDir);
      if (!dataDir.setLastModified(System.currentTimeMillis())) {
        LOGGER.warn("setLastModified on dataDir failed - watch service will not be triggered!");
      }
    }
  finally {
      FileUtils.forceDelete(tmpDir);
      LOGGER.info("Deleted tmp dir {}",tmpDir);
    }
  }
  finally {
    lock.unlock();
    LOGGER.info("Unlocked collection {} using lock {} for data update",collection,lock);
  }
}
