{
  Lock lock=collectionLocks.get(collection);
  if (lock == null) {
    collectionLocks.putIfAbsent(collection,new ReentrantLock());
    lock=collectionLocks.get(collection);
  }
  lock.lock();
  LOGGER.info("Locked collection {} using lock {} for data update",collection,lock);
  try {
    File collectionDir=new File(rootDir,collection);
    if (!collectionDir.exists()) {
      FileUtils.forceMkdir(collectionDir);
      LOGGER.info("Created {}",collectionDir);
    }
    if (schedule.contains("_")) {
      throw new IOException("schedule cannot contain '_'");
    }
    String loadId="load_" + UUID.randomUUID();
    File tmpDir=new File(new File(rootDir,collection),loadId);
    try {
      FileUtils.forceMkdir(tmpDir);
      File tarGzFile=new File(tmpDir,"data.tar.gz");
      OutputStream os=new FileOutputStream(tarGzFile);
      IOUtils.copy(data,os);
      os.close();
      TarGzCompressionUtils.unTar(tarGzFile,tmpDir);
      LOGGER.info("Extracted data into {}",tmpDir);
      File tmpTreeFile=new File(tmpDir,StarTreeConstants.TREE_FILE_NAME);
      ObjectInputStream treeStream=new ObjectInputStream(new FileInputStream(tmpTreeFile));
      StarTreeNode rootNode=(StarTreeNode)treeStream.readObject();
      String treeId=rootNode.getId().toString();
      LOGGER.info("Tree ID for {} is {}",loadId,treeId);
      File dataDir=new File(collectionDir,StorageUtils.getDataDirName(treeId,schedule,minTime,maxTime));
      if (dataDir.exists()) {
        throw new Exception("Data is already uploaded for timerange:" + minTime + " to "+ maxTime+ ". Please delete the existing data for this range and try again");
      }
      FileUtils.forceMkdir(dataDir);
      StorageUtils.moveAllFiles(tmpDir,dataDir);
      LOGGER.info("Moved files from {} to {}",tmpDir,dataDir);
      if (!dataDir.setLastModified(System.currentTimeMillis())) {
        LOGGER.warn("setLastModified on dataDir failed - watch service will not be triggered!");
      }
      if (autoExpire) {
        final DateTime expireUptoDate=minTime;
        String lowerSchedule=null;
        if (schedule.equals(StarTreeConstants.SCHEDULE.DAILY.name())) {
          lowerSchedule=StarTreeConstants.SCHEDULE.HOURLY.name();
        }
 else         if (schedule.equals(StarTreeConstants.SCHEDULE.MONTHLY.name())) {
          lowerSchedule=StarTreeConstants.SCHEDULE.DAILY.name();
        }
        if (lowerSchedule != null) {
          final String expireSchedule=lowerSchedule;
          File[] expireDirs=collectionDir.listFiles(new FilenameFilter(){
            @Override public boolean accept(            File dir,            String name){
              return name.startsWith(StorageUtils.getDataDirPrefix()) && StorageUtils.isExpirable(name,expireSchedule,expireUptoDate);
            }
          }
);
          for (          File expireDir : expireDirs) {
            String[] tokens=expireDir.getName().split("_");
            LOGGER.info("Deleting lower granularity segment {}",expireDir);
            deleteData(collection,tokens[1],StarTreeConstants.DATE_TIME_FORMATTER.parseDateTime(tokens[2]),StarTreeConstants.DATE_TIME_FORMATTER.parseDateTime(tokens[3]));
          }
        }
      }
    }
  finally {
      FileUtils.forceDelete(tmpDir);
      LOGGER.info("Deleted tmp dir {}",tmpDir);
    }
  }
  finally {
    lock.unlock();
    LOGGER.info("Unlocked collection {} using lock {} for data update",collection,lock);
  }
}
