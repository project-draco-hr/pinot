{
  if (starTree.getConfig().getRollup() == null) {
    LOGGER.warn("Rollup is null, will just use same tree");
    return starTree;
  }
  RollupSpec rollup=starTree.getConfig().getRollup();
  Constructor<?> constructor=Class.forName(rollup.getFunctionClass()).getConstructor(Map.class);
  final RollupThresholdFunction threshold=(RollupThresholdFunction)constructor.newInstance(rollup.getFunctionConfig());
  LOGGER.info("Rolling up using function {}",threshold);
  final Map<DimensionKey,MetricTimeSeries> aboveThreshold=new HashMap<>();
  final Map<DimensionKey,MetricTimeSeries> belowThreshold=new HashMap<>();
  starTree.eachLeaf(new StarTreeCallback(){
    @Override public void call(    StarTreeNode node){
      for (      StarTreeRecord record : node.getRecordStore()) {
        if (threshold.isAboveThreshold(record.getMetricTimeSeries())) {
          updateMap(aboveThreshold,record.getDimensionKey(),record.getMetricTimeSeries());
        }
 else {
          updateMap(belowThreshold,record.getDimensionKey(),record.getMetricTimeSeries());
        }
      }
    }
  }
);
  LOGGER.info("Above threshold = {}, below threshold = {}",aboveThreshold.size(),belowThreshold.size());
  Map<String,Integer> nameToPosition=new HashMap<>();
  for (int i=0; i < starTree.getConfig().getDimensions().size(); i++) {
    DimensionSpec dimensionSpec=starTree.getConfig().getDimensions().get(i);
    nameToPosition.put(dimensionSpec.getName(),i);
  }
  LOGGER.info("Generating aggregates for all combinations below threshold...");
  Map<DimensionKey,MetricTimeSeries> allCombinations=new HashMap<>();
  Map<DimensionKey,Set<DimensionKey>> allOptions=new HashMap<>();
  for (  Map.Entry<DimensionKey,MetricTimeSeries> entry : belowThreshold.entrySet()) {
    String[] oldValues=entry.getKey().getDimensionValues();
    for (    String dimensionName : rollup.getOrder()) {
      String[] newValues=Arrays.copyOf(oldValues,oldValues.length);
      int idx=nameToPosition.get(dimensionName);
      newValues[idx]=StarTreeConstants.OTHER;
      DimensionKey newKey=new DimensionKey(newValues);
      updateMap(allCombinations,newKey,entry.getValue());
      Set<DimensionKey> options=allOptions.get(entry.getKey());
      if (options == null) {
        options=new HashSet<>();
        allOptions.put(entry.getKey(),options);
      }
      options.add(newKey);
    }
  }
  LOGGER.info("Selecting combination with least others for all combinations below threshold...");
  Map<DimensionKey,MetricTimeSeries> selectedCombinations=new HashMap<>();
  String[] allOther=new String[starTree.getConfig().getDimensions().size()];
  Arrays.fill(allOther,StarTreeConstants.OTHER);
  DimensionKey allOtherKey=new DimensionKey(allOther);
  MetricSchema metricSchema=MetricSchema.fromMetricSpecs(starTree.getConfig().getMetrics());
  selectedCombinations.put(allOtherKey,new MetricTimeSeries(metricSchema));
  for (  Map.Entry<DimensionKey,Set<DimensionKey>> entry : allOptions.entrySet()) {
    DimensionKey selected=null;
    int minOther=Integer.MAX_VALUE;
    for (    DimensionKey option : entry.getValue()) {
      int numOther=0;
      for (int i=0; i < option.getDimensionValues().length; i++) {
        if (StarTreeConstants.OTHER.equals(option.getDimensionValues()[i])) {
          numOther++;
        }
      }
      MetricTimeSeries rollUpSeries=allCombinations.get(option);
      if (numOther < minOther && threshold.isAboveThreshold(rollUpSeries)) {
        minOther=numOther;
        selected=option;
      }
    }
    if (selected == null) {
      selected=allOtherKey;
    }
    MetricTimeSeries rawTimeSeries=belowThreshold.get(entry.getKey());
    updateMap(selectedCombinations,selected,rawTimeSeries);
  }
  LOGGER.info("Creating rolled up star tree...");
  StarTree rolledUpTree=new StarTreeImpl(starTree.getConfig());
  rolledUpTree.open();
  for (  Map.Entry<DimensionKey,MetricTimeSeries> entry : aboveThreshold.entrySet()) {
    rolledUpTree.add(new StarTreeRecordImpl(starTree.getConfig(),entry.getKey(),entry.getValue()));
  }
  return rolledUpTree;
}
