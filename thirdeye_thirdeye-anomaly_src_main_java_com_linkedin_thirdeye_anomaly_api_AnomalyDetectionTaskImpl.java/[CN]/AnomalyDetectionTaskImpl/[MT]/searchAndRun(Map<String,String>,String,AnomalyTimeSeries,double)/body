{
  boolean shouldContinueExploring=true;
  AnomalyDetectionDataset dataset=getDataset(dimensionValues);
  sanityCheckDataset(dataset);
  Map<DimensionKey,Double> dimensionKeyContributionMap=computeDatasetProportions(dataset,dimensionKeyContributionMetric);
  Set<DimensionKey> dimensionKeysEvaluated=new HashSet<>();
  Set<DimensionKey> dimensionKeysWithAnomalies=new HashSet<>();
  for (  DimensionKey dimensionKey : dataset.getDimensionKeys()) {
    if (dimensionKeyContributionMap != null) {
      double proportion=dimensionKeyContributionMap.get(dimensionKey) * proportionMultiplier;
      if (proportion <= collectionDriverConfig.getContributionMinProportion()) {
        LOGGER.info("skipping series {} - proportion ({}) below threshold",dimensionKey,String.format("%.4f",proportion));
        continue;
      }
 else {
        LOGGER.info("analyzing series {} - proportion ({})",dimensionKey,String.format("%.4f",proportion));
      }
    }
    LOGGER.info("evaluating series for key {}",dimensionKey);
    MetricTimeSeries series=dataset.getMetricTimeSeries(dimensionKey);
    List<AnomalyResult> anomalyResults=null;
    try {
      anomalyResults=function.analyze(dimensionKey,series,taskInfo.getTimeRange(),functionHistory.getHistoryForDimensionKey(dimensionKey));
      filterAnomalyResults(anomalyResults);
    }
 catch (    FunctionDidNotEvaluateException e) {
      LOGGER.warn("failed to execute function - {}",function.toString(),e);
      continue;
    }
    handleAnomalyResults(anomalies,dimensionKey,dimensionKeyContributionMap.get(dimensionKey),anomalyResults);
    dimensionKeysEvaluated.add(dimensionKey);
    if (anomalyResults.isEmpty() == false) {
      dimensionKeysWithAnomalies.add(dimensionKey);
    }
    LOGGER.info("finished analysis on {} between {} ({})",dimensionKey,taskInfo.getTimeRange(),DateTimeZone.getDefault());
  }
  if (collectionDriverConfig.isPruneExplortaionUsingFeedback()) {
    int numDimensionKeysEvaluated=dimensionKeysEvaluated.size();
    int numDimensionKeysWithAnomalies=dimensionKeysWithAnomalies.size();
    if (numDimensionKeysWithAnomalies / (double)numDimensionKeysEvaluated >= PRUNING_MAX_NUMBER_ANOMALOUS_DIMENSION_KEYS_THRESHOLD) {
      shouldContinueExploring=false;
      LOGGER.info("stop exploring because group by produced many anomalous series");
    }
  }
  if (dimensionValues.size() >= collectionDriverConfig.getMaxExplorationDepth()) {
    shouldContinueExploring=false;
  }
  if (shouldContinueExploring) {
    for (    DimensionKey dimensionKey : dimensionKeysEvaluated) {
      if (collectionDriverConfig.isPruneExplortaionUsingFeedback() && dimensionKeysWithAnomalies.contains(dimensionKey)) {
        LOGGER.info("pruned computation due to anomaly in enclosing series");
        continue;
      }
      if (groupByDimension != null) {
        String fixedDimensionValue=dimensionKey.getDimensionValue(starTreeConfig.getDimensions(),groupByDimension);
        LOGGER.info("fixing dimension '{}' to '{}'",groupByDimension,fixedDimensionValue);
        dimensionValues.put(groupByDimension,fixedDimensionValue);
      }
      for (      String nextGroupByDimension : getDimensionKeysToGroupBy(dimensionValues)) {
        LOGGER.info("grouping by '{}'",nextGroupByDimension);
        dimensionValues.put(nextGroupByDimension,GROUP_BY_VALUE);
        searchAndRun(dimensionValues,nextGroupByDimension,anomalies,proportionMultiplier * dimensionKeyContributionMap.get(dimensionKey));
        dimensionValues.remove(nextGroupByDimension);
      }
    }
  }
}
