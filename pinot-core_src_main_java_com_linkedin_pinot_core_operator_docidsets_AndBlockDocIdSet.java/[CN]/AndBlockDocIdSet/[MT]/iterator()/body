{
  return new BlockDocIdIterator(){
    int currentMax=-1;
    @Override public int advance(    int targetDocId){
      if (currentDocId == Constants.EOF) {
        return currentDocId;
      }
      if (currentDocId >= targetDocId) {
        return currentDocId;
      }
      currentMax=targetDocId - 1;
      return next();
    }
    @Override public int next(){
      long start=System.currentTimeMillis();
      if (currentDocId == Constants.EOF) {
        return currentDocId;
      }
      currentMax=currentMax + 1;
      for (int i=0; i < docIdIterators.length; i++) {
        docIdPointers[i]=docIdIterators[i].advance(currentMax);
        if (docIdPointers[i] == Constants.EOF) {
          reachedEnd=true;
          currentMax=Constants.EOF;
          break;
        }
        if (docIdPointers[i] > currentMax) {
          currentMax=docIdPointers[i];
          if (i > 0) {
            i=-1;
          }
        }
 else         if (docIdPointers[i] < currentMax) {
          LOGGER.warn("Should never happen, {} returns docIdPointer : {} should always >= currentMax : {}",docIdIterators[i],docIdPointers[i],currentMax);
          throw new IllegalStateException("Should never happen, docIdPointer should always >= currentMax");
        }
      }
      currentDocId=currentMax;
      long end=System.currentTimeMillis();
      timeMeasure.addAndGet(end - start);
      return currentDocId;
    }
    @Override public int currentDocId(){
      return currentDocId;
    }
  }
;
}
