{
  List<MetricTable> tables=new ArrayList<>();
  for (  Map.Entry<String,Map<String,Number[]>> entry : result.getData().entrySet()) {
    List<MetricDataRow> rows=new LinkedList<>();
    List<MetricDataRow> cumulativeRows=new LinkedList<>();
    List<Long> times=getReverseSortedTimes(entry.getValue().keySet());
    long windowFilled=0;
    int idx=0;
    while (windowFilled < intraDayPeriod && idx < times.size() - 1) {
      long current=times.get(idx);
      long next=times.get(idx + 1);
      idx++;
      int timeIndex=times.indexOf(current - baselineOffsetMillis);
      if (timeIndex < 0) {
        continue;
      }
      long baseline=times.get(timeIndex);
      windowFilled+=(current - next);
      Number[] currentData=entry.getValue().get(String.valueOf(current));
      Number[] baselineData=entry.getValue().get(String.valueOf(baseline));
      rows.add(0,new MetricDataRow(new DateTime(baseline).toDateTime(DateTimeZone.UTC),baselineData,new DateTime(current).toDateTime(DateTimeZone.UTC),currentData));
    }
    if (!rows.isEmpty()) {
      int metricCount=result.getMetrics().size();
      Number[] cumulativeBaselineData=new Number[metricCount];
      Arrays.fill(cumulativeBaselineData,0.0);
      Number[] cumulativeCurrentData=new Number[metricCount];
      Arrays.fill(cumulativeCurrentData,0.0);
      for (      MetricDataRow row : rows) {
        Number[] baselineData=row.getBaseline();
        for (int i=0; i < baselineData.length; i++) {
          cumulativeBaselineData[i]=cumulativeBaselineData[i].doubleValue() + (baselineData[i] == null ? 0.0 : baselineData[i].doubleValue());
        }
        Number[] currentData=row.getCurrent();
        for (int i=0; i < currentData.length; i++) {
          cumulativeCurrentData[i]=cumulativeCurrentData[i].doubleValue() + (currentData[i] == null ? 0.0 : currentData[i].doubleValue());
        }
        Number[] cumulativeBaselineDataCopy=Arrays.copyOf(cumulativeBaselineData,cumulativeBaselineData.length);
        Number[] cumulativeCurrentDataCopy=Arrays.copyOf(cumulativeCurrentData,cumulativeCurrentData.length);
        MetricDataRow cumulativeRow=new MetricDataRow(row.getBaselineTime(),cumulativeBaselineDataCopy,row.getCurrentTime(),cumulativeCurrentDataCopy);
        cumulativeRows.add(cumulativeRow);
      }
    }
    tables.add(new MetricTable(getDimensionValues(entry.getKey()),rows,cumulativeRows));
  }
  return tables;
}
