{
  final BrokerRequest req=new BrokerRequest();
  final QuerySource source=new QuerySource();
  if (requestJSON.has(COLLECTION)) {
    final String collection=requestJSON.getString(COLLECTION);
    source.setResourceName(collection);
  }
  req.setQuerySource(source);
  boolean setSelection=false;
  if (requestJSON.has(META)) {
    final Selection selection=new Selection();
    if (requestJSON.getJSONObject(META).has(SELECT_LIST)) {
      final JSONArray selectionsArr=requestJSON.getJSONObject(META).getJSONArray(SELECT_LIST);
      final List<String> columns=new ArrayList<String>();
      for (int i=0; i < selectionsArr.length(); i++) {
        final String s=selectionsArr.getString(i);
        setSelection=true;
        columns.add(s.trim());
      }
      selection.setSelectionColumns(columns);
    }
    if (requestJSON.has(PAGING_FROM)) {
      selection.setOffset(requestJSON.getInt(PAGING_FROM));
    }
    if (requestJSON.has(PAGING_SIZE)) {
      selection.setSize(requestJSON.getInt(PAGING_SIZE));
    }
    if (requestJSON.has(SORT)) {
      final List<SelectionSort> selectionsSorts=new ArrayList<SelectionSort>();
      final JSONArray sorts=requestJSON.getJSONArray(SORT);
      for (int i=0; i < sorts.length(); i++) {
        final String key=(String)sorts.getJSONObject(i).keys().next();
        final String val=sorts.getJSONObject(i).getString(key);
        final SelectionSort sort=new SelectionSort();
        sort.setColumn(key);
        sort.setIsAsc(val.equals("asc"));
        selectionsSorts.add(sort);
      }
      selection.setSelectionSortSequence(selectionsSorts);
    }
    if (setSelection && !requestJSON.has("mapReduce") && !requestJSON.has("facets")) {
      req.setSelections(selection);
    }
  }
  final List<AggregationInfo> aggInfos=new ArrayList<AggregationInfo>();
  if (requestJSON.has(FACETS)) {
    final GroupBy gBy=new GroupBy();
    gBy.setTopN(requestJSON.getJSONObject("groupBy").getLong("top"));
    final List<String> cols=new ArrayList<String>();
    final String k=(String)requestJSON.getJSONObject(FACETS).keys().next();
    cols.add(k);
    gBy.setColumns(cols);
    req.setGroupBy(gBy);
    final AggregationInfo inf=new AggregationInfo();
    inf.setAggregationType("count");
    final Map<String,String> params=new HashMap<String,String>();
    params.put("column","*");
    inf.setAggregationParams(params);
    aggInfos.add(inf);
  }
  if (requestJSON.has(MAP_REDUCE)) {
    if (requestJSON.getJSONObject(MAP_REDUCE).getString(MAP_REDUCE_FUNCTION).equals(COMPOSITE_MR)) {
      final JSONArray aggs=requestJSON.getJSONObject(MAP_REDUCE).getJSONObject("parameters").getJSONArray("array");
      if (aggs.getJSONObject(0).getString("mapReduce").equals("sensei.groupBy")) {
        final GroupBy groupBy=new GroupBy();
        final HashSet<String> groupByColumns=new HashSet<String>();
        for (int i=0; i < aggs.length(); i++) {
          final AggregationInfo inf=new AggregationInfo();
          final JSONArray columns=aggs.getJSONObject(i).getJSONArray("columns");
          for (int j=0; j < columns.length(); j++) {
            groupByColumns.add(columns.getString(j));
          }
          inf.setAggregationType(aggs.getJSONObject(i).getString("function"));
          final Map<String,String> params=new HashMap<String,String>();
          params.put("column",aggs.getJSONObject(i).getString("metric"));
          inf.setAggregationParams(params);
          aggInfos.add(inf);
        }
        groupBy.setTopN(requestJSON.getJSONObject("groupBy").getLong("top"));
        final String[] a=new String[groupByColumns.size()];
        groupBy.setColumns(Arrays.asList(groupByColumns.toArray(a)));
        req.setGroupBy(groupBy);
      }
 else {
        for (int i=0; i < aggs.length(); i++) {
          final AggregationInfo inf=new AggregationInfo();
          inf.setAggregationType(aggs.getJSONObject(i).getString(MAP_REDUCE));
          final Map<String,String> params=new HashMap<String,String>();
          if ((aggs.getJSONObject(i).getString("column") == null) || (aggs.getJSONObject(i).getString("column").length() <= 1)) {
            params.put("column","*");
          }
 else {
            params.put("column",aggs.getJSONObject(i).getString("column"));
          }
          inf.setAggregationParams(params);
          aggInfos.add(inf);
        }
      }
    }
 else     if (requestJSON.getJSONObject(MAP_REDUCE).getString(MAP_REDUCE_FUNCTION).equals("sensei.groupBy")) {
      final JSONObject parameters=requestJSON.getJSONObject(MAP_REDUCE).getJSONObject("parameters");
      final List<String> cols=new ArrayList<String>();
      final JSONArray columns=parameters.getJSONArray("columns");
      for (int i=0; i < columns.length(); i++) {
        cols.add(columns.getString(i));
      }
      final GroupBy gBy=new GroupBy();
      gBy.setTopN(requestJSON.getJSONObject("groupBy").getLong("top"));
      gBy.setColumns(cols);
      req.setGroupBy(gBy);
      final AggregationInfo inf=new AggregationInfo();
      inf.setAggregationType(parameters.getString("function"));
      final Map<String,String> params=new HashMap<String,String>();
      params.put("column",parameters.getString("metric"));
      inf.setAggregationParams(params);
      aggInfos.add(inf);
    }
 else     if (requestJSON.getJSONObject(MAP_REDUCE).getString(MAP_REDUCE_FUNCTION).equals("count")) {
      final AggregationInfo inf=new AggregationInfo();
      inf.setAggregationType(requestJSON.getJSONObject(MAP_REDUCE).getJSONObject("parameters").getString(MAP_REDUCE));
      final Map<String,String> params=new HashMap<String,String>();
      params.put("column","*");
      inf.setAggregationParams(params);
      aggInfos.add(inf);
    }
 else {
      final AggregationInfo inf=new AggregationInfo();
      inf.setAggregationType(requestJSON.getJSONObject(MAP_REDUCE).getJSONObject("parameters").getString(MAP_REDUCE));
      final Map<String,String> params=new HashMap<String,String>();
      if ((requestJSON.getJSONObject(MAP_REDUCE).getJSONObject("parameters").getString("column") == null) || (requestJSON.getJSONObject(MAP_REDUCE).getJSONObject("parameters").getString("column").length() <= 1)) {
        params.put("column","*");
      }
 else {
        params.put("column",requestJSON.getJSONObject(MAP_REDUCE).getJSONObject("parameters").getString("column"));
      }
      inf.setAggregationParams(params);
      aggInfos.add(inf);
    }
  }
  if (aggInfos.size() > 0) {
    req.setAggregationsInfo(aggInfos);
  }
  if (requestJSON.has("filter")) {
    final FilterQueryTree filterQuery=FilterQueryTreeConstructor.constructFilter(requestJSON.getJSONObject("filter"));
    RequestUtils.generateFilterFromTree(filterQuery,req);
  }
  return req;
}
