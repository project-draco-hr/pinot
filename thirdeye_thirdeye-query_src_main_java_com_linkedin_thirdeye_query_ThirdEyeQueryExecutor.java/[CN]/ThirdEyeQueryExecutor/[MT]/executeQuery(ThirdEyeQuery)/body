{
  LOGGER.info("START Execution for query_id: {} query{}",query.hashCode(),query);
  ThirdEyeQueryResult result=new ThirdEyeQueryResult();
  final StarTreeConfig config=starTreeManager.getConfig(query.getCollection());
  if (config == null) {
    throw new IllegalArgumentException("No collection " + query.getCollection());
  }
  final List<String> dimensionNames=new ArrayList<>(config.getDimensions().size());
  for (  DimensionSpec dimensionSpec : config.getDimensions()) {
    dimensionNames.add(dimensionSpec.getName());
  }
  result.setDimensions(dimensionNames);
  long startOffset=0;
  long collectionWindowMillis=0;
  for (  ThirdEyeFunction function : query.getFunctions()) {
    if (function instanceof ThirdEyeMovingAverageFunction) {
      ThirdEyeMovingAverageFunction movingAverageFunction=(ThirdEyeMovingAverageFunction)function;
      TimeGranularity window=movingAverageFunction.getWindow();
      long windowMillis=TimeUnit.MILLISECONDS.convert(window.getSize(),window.getUnit());
      if (windowMillis > startOffset) {
        startOffset=windowMillis;
      }
    }
 else     if (function instanceof ThirdEyeAggregateFunction) {
      ThirdEyeAggregateFunction aggregateFunction=(ThirdEyeAggregateFunction)function;
      TimeGranularity window=aggregateFunction.getWindow();
      collectionWindowMillis=TimeUnit.MILLISECONDS.convert(window.getSize(),window.getUnit());
    }
  }
  TreeSelections treeSelections=calculateTreeSelections(config,query.getStart(),query.getEnd(),collectionWindowMillis,startOffset);
  final Map<UUID,TimeRange> timeRangesToQuery=treeSelections.getTimeRangesToQuery();
  final List<StarTree> starTrees=getStarTrees(config,treeSelections.getAllTreeIdsToQuery());
  if (!query.getGroupByColumns().isEmpty()) {
    for (    final String groupByColumn : query.getGroupByColumns()) {
      if (query.getDimensionValues().containsKey(groupByColumn)) {
        throw new IllegalArgumentException("Cannot fix dimension value in group by: " + groupByColumn);
      }
      final Set<Future<Set<String>>> dimensionSetFutures=new HashSet<>();
      for (      final StarTree starTree : starTrees) {
        dimensionSetFutures.add(executorService.submit(new Callable<Set<String>>(){
          @Override public Set<String> call() throws Exception {
            return starTree.getDimensionValues(groupByColumn,query.getDimensionValues().asMap());
          }
        }
));
      }
      Set<String> dimensionSet=new HashSet<>();
      for (      Future<Set<String>> future : dimensionSetFutures) {
        dimensionSet.addAll(future.get());
      }
      dimensionSet.remove(StarTreeConstants.STAR);
      for (      String dimensionValue : dimensionSet) {
        query.addDimensionValue(groupByColumn,dimensionValue);
      }
    }
  }
  List<DimensionKey> dimensionKeys=new ArrayList<>();
  for (  String[] combination : query.getDimensionCombinations(config.getDimensions())) {
    dimensionKeys.add(new DimensionKey(combination));
  }
  Map<StarTree,Multimap<DimensionKey,Future<MetricTimeSeries>>> timeSeriesFutures=new HashMap<>();
  for (  final StarTree starTree : starTrees) {
    final UUID treeId=starTree.getRoot().getId();
    Multimap<DimensionKey,Future<MetricTimeSeries>> singleKeyResultMap=LinkedListMultimap.create();
    timeSeriesFutures.put(starTree,singleKeyResultMap);
    for (    final DimensionKey dimensionKey : dimensionKeys) {
      DimensionKey flattenedKey=flattenDisjunctions(config,query,dimensionKey);
      timeSeriesFutures.get(starTree).put(flattenedKey,executorService.submit(new Callable<MetricTimeSeries>(){
        @Override public MetricTimeSeries call() throws Exception {
          TimeRange timeRange=timeRangesToQuery.get(treeId);
          return starTree.getTimeSeries(new StarTreeQueryImpl(config,dimensionKey,timeRange));
        }
      }
));
    }
  }
  Map<DimensionKey,MetricTimeSeries> mergedResults=new HashMap<>();
  for (  Multimap<DimensionKey,Future<MetricTimeSeries>> resultMap : timeSeriesFutures.values()) {
    for (    Map.Entry<DimensionKey,Collection<Future<MetricTimeSeries>>> entry : resultMap.asMap().entrySet()) {
      for (      Future<MetricTimeSeries> seriesFuture : entry.getValue()) {
        MetricTimeSeries additionalSeries=seriesFuture.get();
        MetricTimeSeries currentSeries=mergedResults.get(entry.getKey());
        if (currentSeries == null) {
          currentSeries=new MetricTimeSeries(additionalSeries.getSchema());
          mergedResults.put(entry.getKey(),currentSeries);
        }
        currentSeries.aggregate(additionalSeries);
      }
    }
  }
  for (  Map.Entry<DimensionKey,MetricTimeSeries> entry : mergedResults.entrySet()) {
    MetricTimeSeries timeSeries=entry.getValue();
    for (    ThirdEyeFunction function : query.getFunctions()) {
      timeSeries=function.apply(config,query,timeSeries);
    }
    for (    ThirdEyeFunction function : query.getDerivedMetrics()) {
      timeSeries=function.apply(config,query,timeSeries);
    }
    List<String> resultMetrics=new ArrayList<>();
    resultMetrics.addAll(query.getMetricNames());
    for (    ThirdEyeFunction function : query.getDerivedMetrics()) {
      resultMetrics.add(function.toString());
    }
    ThirdEyeFunction toMillis=new ThirdEyeUnitConversionFunction(1,TimeUnit.MILLISECONDS,resultMetrics);
    timeSeries=toMillis.apply(config,query,timeSeries);
    result.addData(entry.getKey(),timeSeries);
    result.setMetrics(timeSeries.getSchema().getNames());
  }
  LOGGER.info("END Execution for query_id: {} ",query.hashCode());
  return result;
}
