{
  LOGGER.info("START Execution for query_id: {} query{}",query.hashCode(),query);
  ThirdEyeQueryResult result=new ThirdEyeQueryResult();
  final StarTreeConfig config=starTreeManager.getConfig(query.getCollection());
  if (config == null) {
    throw new IllegalArgumentException("No collection " + query.getCollection());
  }
  final List<String> dimensionNames=new ArrayList<>(config.getDimensions().size());
  for (  DimensionSpec dimensionSpec : config.getDimensions()) {
    dimensionNames.add(dimensionSpec.getName());
  }
  result.setDimensions(dimensionNames);
  long startOffset=0;
  long collectionWindowMillis=0;
  for (  ThirdEyeFunction function : query.getFunctions()) {
    if (function instanceof ThirdEyeMovingAverageFunction) {
      ThirdEyeMovingAverageFunction movingAverageFunction=(ThirdEyeMovingAverageFunction)function;
      TimeGranularity window=movingAverageFunction.getWindow();
      long windowMillis=TimeUnit.MILLISECONDS.convert(window.getSize(),window.getUnit());
      if (windowMillis > startOffset) {
        startOffset=windowMillis;
      }
    }
 else     if (function instanceof ThirdEyeAggregateFunction) {
      ThirdEyeAggregateFunction aggregateFunction=(ThirdEyeAggregateFunction)function;
      TimeGranularity window=aggregateFunction.getWindow();
      collectionWindowMillis=TimeUnit.MILLISECONDS.convert(window.getSize(),window.getUnit());
    }
  }
  DateTime queryStartInMillis=new DateTime(query.getStart().getMillis() - startOffset);
  long queryStartTime=dateTimeToCollectionTime(config,queryStartInMillis);
  long queryEndTime=dateTimeToCollectionTime(config,query.getEnd());
  final TimeRange inputQueryTimeRange=new TimeRange(queryStartInMillis.getMillis(),query.getEnd().getMillis());
  Map<UUID,IndexMetadata> immutableMetadataMap=new HashMap<>();
  Map<UUID,IndexMetadata> realTimeMetadataMap=new HashMap<>();
  for (  StarTree starTree : starTreeManager.getStarTrees(config.getCollection()).values()) {
    UUID treeId=starTree.getRoot().getId();
    IndexMetadata indexMetadata=starTreeManager.getIndexMetadata(treeId);
    if ("KAFKA".equals(indexMetadata.getTimeGranularity())) {
      realTimeMetadataMap.put(treeId,indexMetadata);
    }
 else {
      immutableMetadataMap.put(treeId,indexMetadata);
    }
  }
  LOGGER.info("Selecting trees to query for queryTimeRange:{}",inputQueryTimeRange);
  List<UUID> treeIdsToQuery=selectTreesToQuery(immutableMetadataMap,inputQueryTimeRange);
  if (collectionWindowMillis > 0) {
    long collectionWindow=dateTimeToCollectionTime(config,new DateTime(collectionWindowMillis));
    queryStartTime=(queryStartTime / collectionWindow) * collectionWindow;
    queryEndTime=(queryEndTime / collectionWindow + 1) * collectionWindow;
  }
  final TimeRange queryTimeRange=new TimeRange(queryStartTime,queryEndTime);
  final Map<UUID,TimeRange> timeRangesToQuery=new HashMap<>();
  for (  UUID treeId : treeIdsToQuery) {
    timeRangesToQuery.put(treeId,queryTimeRange);
  }
  Long maxImmutableTimeMillis=null;
  for (  UUID treeId : treeIdsToQuery) {
    IndexMetadata indexMetadata=immutableMetadataMap.get(treeId);
    if (maxImmutableTimeMillis == null || maxImmutableTimeMillis < indexMetadata.getMaxDataTimeMillis()) {
      maxImmutableTimeMillis=indexMetadata.getMaxDataTimeMillis();
    }
  }
  Long realTimeStartTime=null;
  Long realTimeStartTimeMillis=null;
  if (maxImmutableTimeMillis == null) {
    realTimeStartTime=queryTimeRange.getStart();
    realTimeStartTimeMillis=queryStartInMillis.getMillis();
  }
 else   if (maxImmutableTimeMillis < query.getEnd().getMillis()) {
    realTimeStartTime=dateTimeToCollectionTime(config,new DateTime(maxImmutableTimeMillis));
    realTimeStartTimeMillis=maxImmutableTimeMillis;
    long collectionWindow=dateTimeToCollectionTime(config,new DateTime(collectionWindowMillis));
    if (collectionWindow > 0) {
      realTimeStartTime=(realTimeStartTime / collectionWindow) * collectionWindow;
    }
  }
  List<UUID> realTimeTreeIdsToQuery=new ArrayList<>();
  if (realTimeStartTime != null) {
    TimeRange mutableTimeRange=new TimeRange(realTimeStartTime,queryTimeRange.getEnd());
    TimeRange mutableTimeRangeMillis=new TimeRange(realTimeStartTimeMillis,query.getEnd().getMillis());
    realTimeTreeIdsToQuery.addAll(selectTreesToQuery(realTimeMetadataMap,mutableTimeRangeMillis));
    StarTree mutableTree=starTreeManager.getMutableStarTree(config.getCollection());
    realTimeTreeIdsToQuery.add(mutableTree.getRoot().getId());
    for (    UUID treeId : realTimeTreeIdsToQuery) {
      timeRangesToQuery.put(treeId,mutableTimeRange);
    }
  }
  if (!query.getGroupByColumns().isEmpty()) {
    for (    final String groupByColumn : query.getGroupByColumns()) {
      if (query.getDimensionValues().containsKey(groupByColumn)) {
        throw new IllegalArgumentException("Cannot fix dimension value in group by: " + groupByColumn);
      }
      final Set<Future<Set<String>>> dimensionSetFutures=new HashSet<>();
      final List<StarTree> starTrees=new ArrayList<>(starTreeManager.getStarTrees(config.getCollection()).values());
      StarTree mutableTree=starTreeManager.getMutableStarTree(config.getCollection());
      if (mutableTree != null) {
        starTrees.add(mutableTree);
      }
      for (      final StarTree starTree : starTrees) {
        UUID treeId=starTree.getRoot().getId();
        if (!treeIdsToQuery.contains(treeId) && !realTimeTreeIdsToQuery.contains(treeId)) {
          continue;
        }
        dimensionSetFutures.add(executorService.submit(new Callable<Set<String>>(){
          @Override public Set<String> call() throws Exception {
            return starTree.getDimensionValues(groupByColumn,query.getDimensionValues().asMap());
          }
        }
));
      }
      Set<String> dimensionSet=new HashSet<>();
      for (      Future<Set<String>> future : dimensionSetFutures) {
        dimensionSet.addAll(future.get());
      }
      dimensionSet.remove(StarTreeConstants.STAR);
      for (      String dimensionValue : dimensionSet) {
        query.addDimensionValue(groupByColumn,dimensionValue);
      }
    }
  }
  List<DimensionKey> dimensionKeys=new ArrayList<>();
  for (  String[] combination : query.getDimensionCombinations(config.getDimensions())) {
    dimensionKeys.add(new DimensionKey(combination));
  }
  Map<StarTree,Multimap<DimensionKey,Future<MetricTimeSeries>>> timeSeriesFutures=new HashMap<>();
  final List<StarTree> starTrees=new ArrayList<>(starTreeManager.getStarTrees(config.getCollection()).values());
  StarTree mutableTree=starTreeManager.getMutableStarTree(config.getCollection());
  if (mutableTree != null) {
    starTrees.add(mutableTree);
  }
  for (  final StarTree starTree : starTrees) {
    final UUID treeId=starTree.getRoot().getId();
    if (!treeIdsToQuery.contains(treeId) && !realTimeTreeIdsToQuery.contains(treeId)) {
      continue;
    }
    Multimap<DimensionKey,Future<MetricTimeSeries>> singleKeyResultMap=LinkedListMultimap.create();
    timeSeriesFutures.put(starTree,singleKeyResultMap);
    for (    final DimensionKey dimensionKey : dimensionKeys) {
      DimensionKey flattenedKey=flattenDisjunctions(config,query,dimensionKey);
      timeSeriesFutures.get(starTree).put(flattenedKey,executorService.submit(new Callable<MetricTimeSeries>(){
        @Override public MetricTimeSeries call() throws Exception {
          TimeRange timeRange=timeRangesToQuery.get(treeId);
          return starTree.getTimeSeries(new StarTreeQueryImpl(config,dimensionKey,timeRange));
        }
      }
));
    }
  }
  Map<DimensionKey,MetricTimeSeries> mergedResults=new HashMap<>();
  for (  Multimap<DimensionKey,Future<MetricTimeSeries>> resultMap : timeSeriesFutures.values()) {
    for (    Map.Entry<DimensionKey,Collection<Future<MetricTimeSeries>>> entry : resultMap.asMap().entrySet()) {
      for (      Future<MetricTimeSeries> seriesFuture : entry.getValue()) {
        MetricTimeSeries additionalSeries=seriesFuture.get();
        MetricTimeSeries currentSeries=mergedResults.get(entry.getKey());
        if (currentSeries == null) {
          currentSeries=new MetricTimeSeries(additionalSeries.getSchema());
          mergedResults.put(entry.getKey(),currentSeries);
        }
        currentSeries.aggregate(additionalSeries);
      }
    }
  }
  for (  Map.Entry<DimensionKey,MetricTimeSeries> entry : mergedResults.entrySet()) {
    MetricTimeSeries timeSeries=entry.getValue();
    for (    ThirdEyeFunction function : query.getFunctions()) {
      timeSeries=function.apply(config,query,timeSeries);
    }
    for (    ThirdEyeFunction function : query.getDerivedMetrics()) {
      timeSeries=function.apply(config,query,timeSeries);
    }
    List<String> resultMetrics=new ArrayList<>();
    resultMetrics.addAll(query.getMetricNames());
    for (    ThirdEyeFunction function : query.getDerivedMetrics()) {
      resultMetrics.add(function.toString());
    }
    ThirdEyeFunction toMillis=new ThirdEyeUnitConversionFunction(1,TimeUnit.MILLISECONDS,resultMetrics);
    timeSeries=toMillis.apply(config,query,timeSeries);
    result.addData(entry.getKey(),timeSeries);
    result.setMetrics(timeSeries.getSchema().getNames());
  }
  LOGGER.info("END Execution for query_id: {} ",query.hashCode());
  return result;
}
