{
  LOGGER.info("START Execution for query_id: {} query{}",query.hashCode(),query);
  ThirdEyeQueryResult result=new ThirdEyeQueryResult();
  final StarTreeConfig config=starTreeManager.getConfig(query.getCollection());
  if (config == null) {
    throw new IllegalArgumentException("No collection " + query.getCollection());
  }
  final List<String> dimensionNames=new ArrayList<>(config.getDimensions().size());
  for (  DimensionSpec dimensionSpec : config.getDimensions()) {
    dimensionNames.add(dimensionSpec.getName());
  }
  result.setDimensions(dimensionNames);
  long startOffset=0;
  long collectionWindowMillis=0;
  for (  ThirdEyeFunction function : query.getFunctions()) {
    if (function instanceof ThirdEyeMovingAverageFunction) {
      ThirdEyeMovingAverageFunction movingAverageFunction=(ThirdEyeMovingAverageFunction)function;
      TimeGranularity window=movingAverageFunction.getWindow();
      long windowMillis=TimeUnit.MILLISECONDS.convert(window.getSize(),window.getUnit());
      if (windowMillis > startOffset) {
        startOffset=windowMillis;
      }
    }
 else     if (function instanceof ThirdEyeAggregateFunction) {
      ThirdEyeAggregateFunction aggregateFunction=(ThirdEyeAggregateFunction)function;
      TimeGranularity window=aggregateFunction.getWindow();
      collectionWindowMillis=TimeUnit.MILLISECONDS.convert(window.getSize(),window.getUnit());
    }
  }
  long queryStartTime=dateTimeToCollectionTime(config,new DateTime(query.getStart().getMillis() - startOffset));
  long queryEndTime=dateTimeToCollectionTime(config,query.getEnd());
  if (collectionWindowMillis > 0) {
    long collectionWindow=dateTimeToCollectionTime(config,new DateTime(collectionWindowMillis));
    queryStartTime=(queryStartTime / collectionWindow) * collectionWindow;
    queryEndTime=(queryEndTime / collectionWindow + 1) * collectionWindow;
  }
  final TimeRange queryTimeRange=new TimeRange(queryStartTime,queryEndTime);
  Map<UUID,IndexMetadata> treeMetadataMap=new HashMap<UUID,IndexMetadata>();
  for (  StarTree starTree : starTreeManager.getStarTrees(config.getCollection()).values()) {
    UUID treeId=starTree.getRoot().getId();
    treeMetadataMap.put(treeId,starTreeManager.getIndexMetadata(treeId));
  }
  LOGGER.info("Selecting trees to query for queryTimeRange:{}",queryTimeRange);
  List<UUID> treeIdsToQuery=selectTreesToQuery(treeMetadataMap,queryTimeRange);
  if (!query.getGroupByColumns().isEmpty()) {
    for (    final String groupByColumn : query.getGroupByColumns()) {
      if (query.getDimensionValues().containsKey(groupByColumn)) {
        throw new IllegalArgumentException("Cannot fix dimension value in group by: " + groupByColumn);
      }
      final Set<Future<Set<String>>> dimensionSetFutures=new HashSet<>();
      for (      final StarTree starTree : starTreeManager.getStarTrees(config.getCollection()).values()) {
        if (!treeIdsToQuery.contains(starTree.getRoot().getId())) {
          continue;
        }
        dimensionSetFutures.add(executorService.submit(new Callable<Set<String>>(){
          @Override public Set<String> call() throws Exception {
            Multimap<String,String> values=query.getDimensionValues();
            Map<String,String> singleValues=new HashMap<>(values.size());
            for (            Map.Entry<String,String> entry : query.getDimensionValues().entries()) {
              if (singleValues.containsKey(entry.getKey())) {
                throw new IllegalArgumentException("Multiple values currently not supported: " + values);
              }
              singleValues.put(entry.getKey(),entry.getValue());
            }
            return starTree.getDimensionValues(groupByColumn,singleValues);
          }
        }
));
      }
      Set<String> dimensionSet=new HashSet<>();
      for (      Future<Set<String>> future : dimensionSetFutures) {
        dimensionSet.addAll(future.get());
      }
      dimensionSet.remove(StarTreeConstants.STAR);
      for (      String dimensionValue : dimensionSet) {
        query.addDimensionValue(groupByColumn,dimensionValue);
      }
    }
  }
  List<DimensionKey> dimensionKeys=new ArrayList<>();
  for (  String[] combination : query.getDimensionCombinations(config.getDimensions())) {
    dimensionKeys.add(new DimensionKey(combination));
  }
  Map<StarTree,Map<DimensionKey,Future<MetricTimeSeries>>> timeSeriesFutures=new HashMap<>();
  for (  final StarTree starTree : starTreeManager.getStarTrees(config.getCollection()).values()) {
    if (!treeIdsToQuery.contains(starTree.getRoot().getId())) {
      continue;
    }
    timeSeriesFutures.put(starTree,new HashMap<DimensionKey,Future<MetricTimeSeries>>());
    for (    final DimensionKey dimensionKey : dimensionKeys) {
      timeSeriesFutures.get(starTree).put(dimensionKey,executorService.submit(new Callable<MetricTimeSeries>(){
        @Override public MetricTimeSeries call() throws Exception {
          return starTree.getTimeSeries(new StarTreeQueryImpl(config,dimensionKey,queryTimeRange));
        }
      }
));
    }
  }
  Map<DimensionKey,MetricTimeSeries> mergedResults=new HashMap<>();
  for (  Map<DimensionKey,Future<MetricTimeSeries>> resultMap : timeSeriesFutures.values()) {
    for (    Map.Entry<DimensionKey,Future<MetricTimeSeries>> entry : resultMap.entrySet()) {
      MetricTimeSeries additionalSeries=entry.getValue().get();
      MetricTimeSeries currentSeries=mergedResults.get(entry.getKey());
      if (currentSeries == null) {
        currentSeries=new MetricTimeSeries(additionalSeries.getSchema());
        mergedResults.put(entry.getKey(),currentSeries);
      }
      currentSeries.aggregate(additionalSeries);
    }
  }
  for (  Map.Entry<DimensionKey,MetricTimeSeries> entry : mergedResults.entrySet()) {
    MetricTimeSeries timeSeries=entry.getValue();
    for (    ThirdEyeFunction function : query.getFunctions()) {
      timeSeries=function.apply(config,query,timeSeries);
    }
    for (    ThirdEyeFunction function : query.getDerivedMetrics()) {
      timeSeries=function.apply(config,query,timeSeries);
    }
    timeSeries=TO_MILLIS.apply(config,query,timeSeries);
    result.addData(entry.getKey(),timeSeries);
    result.setMetrics(timeSeries.getSchema().getNames());
  }
  LOGGER.info("END Execution for query_id: {} ",query.hashCode());
  return result;
}
