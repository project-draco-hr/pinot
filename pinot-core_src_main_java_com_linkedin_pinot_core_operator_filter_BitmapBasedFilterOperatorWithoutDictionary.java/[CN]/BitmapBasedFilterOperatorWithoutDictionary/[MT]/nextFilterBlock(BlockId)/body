{
  Predicate predicate=getPredicate();
  RealtimeInvertedIndex invertedIndex=(RealtimeInvertedIndex)dataSource.getInvertedIndex();
  Block dataSourceBlock=dataSource.nextBlock();
  List<ImmutableRoaringBitmap> bitmapList=new ArrayList<ImmutableRoaringBitmap>();
switch (predicate.getType()) {
case EQ:
    MutableRoaringBitmap eqBitmapForInQueries;
  String equalsValueToLookup=((EqPredicate)predicate).getEqualsValue();
eqBitmapForInQueries=invertedIndex.getDocIdSetFor(getNumberObjectFromString(equalsValueToLookup));
if (eqBitmapForInQueries != null) {
bitmapList.add(eqBitmapForInQueries);
}
break;
case NEQ:
String neqValue=((NEqPredicate)predicate).getNotEqualsValue();
MutableRoaringBitmap neqBitmap=invertedIndex.getDocIdSetFor(getNumberObjectFromString(neqValue));
if (neqBitmap == null) {
neqBitmap=new MutableRoaringBitmap();
}
neqBitmap.flip(0,neqBitmap.getCardinality());
bitmapList.add(neqBitmap);
break;
case IN:
String[] inRangeStrings=((InPredicate)predicate).getInRange();
Set<String> inRangeStringSet=new HashSet<String>(Arrays.asList(inRangeStrings));
for (String rawValueInString : inRangeStringSet) {
MutableRoaringBitmap bitmap=invertedIndex.getDocIdSetFor(getNumberObjectFromString(rawValueInString));
if (bitmap != null) {
bitmapList.add(bitmap);
}
}
break;
case NOT_IN:
final String[] notInValues=((NotInPredicate)predicate).getNotInRange();
final MutableRoaringBitmap notINHolder=new MutableRoaringBitmap();
for (String notInValue : notInValues) {
MutableRoaringBitmap notBitmap=invertedIndex.getDocIdSetFor(getNumberObjectFromString(notInValue));
if (notBitmap != null) {
notINHolder.or(notBitmap);
}
}
notINHolder.flip(0,notINHolder.getCardinality());
bitmapList.add(notINHolder);
break;
case RANGE:
double rangeStart=0;
double rangeEnd=0;
final boolean incLower=((RangePredicate)predicate).includeLowerBoundary();
final boolean incUpper=((RangePredicate)predicate).includeUpperBoundary();
final String lower=((RangePredicate)predicate).getLowerBoundary();
final String upper=((RangePredicate)predicate).getUpperBoundary();
if (lower.equals("*")) {
rangeStart=Double.NEGATIVE_INFINITY;
}
 else {
rangeStart=Double.parseDouble(lower);
if (incLower) {
rangeStart=getSmallerDoubleValue(rangeStart);
}
}
if (upper.equals("*")) {
rangeEnd=Double.POSITIVE_INFINITY;
}
 else {
rangeEnd=Double.parseDouble(upper);
if (incUpper) {
rangeEnd=getLargerDoubleValue(rangeEnd);
}
}
for (Object invKey : ((MetricInvertedIndex)invertedIndex).getKeys()) {
double invKeyDouble=((Number)invKey).doubleValue();
if (rangeStart < invKeyDouble && invKeyDouble < rangeEnd) {
bitmapList.add(invertedIndex.getDocIdSetFor(invKey));
}
}
break;
case REGEX:
throw new UnsupportedOperationException("Regex not supported");
}
ImmutableRoaringBitmap[] bitmaps=new ImmutableRoaringBitmap[bitmapList.size()];
bitmapList.toArray(bitmaps);
bitmapBlock=new BitmapBlock(dataSource.getOperatorName(),dataSourceBlock.getMetadata(),bitmaps);
return bitmapBlock;
}
