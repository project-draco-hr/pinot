{
  String metricFunction="AGGREGATE_1_HOURS(" + METRIC_FUNCTION_JOINER.join(metricList) + ")";
  DateTime current=new DateTime(year,month,day,0,0);
  DateTime baseline=current.minusWeeks(1);
  MultivaluedMap<String,String> dimensionValues=queryParams;
  if (groupBy != null) {
    if (dimensionValues.containsKey(groupBy)) {
      throw new IllegalArgumentException("Cannot group by fixed dimension");
    }
    dimensionValues.put(groupBy,Arrays.asList("!"));
  }
  String sql=SqlUtils.getSql(metricFunction,collection,baseline,current,dimensionValues);
  QueryResult result=queryCache.getQueryResult(serverUri,sql);
  CollectionSchema schema=dataCache.getCollectionSchema(serverUri,collection);
  int groupByIdx=-1;
  for (int i=0; i < schema.getDimensions().size(); i++) {
    if (schema.getDimensions().get(i).equals(groupBy)) {
      groupByIdx=i;
      break;
    }
  }
  Map<String,Map<Long,Number>> groupedSeries=new HashMap<>();
  final Map<String,Long> aggregates=new HashMap<>();
  for (  Map.Entry<String,Map<String,Number[]>> entry : result.getData().entrySet()) {
    String dimensionValue="";
    if (groupByIdx >= 0) {
      List<String> values=objectMapper.readValue(entry.getKey(),LIST_REF);
      dimensionValue=values.get(groupByIdx);
    }
    Map<Long,Number> series=new HashMap<>();
    aggregates.put(dimensionValue,0L);
    groupedSeries.put(dimensionValue,series);
    for (    Map.Entry<String,Number[]> dataPoint : entry.getValue().entrySet()) {
      Long time=Long.valueOf(dataPoint.getKey());
      Number value=dataPoint.getValue()[0];
      series.put(time,value);
      aggregates.put(dimensionValue,aggregates.get(dimensionValue) + value.longValue());
    }
  }
  List<String> chosenValues=new ArrayList<>(groupedSeries.keySet());
  Collections.sort(chosenValues,new Comparator<String>(){
    @Override public int compare(    String o1,    String o2){
      return (int)(aggregates.get(o2) - aggregates.get(o1));
    }
  }
);
  if (chosenValues.size() > 5) {
    chosenValues=chosenValues.subList(0,5);
  }
  List<Long> times=new ArrayList<>();
  DateTime cursor=new DateTime(baseline.getMillis());
  while (cursor.compareTo(current) < 0) {
    times.add(cursor.getMillis());
    cursor=cursor.plusHours(1);
  }
  Map<String,List<Number[]>> allSeries=new HashMap<>();
  for (  String chosenValue : chosenValues) {
    Map<Long,Number> seriesMap=groupedSeries.get(chosenValue);
    List<Number[]> series=new ArrayList<>();
    for (    Long time : times) {
      Number value=seriesMap.get(time);
      series.add(new Number[]{time,value == null ? 0 : value});
    }
    allSeries.put(chosenValue,series);
  }
  return new CustomTimeSeriesView(allSeries);
}
