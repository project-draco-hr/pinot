{
  long startTime=Collections.min(series.getTimeWindowSet());
  long endTime=Collections.max(series.getTimeWindowSet());
  int numValues=(int)(1 + ((endTime - startTime) / bucketWidthInMillis));
  double[] values=new double[numValues];
  long[] timestamps=new long[numValues];
  for (int i=0; i < numValues; i++) {
    long timeWindow=startTime + (i * bucketWidthInMillis);
    timestamps[i]=timeWindow;
    if (series.getTimeWindowSet().contains(timeWindow)) {
      values[i]=series.get(timeWindow,metric).doubleValue();
    }
 else {
      values[i]=defaultValue;
      if (missingTimeStamps != null) {
        missingTimeStamps.add(timeWindow);
      }
    }
  }
  if (numValues != series.getTimeWindowSet().size()) {
    LOGGER.warn("looks like there are holes in the data: expected {} timestamps, found {}",numValues,series.getTimeWindowSet().size());
  }
  return new Pair<>(timestamps,values);
}
