{
  long newTimeIntervalStart=timeInterval.getStart() - (length * TimeGranularityUtils.toMillis(childFunc.getAggregationTimeGranularity()));
  TimeRange timeIntervalExtended=new TimeRange(newTimeIntervalStart,timeInterval.getEnd());
  List<AnomalyResult> consecutiveResults=new ArrayList<AnomalyResult>(series.getTimeWindowSet().size());
  List<AnomalyResult> intermediateResults=childFunc.analyze(dimensionKey,series,timeIntervalExtended);
  HashMap<Long,AnomalyResult> mappedResults=new HashMap<>();
  for (  AnomalyResult ar : intermediateResults) {
    mappedResults.put(ar.getTimeWindow(),ar);
  }
  long windowGranularity=TimeGranularityUtils.toMillis(childFunc.getAggregationTimeGranularity());
  for (  Long timeWindow : mappedResults.keySet()) {
    int anomalyCount=0;
    double scoreAvg=0;
    double volumeAvg=0;
    for (int i=0; i < length; i++) {
      long currentTimeWindow=timeWindow - (i * windowGranularity);
      if (mappedResults.containsKey(currentTimeWindow)) {
        AnomalyResult currResult=mappedResults.get(currentTimeWindow);
        anomalyCount+=(currResult.isAnomaly()) ? 1 : 0;
        scoreAvg+=currResult.getAnomalyScore() / length;
        volumeAvg+=currResult.getAnomalyVolume() / length;
      }
 else {
        break;
      }
    }
    consecutiveResults.add(new AnomalyResult(anomalyCount == length,timeWindow,scoreAvg,volumeAvg,mappedResults.get(timeWindow).getProperties()));
  }
  return consecutiveResults;
}
