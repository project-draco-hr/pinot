{
  int recordCount=0;
  long MAX_TIME_EXPECTED=Long.MIN_VALUE;
  long MIN_TIME_EXPECTED=Long.MAX_VALUE;
  long MAX_TIME_ACTUAL=Long.MIN_VALUE;
  long MIN_TIME_ACTUAL=Long.MAX_VALUE;
  List<GenericRecord> inputRecords=generateTestData();
  for (  GenericRecord record : inputRecords) {
    AvroKey<GenericRecord> inKey=new AvroKey<GenericRecord>();
    inKey.datum(record);
    mapDriver.addInput(new Pair<AvroKey<GenericRecord>,NullWritable>(inKey,NullWritable.get()));
    recordCount++;
    MAX_TIME_EXPECTED=Math.max(MAX_TIME_EXPECTED,Long.parseLong(record.get("hoursSinceEpoch").toString()));
    MIN_TIME_EXPECTED=Math.max(MIN_TIME_EXPECTED,Long.parseLong(record.get("hoursSinceEpoch").toString()));
  }
  List<Pair<BytesWritable,BytesWritable>> result=mapDriver.run();
  Assert.assertEquals(recordCount,result.size());
  for (  Pair<BytesWritable,BytesWritable> p : result) {
    List<BytesWritable> tmp=new ArrayList<BytesWritable>();
    tmp.add(p.getSecond());
    reduceDriver.addInput(new Pair<BytesWritable,List<BytesWritable>>(p.getFirst(),tmp));
  }
  List<Pair<BytesWritable,NullWritable>> r=reduceDriver.run();
  for (  Pair<BytesWritable,NullWritable> p : r) {
    BytesWritable value=p.getFirst();
    MAX_TIME_ACTUAL=Math.max(MAX_TIME_ACTUAL,AnalysisPhaseStats.fromBytes(value.copyBytes()).getMaxTime());
    MIN_TIME_ACTUAL=Math.max(MIN_TIME_EXPECTED,AnalysisPhaseStats.fromBytes(value.copyBytes()).getMaxTime());
  }
  Assert.assertEquals(MAX_TIME_EXPECTED,MAX_TIME_ACTUAL);
  Assert.assertEquals(MIN_TIME_EXPECTED,MIN_TIME_ACTUAL);
}
