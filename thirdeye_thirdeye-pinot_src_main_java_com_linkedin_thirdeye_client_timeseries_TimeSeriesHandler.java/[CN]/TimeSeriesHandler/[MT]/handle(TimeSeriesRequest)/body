{
  List<String> groupByDimensions=timeSeriesRequest.getGroupByDimensions();
  boolean hasGroupByDimensions=CollectionUtils.isNotEmpty(groupByDimensions);
  List<Range<DateTime>> timeRanges=timeSeriesRequest.getTimeRanges();
  Map<TimeSeriesRequest,Map<ThirdEyeRequest,Future<ThirdEyeResponse>>> subRequestQueryResponseMap=new HashMap<>();
  for (  Range<DateTime> range : timeRanges) {
    TimeSeriesRequest subTimeSeriesRequest=new TimeSeriesRequest(timeSeriesRequest);
    subTimeSeriesRequest.setStart(range.lowerEndpoint());
    subTimeSeriesRequest.setEnd(range.upperEndpoint());
    List<ThirdEyeRequest> subRequests;
    if (hasGroupByDimensions) {
      subRequests=requestGenerator.generateRequestsForGroupByDimensions(subTimeSeriesRequest);
    }
 else {
      subRequests=Collections.singletonList(requestGenerator.generateRequestsForAggregation(subTimeSeriesRequest));
    }
    Map<ThirdEyeRequest,Future<ThirdEyeResponse>> queryResponseFutureMap=queryCache.getQueryResultsAsync(subRequests);
    subRequestQueryResponseMap.put(subTimeSeriesRequest,queryResponseFutureMap);
  }
  List<TimeSeriesRow> rows=new ArrayList<>();
  for (  Entry<TimeSeriesRequest,Map<ThirdEyeRequest,Future<ThirdEyeResponse>>> entry : subRequestQueryResponseMap.entrySet()) {
    TimeSeriesRequest subTimeSeriesRequest=entry.getKey();
    Map<ThirdEyeRequest,ThirdEyeResponse> queryResponseMap=waitForFutures(entry.getValue());
    if (hasGroupByDimensions) {
      rows.addAll(responseParser.parseGroupByDimensionResponse(subTimeSeriesRequest,queryResponseMap));
    }
 else {
      rows.add(responseParser.parseAggregationOnlyResponse(subTimeSeriesRequest,queryResponseMap));
    }
  }
  List<MetricExpression> metricExpressions=timeSeriesRequest.getMetricExpressions();
  List<MetricExpression> derivedMetricExpressions=new ArrayList<>();
  for (  MetricExpression expression : metricExpressions) {
    if (expression.computeMetricFunctions().size() > 1) {
      derivedMetricExpressions.add(expression);
    }
  }
  if (derivedMetricExpressions.size() > 0) {
    Map<String,Double> metricValueContext=new HashMap<>();
    for (    TimeSeriesRow row : rows) {
      metricValueContext.clear();
      List<TimeSeriesMetric> metrics=row.getMetrics();
      for (      TimeSeriesMetric metric : metrics) {
        metricValueContext.put(metric.getMetricName(),metric.getValue());
      }
      for (      MetricExpression expression : derivedMetricExpressions) {
        String derivedMetricExpression=expression.getExpression();
        double derivedMetricValue=MetricExpression.evaluateExpression(derivedMetricExpression,metricValueContext);
        row.getMetrics().add(new TimeSeriesMetric(expression.getEspressionName(),derivedMetricValue));
      }
    }
  }
  return new TimeSeriesResponse(metricExpressions,groupByDimensions,rows);
}
