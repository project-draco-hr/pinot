{
  long start=System.nanoTime();
  if (targetDocId < startDocId) {
    targetDocId=startDocId;
  }
 else   if (targetDocId > endDocId) {
    currentDocId=Constants.EOF;
  }
  if (currentDocId == Constants.EOF) {
    return currentDocId;
  }
  Iterator<IntPair> iterator=queue.iterator();
  while (iterator.hasNext()) {
    IntPair pair=iterator.next();
    if (pair.getA() < targetDocId) {
      iterator.remove();
      iteratorIsInQueue[pair.getB()]=false;
    }
  }
  for (int i=0; i < iterators.length; i++) {
    if (!iteratorIsInQueue[i]) {
      int next;
      while (iterators[i].hasNext()) {
        next=iterators[i].next();
        if (next > endDocId) {
          break;
        }
        if (next >= targetDocId) {
          queue.add(new IntPair(next,i));
          break;
        }
      }
      iteratorIsInQueue[i]=true;
    }
  }
  if (queue.size() > 0) {
    currentDocId=queue.peek().getA();
  }
 else {
    currentDocId=Constants.EOF;
  }
  long end=System.nanoTime();
  timeMeasure.addAndGet(end - start);
  return currentDocId;
}
