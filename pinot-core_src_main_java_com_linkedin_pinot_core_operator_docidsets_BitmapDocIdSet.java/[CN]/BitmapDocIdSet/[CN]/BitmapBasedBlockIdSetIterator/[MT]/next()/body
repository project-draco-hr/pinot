{
  long start=System.nanoTime();
  if (currentDocId == Constants.EOF) {
    return currentDocId;
  }
  while (queue.size() > 0 && queue.peek().getA() <= currentDocId) {
    IntPair pair=queue.remove();
    iteratorIsInQueue[pair.getB()]=false;
  }
  currentDocId++;
  for (int i=0; i < iterators.length; i++) {
    if (!iteratorIsInQueue[i]) {
      while (iterators[i].hasNext()) {
        int next=iterators[i].next();
        if (next >= startDocId && next <= endDocId && next >= currentDocId) {
          queue.add(new IntPair(next,i));
          break;
        }
        if (next > endDocId) {
          break;
        }
      }
      iteratorIsInQueue[i]=true;
    }
  }
  if (queue.size() > 0) {
    currentDocId=queue.peek().getA();
  }
 else {
    currentDocId=Constants.EOF;
  }
  long end=System.nanoTime();
  timeMeasure.addAndGet(end - start);
  return currentDocId;
}
