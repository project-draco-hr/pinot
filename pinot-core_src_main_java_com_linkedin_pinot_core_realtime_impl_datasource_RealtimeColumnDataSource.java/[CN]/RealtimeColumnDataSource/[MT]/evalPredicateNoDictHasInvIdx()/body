{
switch (predicate.getType()) {
case EQ:
    MutableRoaringBitmap eqBitmapForInQueries;
  String equalsValueToLookup=((EqPredicate)predicate).getEqualsValue();
eqBitmapForInQueries=invertedIndex.getDocIdSetFor(getNumberObjectFromString(equalsValueToLookup));
if (eqBitmapForInQueries == null) {
eqBitmapForInQueries=new MutableRoaringBitmap();
}
filteredDocIdBitmap=eqBitmapForInQueries;
break;
case IN:
MutableRoaringBitmap orBitmapForInQueries=new MutableRoaringBitmap();
String[] inRangeStrings=((InPredicate)predicate).getInRange();
for (String rawValueInString : inRangeStrings) {
MutableRoaringBitmap bitmap=invertedIndex.getDocIdSetFor(getNumberObjectFromString(rawValueInString));
if (bitmap != null) {
orBitmapForInQueries.or(bitmap);
}
}
filteredDocIdBitmap=orBitmapForInQueries;
break;
case NEQ:
MutableRoaringBitmap neqBitmap;
String neqValue=((NEqPredicate)predicate).getNotEqualsValue();
neqBitmap=invertedIndex.getDocIdSetFor(getNumberObjectFromString(neqValue));
if (neqBitmap == null) {
neqBitmap=new MutableRoaringBitmap();
}
neqBitmap.flip(0,offset + 1);
filteredDocIdBitmap=neqBitmap;
break;
case NOT_IN:
final String[] notInValues=((NotInPredicate)predicate).getNotInRange();
final MutableRoaringBitmap notINHolder=new MutableRoaringBitmap();
for (String notInValue : notInValues) {
MutableRoaringBitmap notBitmap=invertedIndex.getDocIdSetFor(getNumberObjectFromString(notInValue));
if (notBitmap != null) {
notINHolder.or(notBitmap);
}
}
notINHolder.flip(0,offset + 1);
filteredDocIdBitmap=notINHolder;
break;
case RANGE:
double rangeStart=0;
double rangeEnd=0;
final boolean incLower=((RangePredicate)predicate).includeLowerBoundary();
final boolean incUpper=((RangePredicate)predicate).includeUpperBoundary();
final String lower=((RangePredicate)predicate).getLowerBoundary();
final String upper=((RangePredicate)predicate).getUpperBoundary();
if (lower.equals("*")) {
rangeStart=Double.NEGATIVE_INFINITY;
}
 else {
rangeStart=Double.parseDouble(lower);
if (incLower) {
rangeStart=getSmallerDoubleValue(rangeStart);
}
}
if (upper.equals("*")) {
rangeEnd=Double.POSITIVE_INFINITY;
}
 else {
rangeEnd=Double.parseDouble(upper);
if (incUpper) {
rangeEnd=getLargerDoubleValue(rangeEnd);
}
}
MutableRoaringBitmap rangeBitmap=new MutableRoaringBitmap();
for (Object invKey : ((MetricInvertedIndex)invertedIndex).getKeys()) {
double invKeyDouble=((Number)invKey).doubleValue();
if (rangeStart < invKeyDouble && invKeyDouble < rangeEnd) {
rangeBitmap.or(invertedIndex.getDocIdSetFor(invKey));
}
}
filteredDocIdBitmap=rangeBitmap;
break;
case REGEX:
throw new UnsupportedOperationException("regex filter not supported");
}
return true;
}
