{
  this.predicate=predicate;
switch (predicate.getType()) {
case EQ:
    String equalsValueToLookup=predicate.getRhs().get(0);
  filteredDocIdBitmap=invertedINdex.getDocIdSetFor(dictionary.indexOf(equalsValueToLookup));
break;
case IN:
MutableRoaringBitmap orBitmapForInQueries=new MutableRoaringBitmap();
int[] dicIdsToOrTogether=new int[predicate.getRhs().get(0).split(",").length];
int counter=0;
for (String rawValueInString : predicate.getRhs().get(0).split(",")) {
dicIdsToOrTogether[counter++]=dictionary.indexOf(rawValueInString);
}
for (int dicId : dicIdsToOrTogether) {
orBitmapForInQueries.or(invertedINdex.getDocIdSetFor(dicId));
}
filteredDocIdBitmap=orBitmapForInQueries;
break;
case NEQ:
MutableRoaringBitmap neqBitmap=new MutableRoaringBitmap();
int valueToExclude=predicate.getRhs().get(0) == null ? 0 : dictionary.indexOf(predicate.getRhs().get(0));
for (int i=1; i <= dictionary.length(); i++) {
if (valueToExclude != i) {
neqBitmap.or(invertedINdex.getDocIdSetFor(i));
}
}
filteredDocIdBitmap=neqBitmap;
break;
case NOT_IN:
final String[] notInValues=predicate.getRhs().get(0).split(",");
final List<Integer> notInIds=new ArrayList<Integer>();
for (final String notInValue : notInValues) {
notInIds.add(new Integer(dictionary.indexOf(notInValue)));
}
final MutableRoaringBitmap notINHolder=new MutableRoaringBitmap();
for (int i=0; i < dictionary.length(); i++) {
if (!notInIds.contains(new Integer(i))) {
notINHolder.or(invertedINdex.getDocIdSetFor(i));
}
}
break;
case RANGE:
String rangeStart="";
String rangeEnd="";
final String rangeString=predicate.getRhs().get(0);
boolean incLower=true;
boolean incUpper=true;
if (rangeString.trim().startsWith("(")) {
incLower=false;
}
if (rangeString.trim().endsWith(")")) {
incUpper=false;
}
final String lower=rangeString.split(",")[0].substring(1,rangeString.split(",")[0].length());
final String upper=rangeString.split(",")[1].substring(0,rangeString.split(",")[1].length() - 1);
if (lower.equals("*")) {
rangeStart=dictionary.getString(0);
}
if (upper.equals("*")) {
rangeEnd=dictionary.getString(dictionary.length() - 1);
}
List<Integer> rangeCollector=new ArrayList<Integer>();
for (int i=0; i < dictionary.length(); i++) {
if (dictionary.inRange(rangeStart,rangeEnd,i,incLower,incUpper)) {
rangeCollector.add(i);
}
}
MutableRoaringBitmap rangeBitmap=new MutableRoaringBitmap();
for (Integer dicId : rangeCollector) {
rangeBitmap.or(invertedINdex.getDocIdSetFor(dicId));
}
filteredDocIdBitmap=rangeBitmap;
break;
case REGEX:
throw new UnsupportedOperationException("regex filter not supported");
}
return true;
}
