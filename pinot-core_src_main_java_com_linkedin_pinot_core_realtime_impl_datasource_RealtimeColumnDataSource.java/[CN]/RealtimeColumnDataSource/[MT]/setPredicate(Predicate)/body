{
  this.predicate=predicate;
switch (predicate.getType()) {
case EQ:
    String equalsValueToLookup=((EqPredicate)predicate).getEqualsValue();
  if (dictionary.contains(equalsValueToLookup)) {
    filteredDocIdBitmap=invertedINdex.getDocIdSetFor(dictionary.indexOf(equalsValueToLookup));
  }
 else {
    filteredDocIdBitmap=new MutableRoaringBitmap();
  }
break;
case IN:
MutableRoaringBitmap orBitmapForInQueries=new MutableRoaringBitmap();
String[] inRangeStrings=((InPredicate)predicate).getInRange();
for (String rawValueInString : inRangeStrings) {
if (dictionary.contains(rawValueInString)) {
int dictId=dictionary.indexOf(rawValueInString);
orBitmapForInQueries.or(invertedINdex.getDocIdSetFor(dictId));
}
}
filteredDocIdBitmap=orBitmapForInQueries;
break;
case NEQ:
MutableRoaringBitmap neqBitmap=new MutableRoaringBitmap();
String neqValue=((NEqPredicate)predicate).getNotEqualsValue();
int valueToExclude=-1;
if (neqValue == null) {
valueToExclude=0;
}
 else if (neqValue != null && dictionary.contains(neqValue)) {
valueToExclude=dictionary.indexOf(neqValue);
}
for (int i=1; i <= dictionary.length(); i++) {
if (valueToExclude != i) {
neqBitmap.or(invertedINdex.getDocIdSetFor(i));
}
}
filteredDocIdBitmap=neqBitmap;
break;
case NOT_IN:
final String[] notInValues=((NotInPredicate)predicate).getNotInRange();
final Set<Integer> notInIds=new HashSet<Integer>();
for (final String notInValue : notInValues) {
if (dictionary.contains(notInValue)) {
notInIds.add(dictionary.indexOf(notInValue));
}
}
final MutableRoaringBitmap notINHolder=new MutableRoaringBitmap();
for (int i=0; i < dictionary.length(); i++) {
if (!notInIds.contains(new Integer(i))) {
notINHolder.or(invertedINdex.getDocIdSetFor(i));
}
}
filteredDocIdBitmap=notINHolder;
break;
case RANGE:
String rangeStart="";
String rangeEnd="";
final boolean incLower=((RangePredicate)predicate).includeLowerBoundary();
final boolean incUpper=((RangePredicate)predicate).includeUpperBoundary();
final String lower=((RangePredicate)predicate).getLowerBoundary();
final String upper=((RangePredicate)predicate).getUpperBoundary();
if (lower.equals("*")) {
rangeStart=dictionary.getStringValue(REALTIME_DICTIONARY_INIT_ID);
}
 else {
rangeStart=lower;
}
if (upper.equals("*")) {
rangeEnd=dictionary.getStringValue(dictionary.length());
}
 else {
rangeEnd=upper;
}
MutableRoaringBitmap rangeBitmap=new MutableRoaringBitmap();
for (int dicId=1; dicId <= dictionary.length(); dicId++) {
if (dictionary.inRange(rangeStart,rangeEnd,dicId,incLower,incUpper)) {
rangeBitmap.or(invertedINdex.getDocIdSetFor(dicId));
}
}
filteredDocIdBitmap=rangeBitmap;
break;
case REGEX:
throw new UnsupportedOperationException("regex filter not supported");
}
return true;
}
