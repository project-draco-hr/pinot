{
  final long transitionStartTimeMs=now();
  long timeoutMs=_maxTimeForConsumingToOnlineSec * 1000L;
  LLCRealtimeSegmentZKMetadata llcMetadata=(LLCRealtimeSegmentZKMetadata)metadata;
  final long endOffset=llcMetadata.getEndOffset();
  segmentLogger.info("State: {}, transitioning from CONSUMING to ONLINE (startOffset: {}, endOffset: {})",_state.toString(),_startOffset,endOffset);
  stop(timeoutMs);
  long now=now();
  timeoutMs-=(now - transitionStartTimeMs);
  segmentLogger.info("Consumer thread stopped in state {}. Time remaining to catchup: {}ms",_state.toString(),timeoutMs);
  if (timeoutMs <= 0) {
    throw new RuntimeException("Could not get to stop consumer thread" + _consumerThread);
  }
switch (_state) {
case COMMITTED:
case RETAINED:
    segmentLogger.info("State {}. Nothing to do",_state.toString());
  break;
case DISCARDED:
case ERROR:
segmentLogger.info("State {}. Downloading to replace",_state.toString());
downloadSegmentAndReplace(llcMetadata);
break;
case CATCHING_UP:
case HOLDING:
case INITIAL_CONSUMING:
if (_currentOffset > endOffset) {
segmentLogger.warn("Current offset {} ahead of the offset in zk {}. Downloading to replace",_currentOffset,endOffset);
downloadSegmentAndReplace(llcMetadata);
}
 else if (_currentOffset == endOffset) {
segmentLogger.info("Current offset {} matches offset in zk {}. Replacing segment",_currentOffset,endOffset);
buildSegmentAndReplace();
}
 else {
segmentLogger.info("Attempting to catch up from offset {} to {} ",_currentOffset,endOffset);
boolean success=catchupToFinalOffset(endOffset,timeoutMs);
if (success) {
segmentLogger.info("Caught up to offset {}",_currentOffset);
buildSegmentAndReplace();
}
 else {
segmentLogger.info("Could not catch up to offset (current = {}). Downloading to replace",_currentOffset);
downloadSegmentAndReplace(llcMetadata);
}
}
break;
default :
segmentLogger.info("Downloading to replace segment while in state {}",_state.toString());
downloadSegmentAndReplace(llcMetadata);
break;
}
}
