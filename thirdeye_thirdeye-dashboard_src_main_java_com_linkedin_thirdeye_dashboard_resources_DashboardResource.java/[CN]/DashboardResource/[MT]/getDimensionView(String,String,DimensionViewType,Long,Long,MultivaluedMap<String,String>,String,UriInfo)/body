{
  CollectionSchema schema=dataCache.getCollectionSchema(serverUri,collection);
  DateTime baseline=new DateTime(baselineMillis);
  DateTime current=new DateTime(currentMillis);
  Map<String,Map<String,List<String>>> reverseDimensionGroups=null;
  DimensionGroupSpec dimensionGroupSpec=configCache.getDimensionGroupSpec(collection);
  if (dimensionGroupSpec != null) {
    reverseDimensionGroups=dimensionGroupSpec.getReverseMapping();
  }
switch (dimensionViewType) {
case CONTRIBUTOR:
case MULTI_TIME_SERIES:
    List<String> viewDimensions=dashboardConfigResource.getDimensions(collection,uriInfo);
  return contributorResource.generateDimensionContributorView(collection,metricFunction,selectedDimensions,uriInfo,viewDimensions,baseline,current,reverseDimensionGroups);
case HEAT_MAP:
Map<String,Future<QueryResult>> resultCurrentFutures=new HashMap<>();
Map<String,Future<QueryResult>> resultBaselineFutures=new HashMap<>();
for (String dimension : schema.getDimensions()) {
if (!selectedDimensions.containsKey(dimension)) {
selectedDimensions.put(dimension,Arrays.asList("!"));
String currentSql=SqlUtils.getSql(metricFunction,collection,current,current,selectedDimensions,reverseDimensionGroups);
String baselineSql=SqlUtils.getSql(metricFunction,collection,baseline,baseline,selectedDimensions,reverseDimensionGroups);
LOGGER.info("Generated current SQL for heat map {}: {}",uriInfo.getRequestUri(),currentSql);
LOGGER.info("Generated baseline SQL for heat map {}: {}",uriInfo.getRequestUri(),baselineSql);
selectedDimensions.remove(dimension);
resultCurrentFutures.put(dimension,queryCache.getQueryResultAsync(serverUri,currentSql));
resultBaselineFutures.put(dimension,queryCache.getQueryResultAsync(serverUri,baselineSql));
}
}
Map<String,Map<String,String>> dimensionGroups=null;
Map<String,Map<Pattern,String>> dimensionRegex=null;
DimensionGroupSpec groupSpec=configCache.getDimensionGroupSpec(collection);
if (groupSpec != null) {
dimensionGroups=groupSpec.getMapping();
dimensionRegex=groupSpec.getRegexMapping();
}
Map<String,QueryResult> currentResults=QueryUtils.waitForQueries(resultCurrentFutures);
Map<String,QueryResult> baselineResults=QueryUtils.waitForQueries(resultBaselineFutures);
Map<String,QueryResult> mergedResults=QueryUtils.mergeQueryMaps(currentResults,baselineResults);
return new DimensionViewHeatMap(schema,objectMapper,mergedResults,dimensionGroups,dimensionRegex);
case TABULAR:
List<FunnelTable> funnelTables=funnelResource.computeFunnelViews(collection,metricFunction,funnels,baselineMillis,currentMillis,selectedDimensions);
return new DimensionViewFunnel(funnelTables);
default :
throw new NotFoundException("No dimension view implementation for " + dimensionViewType);
}
}
