{
  final JSONArray jsonArray=new JSONArray();
  Map<String,Integer> columnToIdxMapping=buildColumnToIdxMappingForDataSchema(dataSchema);
  for (int i=0; i < _selectionColumns.size(); ++i) {
    if (!columnToIdxMapping.containsKey(_selectionColumns.get(i))) {
      jsonArray.put((String)null);
    }
 else {
      int colIdx=columnToIdxMapping.get(_selectionColumns.get(i));
      if (dataSchema.getColumnType(colIdx).isSingleValue()) {
        if (dataSchema.getColumnType(colIdx) == DataType.STRING) {
          jsonArray.put(poll[colIdx]);
        }
 else {
          jsonArray.put(DEFAULT_FORMAT_STRING_MAP.get(dataSchema.getColumnType(colIdx)).format(poll[colIdx]));
        }
      }
 else {
        JSONArray stringJsonArray=new JSONArray();
switch (dataSchema.getColumnType(colIdx)) {
case STRING_ARRAY:
          String[] stringValues=(String[])poll[colIdx];
        for (        String s : stringValues) {
          stringJsonArray.put(s);
        }
      break;
case INT_ARRAY:
    int[] intValues=(int[])poll[colIdx];
  for (  int s : intValues) {
    stringJsonArray.put(DEFAULT_FORMAT_STRING_MAP.get(dataSchema.getColumnType(colIdx)).format(s));
  }
break;
case FLOAT_ARRAY:
float[] floatValues=(float[])poll[colIdx];
for (float s : floatValues) {
stringJsonArray.put(DEFAULT_FORMAT_STRING_MAP.get(dataSchema.getColumnType(colIdx)).format(s));
}
break;
case LONG_ARRAY:
long[] longValues=(long[])poll[colIdx];
for (long s : longValues) {
stringJsonArray.put(DEFAULT_FORMAT_STRING_MAP.get(dataSchema.getColumnType(colIdx)).format(s));
}
break;
case DOUBLE_ARRAY:
double[] doubleValues=(double[])poll[colIdx];
for (double s : doubleValues) {
stringJsonArray.put(DEFAULT_FORMAT_STRING_MAP.get(dataSchema.getColumnType(colIdx)).format(s));
}
break;
default :
break;
}
jsonArray.put(stringJsonArray);
}
}
}
return jsonArray;
}
