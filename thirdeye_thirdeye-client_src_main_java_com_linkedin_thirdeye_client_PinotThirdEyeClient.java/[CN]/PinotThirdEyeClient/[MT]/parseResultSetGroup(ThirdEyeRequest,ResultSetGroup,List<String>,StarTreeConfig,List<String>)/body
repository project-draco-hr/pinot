{
  HashMap<String,Map<String,Number[]>> data=new HashMap<String,Map<String,Number[]>>();
  String baseDimensionKeyFormatter=calculateBaseDimensionKey(dimensionNames,request.getGroupBy());
  TimeGranularity bucketGranularity=starTreeConfig.getTime().getBucket();
  TimeGranularity aggGranularity=request.getTimeGranularity();
  DateTime startTime=request.getStartTime();
  int columnOffset=0;
  for (int groupIdx=0; groupIdx < result.getResultSetCount(); groupIdx++) {
    ResultSet resultSet=result.getResultSet(groupIdx);
    int columnCount=resultSet.getColumnCount();
    for (int row=0; row < resultSet.getRowCount(); row++) {
      String dimensionKey;
      String timestamp=null;
      if (resultSet.getGroupKeyLength() > 0) {
        List<String> dimensionKeyList=new LinkedList<String>();
        for (int group=0; group < resultSet.getGroupKeyLength(); group++) {
          String timeKey=resultSet.getGroupKeyString(row,group);
          if (group == 0) {
            timestamp=calculateTimeStamp(timeKey,bucketGranularity,aggGranularity,startTime);
          }
 else {
            dimensionKeyList.add(timeKey);
          }
        }
        dimensionKey=String.format(baseDimensionKeyFormatter,dimensionKeyList.toArray());
        dimensionKey=MAPPER.writeValueAsString(dimensionKey.split(","));
      }
 else {
        throw new RuntimeException("Error: no dimension key can be derived from the results.");
      }
      Double[] rowData=getRowData(data,rawMetrics.size(),dimensionKey,timestamp);
      for (int col=0; col < columnCount; col++) {
        String colValStr=resultSet.getString(row,col);
        int metricIdx=col + columnOffset;
        rowData[metricIdx]+=Double.valueOf(colValStr);
      }
    }
    columnOffset+=columnCount;
  }
  return data;
}
